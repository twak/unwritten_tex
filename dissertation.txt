Unwritten Procedural Modeling
with Skeletons

Tom Kelly
Submitted in fulfilment of the requirements for the degree of
Doctor of Philosophy

School of Computing Science
College of Science and Engineering
University of Glasgow

July 2012

c Tom Kelly

Abstract
We introduce the weighted straight skeleton as a procedural modeling operation and
show how it can be used to construct procedural models without written programs.
We demonstrate the application of the skeleton to modeling urban environments. In
particular we apply the skeleton to subdividing city blocks into parcels and the architectural design of buildings.

Crow Road for keeping me sane.
Ron Poet, Peter Wonka, Paul Cockshott & Pascal M¨ller for letting me be insane.
u

Table of Contents
1 Introduction

1

1.1

Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

1.2

Thesis Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3

2 Readings: A Spectrum of Proceduralisation

4

2.1

General Purpose Programming Languages . . . . . . . . . . . . . . . .

5

2.2

Formal String Grammars . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.3

Graph Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

2.4

L-Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

2.5

Shape Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

17

2.6

Split Shape Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . .

23

2.7

Data Flow Programming . . . . . . . . . . . . . . . . . . . . . . . . . .

27

2.8

Simulation Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . .

35

2.9

Inverse Procedural Modeling . . . . . . . . . . . . . . . . . . . . . . . .

39

2.10 Combinatory Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . .

41

2.11 Shape Deformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

44

2.12 Geometry Construction . . . . . . . . . . . . . . . . . . . . . . . . . . .

47

2.13 Digital Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

51

2.14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

52

3 Various Skeletons

54

3.1

Ways of Shrinking Polygons . . . . . . . . . . . . . . . . . . . . . . . .

54

3.2

The Straight Skeleton . . . . . . . . . . . . . . . . . . . . . . . . . . . .

56

3.2.1

57

Constructing the Straight Skeleton . . . . . . . . . . . . . . . .

3.2.2

Computational Complexity of the Straight Skeleton . . . . . . .

66

3.2.3

Straight Skeleton Degenerate Events . . . . . . . . . . . . . . .

67

3.2.4

The Generalised Intersection Event . . . . . . . . . . . . . . . .

70

The Positively Weighted Straight Skeleton . . . . . . . . . . . . . . . .

76

3.3.1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

76

3.3.2

The PCE event revisited . . . . . . . . . . . . . . . . . . . . . .

79

3.4

The Negatively Weighted Straight Skeleton . . . . . . . . . . . . . . . .

81

3.5

The Mixed Weighted Straight Skeleton . . . . . . . . . . . . . . . . . .

82

3.5.1

Point degeneracies . . . . . . . . . . . . . . . . . . . . . . . . .

84

3.5.2

Removing Parallel Adjacent Edges . . . . . . . . . . . . . . . .

87

3.5.3

The Pincushion Problem . . . . . . . . . . . . . . . . . . . . . .

91

Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

97

3.3

3.6

4 Procedural Generation of Parcels

99

4.1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

4.2

Existing Parcel Subdivision Techniques . . . . . . . . . . . . . . . . . . 102

4.3

Block Subdivision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
4.3.1

Inputs, Outputs and Goals . . . . . . . . . . . . . . . . . . . . . 104

4.3.2

Skeleton-based Subdivision . . . . . . . . . . . . . . . . . . . . . 106

4.3.3

OBB-based Subdivision† . . . . . . . . . . . . . . . . . . . . . . 114

4.4

Parcel Consistency under Live Editing† . . . . . . . . . . . . . . . . . . 116

4.5

Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
4.5.1

4.6

Use within CityEngine† . . . . . . . . . . . . . . . . . . . . . . 131

Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

5 Procedural Extrusions

133

5.1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

5.2

Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

5.3

User Interface Description . . . . . . . . . . . . . . . . . . . . . . . . . 141
5.3.1

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141

5.3.2

Plans and Proﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . 142

5.3.3

Anchors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

5.3.4

Plan Edits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

5.3.5

Positioning Decorative Details . . . . . . . . . . . . . . . . . . . 147

5.4

Splitting the active plan . . . . . . . . . . . . . . . . . . . . . . . . . . 149

5.5

Computing Procedural Extrusions . . . . . . . . . . . . . . . . . . . . . 150
5.5.1

Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

5.5.2

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

5.5.3

Description of Events . . . . . . . . . . . . . . . . . . . . . . . . 153

5.5.4

Generalized Intersection Event . . . . . . . . . . . . . . . . . . . 154

5.5.5

Edge Direction Events . . . . . . . . . . . . . . . . . . . . . . . 158

5.5.6

Proﬁle Oﬀset Events . . . . . . . . . . . . . . . . . . . . . . . . 159

5.5.7

Anchor events . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

5.5.8

Plan Edit Events . . . . . . . . . . . . . . . . . . . . . . . . . . 165

5.5.9

Mesh Anchors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167

5.5.10 Subdivison Events . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.6

Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
5.6.1

GIS Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . 175

5.6.2

Interactive Evaluation . . . . . . . . . . . . . . . . . . . . . . . 178

5.6.3

Artistic Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . 182

5.6.4

Notable external applications . . . . . . . . . . . . . . . . . . . 185

5.7

Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187

5.8

Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189

6 Conclusion

191

A Appendix - input for interactive UI evaluation

192

B Appendix - artists’ comments on the procedural extrusions system 194
B.0.1 User 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
B.0.2 User 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
Bibliography

198

List of Figures
1.1

Hour glasses at the London Science Museum. . . . . . . . . . . . . . . .

1

2.1

A java program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5

2.2

A formal string grammar . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.3

A formal grammar derivation . . . . . . . . . . . . . . . . . . . . . . .

6

2.4

The Chomsky Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . .

7

2.5

A simple graph grammar . . . . . . . . . . . . . . . . . . . . . . . . . .

9

2.6

An algebraic production rule . . . . . . . . . . . . . . . . . . . . . . . .

9

2.7

An algebraic production rule . . . . . . . . . . . . . . . . . . . . . . . .

10

2.8

A simple L-system . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

2.9

Evaluation terms in a context sensitive L-system . . . . . . . . . . . . .

12

2.10 Turtles in L-systems . . . . . . . . . . . . . . . . . . . . . . . . . . . .

13

2.11 A L-system description . . . . . . . . . . . . . . . . . . . . . . . . . . .

13

2.12 Evaluation of a L-system’s string grammar . . . . . . . . . . . . . . . .

14

2.13 The output of an L-system . . . . . . . . . . . . . . . . . . . . . . . . .

14

2.14 An example of a complex L-system . . . . . . . . . . . . . . . . . . . .

15

2.15 A simple fa¸ade shape grammar . . . . . . . . . . . . . . . . . . . . . .
c

18

2.16 Evaluations of a shape grammar . . . . . . . . . . . . . . . . . . . . . .

19

2.17 The use of shape grammars to position trees on an circle . . . . . . . .

19

2.18 A parametric shape grammar production rule . . . . . . . . . . . . . .

20

2.19 Dead ends in the Palladian grammar . . . . . . . . . . . . . . . . . . .

22

2.20 CGA Shape’s scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

25

2.21 The evaluation of a split shape grammar . . . . . . . . . . . . . . . . .

26

2.22 An instance locator . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

26

2.23 The over-compartmentalisation problem in shape grammars . . . . . .

27

2.24 A data ﬂow graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

28

2.25 A token based data ﬂow graph . . . . . . . . . . . . . . . . . . . . . . .

29

2.26 The Labview graphical data ﬂow language . . . . . . . . . . . . . . . .

30

2.27 The Scratch visual programming language . . . . . . . . . . . . . . . .

31

2.28 The OpenDX visual programming language . . . . . . . . . . . . . . .

32

2.29 Editing the parametrisations of the model in Fig. 2.30 . . . . . . . . . .

33

2.30 A Grasshopper data ﬂow graph . . . . . . . . . . . . . . . . . . . . . .

34

2.31 Data matching in Grasshopper . . . . . . . . . . . . . . . . . . . . . . .

35

2.32 Conway’s game of Life . . . . . . . . . . . . . . . . . . . . . . . . . . .

36

2.33 A Wolfram class VI automata . . . . . . . . . . . . . . . . . . . . . . .

36

2.34 An urban modeling pipeline . . . . . . . . . . . . . . . . . . . . . . . .

38

2.35 Simulating the growth of a city . . . . . . . . . . . . . . . . . . . . . .

39

2.36 Texture Synthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

42

2.37 Issues with combinatory Modeling . . . . . . . . . . . . . . . . . . . . .

44

2.38 Image warping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

45

2.39 Mesh modeling techniques . . . . . . . . . . . . . . . . . . . . . . . . .

50

2.40 A model from a library . . . . . . . . . . . . . . . . . . . . . . . . . . .

51

3.1

Diﬀerent ways to shrink a polygon. . . . . . . . . . . . . . . . . . . . .

55

3.2

Purple cubic crystals of ﬂuorite . . . . . . . . . . . . . . . . . . . . . .

56

3.3

2D crystal growth. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

56

3.4

Shrinking a polygon to form the straight skeleton . . . . . . . . . . . .

57

3.5

The straight skeleton of various polygons . . . . . . . . . . . . . . . . .

58

3.6

Straight skeleton terminology . . . . . . . . . . . . . . . . . . . . . . .

58

3.7

A moving plan edge . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

60

3.8

A badly formed plan . . . . . . . . . . . . . . . . . . . . . . . . . . . .

60

3.9

Constructing the straight skeleton . . . . . . . . . . . . . . . . . . . . .

61

3.10 Split and edge events . . . . . . . . . . . . . . . . . . . . . . . . . . . .

61

3.11 Not all direction plane intersection are active plane events . . . . . . .

62

3.12 The implicit active plan . . . . . . . . . . . . . . . . . . . . . . . . . .

63

3.13 Reconstructing skeleton faces . . . . . . . . . . . . . . . . . . . . . . .

63

3.14 Pseudo-code for the SS algorithm . . . . . . . . . . . . . . . . . . . . .

64

3.15 A complex straight skeleton . . . . . . . . . . . . . . . . . . . . . . . .

65

3.16 Aicholzer’s triangulation algorithm . . . . . . . . . . . . . . . . . . . .

66

3.17 Eppstein’s Motorcycle Graphs . . . . . . . . . . . . . . . . . . . . . . .

67

3.18 Various degenerate situations . . . . . . . . . . . . . . . . . . . . . . .

68

3.19 An example of the loop of two situation . . . . . . . . . . . . . . . . . .

69

3.20 An issue with parallel consecutive edges

. . . . . . . . . . . . . . . . .

70

3.21 Perturbing event sequences may lead to wildly diﬀerent results . . . . .

70

3.22 Adjacent edges in an event form chains . . . . . . . . . . . . . . . . . .

71

3.23 Chains approaching an event . . . . . . . . . . . . . . . . . . . . . . . .

71

3.24 Intra chain pointer manipulation . . . . . . . . . . . . . . . . . . . . .

72

3.25 Inter chain pointer manipulation . . . . . . . . . . . . . . . . . . . . . .

73

3.26 Algorithm for the generalised intersection event.

. . . . . . . . . . . .

74

3.27 Results of the GIE . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

75

3.28 Positively weighted straight skeleton terminology . . . . . . . . . . . .

77

3.29 A PWSS may contain holes . . . . . . . . . . . . . . . . . . . . . . . .

77

3.30 PWSS faces may not be monotone . . . . . . . . . . . . . . . . . . . .

78

3.31 A plan that leads to a PCE, a. The algorithm must choose between the
red (middle ﬁgure) or yellow (right ﬁgure) faces to dominate. . . . . . .

79

3.32 Global coordination requirement in PCEs . . . . . . . . . . . . . . . . .

80

3.33 A PWSS PCE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

81

3.34 A PWSS PCE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

82

3.35 Degenerate events in the PWSS and MWSS . . . . . . . . . . . . . . .

83

3.36 Unbounded MWSS . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

83

3.37 The GIE doesn’t work on the PWSS . . . . . . . . . . . . . . . . . . .

84

3.38 A point degeneracy . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

85

3.39 Enclosing chains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

85

3.40 Several solutions to the MWSS . . . . . . . . . . . . . . . . . . . . . .

86

3.41 Manual examples of good MWSS solutions . . . . . . . . . . . . . . . .

87

3.42 Ordering chains around the event . . . . . . . . . . . . . . . . . . . . .

88

3.43 Global coordination of a solution with parallel edges . . . . . . . . . . .

89

3.44 Removing zero area chains . . . . . . . . . . . . . . . . . . . . . . . . .

90

3.45 A MWSS event that cannot be fairly solved . . . . . . . . . . . . . . .

90

3.46 The sector property . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

91

3.47 Edges become rays in the pincushion problem . . . . . . . . . . . . . .

92

3.48 The Pincushion diagram . . . . . . . . . . . . . . . . . . . . . . . . . .

93

3.49 PWSS events may not have unique solutions . . . . . . . . . . . . . . .

94

3.50 A brute force approach to the pincusion problem . . . . . . . . . . . . .

95

3.51 Brute force application . . . . . . . . . . . . . . . . . . . . . . . . . . .

96

3.52 The 5 Star Pincushion . . . . . . . . . . . . . . . . . . . . . . . . . . .

97

4.1

Two parcel types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

4.2

Previous parcel generation approaches . . . . . . . . . . . . . . . . . . 103

4.3

A perimeter block’s depth . . . . . . . . . . . . . . . . . . . . . . . . . 108

4.4

Strips sharing a block’s corner . . . . . . . . . . . . . . . . . . . . . . . 109

4.5

A problem with tolerances . . . . . . . . . . . . . . . . . . . . . . . . . 111

4.6

A problem with naive strip splitting . . . . . . . . . . . . . . . . . . . . 112

4.7

Assignment in a perimeter subdivision . . . . . . . . . . . . . . . . . . 112

4.8

Skeleton parcel subdivision pseduocode. . . . . . . . . . . . . . . . . . . 113

4.9

A problem with naive strip splitting . . . . . . . . . . . . . . . . . . . . 115

4.10 OBB subdivision pseudocode. . . . . . . . . . . . . . . . . . . . . . . . 115
4.11 The parcel matching problem . . . . . . . . . . . . . . . . . . . . . . . 116
4.12 A problem with naive strip splitting . . . . . . . . . . . . . . . . . . . . 117
4.13 Data sources used for evaluation . . . . . . . . . . . . . . . . . . . . . . 118
4.14 Pasadena data set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
4.15 Pasadena results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
4.16 Naper data set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.17 Naper results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
4.18 Wynneﬁeld data set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
4.19 Wynneﬁeld results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

4.20 Germantown data set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
4.21 Germantown results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
4.22 Details of subdivision deﬁciencies . . . . . . . . . . . . . . . . . . . . . 128
4.23 Non-local parcel features. . . . . . . . . . . . . . . . . . . . . . . . . . . 129
4.24 Details from the skeleton subdivision . . . . . . . . . . . . . . . . . . . 130
4.25 CityEngine results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.1

A house created using procedural extrusions. . . . . . . . . . . . . . . . 134

5.2

Plans and proﬁles of two architectural models . . . . . . . . . . . . . . 135

5.3

Horizontal edges are common in architectural form . . . . . . . . . . . 137

5.4

Mesh editing may not preserve face planarity. . . . . . . . . . . . . . . 138

5.5

Failure cases with extrude tool . . . . . . . . . . . . . . . . . . . . . . . 139

5.6

CSG failure cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

5.7

Example PE plans and proﬁles. . . . . . . . . . . . . . . . . . . . . . . 141

5.8

The PE GUI. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142

5.9

A non-monotone proﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

5.10 An example of anchors . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
5.11 Adding a chimney using plan edits. . . . . . . . . . . . . . . . . . . . . 146
5.12 Sharing anchors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
5.13 The subdivision event UI . . . . . . . . . . . . . . . . . . . . . . . . . . 150
5.14 PE pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
5.15 PE algorithm pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
5.16 Architectural footprints often lead to degenerate events . . . . . . . . . 155
5.17 Epsilon error parameters . . . . . . . . . . . . . . . . . . . . . . . . . . 156
5.18 PE ambiguities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
5.19 Near horizontal edge direction events . . . . . . . . . . . . . . . . . . . 159
5.20 Proﬁle Oﬀset events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
5.21 Calculating oﬀset events . . . . . . . . . . . . . . . . . . . . . . . . . . 161
5.22 Anchors deﬁning positions . . . . . . . . . . . . . . . . . . . . . . . . . 164
5.23 Anchors and plan edits . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
5.24 Plan edits update the corner data structure . . . . . . . . . . . . . . . 166

5.25 The advantages of natural steps . . . . . . . . . . . . . . . . . . . . . . 166
5.26 Using the natural step for genus change . . . . . . . . . . . . . . . . . . 167
5.27 An interior step with a genus change . . . . . . . . . . . . . . . . . . . 167
5.28 Adding decorative meshes using anchors . . . . . . . . . . . . . . . . . 168
5.29 Subdivision events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
5.30 The subdivision event for creating relative and absolute partitions . . . 170
5.31 An example of subdivision events for roofs . . . . . . . . . . . . . . . . 171
5.32 A range of structures possible with the PE systems . . . . . . . . . . . 172
5.33 An PE American condo . . . . . . . . . . . . . . . . . . . . . . . . . . 173
5.34 PEs for architectural elements . . . . . . . . . . . . . . . . . . . . . . . 174
5.35 PE for artistic rendering . . . . . . . . . . . . . . . . . . . . . . . . . . 174
5.36 GIS evaluation input data . . . . . . . . . . . . . . . . . . . . . . . . . 176
5.37 The GIS UI for large scale proﬁle assignment . . . . . . . . . . . . . . . 176
5.38 Automatic proﬁle assignment . . . . . . . . . . . . . . . . . . . . . . . 177
5.39 Large scale GIS results . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
5.40 Failure modes in the automated case . . . . . . . . . . . . . . . . . . . 178
5.41 Results of interactive evaluation . . . . . . . . . . . . . . . . . . . . . . 179
5.42 Further source material for interactive evaluation . . . . . . . . . . . . 180
5.43 Usability issues with PEs . . . . . . . . . . . . . . . . . . . . . . . . . . 181
5.44 Artist’s use of PEs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
5.45 Further artistic use of PEs . . . . . . . . . . . . . . . . . . . . . . . . . 184
5.46 Clockwork Empires video game. . . . . . . . . . . . . . . . . . . . . . . 186
5.47 Integration with Houdini.

. . . . . . . . . . . . . . . . . . . . . . . . . 187

5.48 Comparison of PEs with previous systems . . . . . . . . . . . . . . . . 188
5.49 The PE as an automated data-loss system . . . . . . . . . . . . . . . . 189
A.1 The source material for interactive evaluation . . . . . . . . . . . . . . 193

1

Chapter 1
Introduction
1.1

Motivation

Figure 1.1: Hour glasses at the London Science Museum.

We may ask ourselves how we would create a single model that could create all of
the hour glasses in Figure 1.1. This is the goal in procedural geometric modeling –
we have no deﬁnitive way to do this today, but in this document we hope to take
some steps towards a solution.
Whilst a standard 3D work ﬂow might allow a user to create a single hour glass
of a speciﬁc dimension amd design, a procedural modeling system might let a user
create an algorithm that produces a glass of any given dimension.

Procedural geometric modeling (PGM ) is a ﬁeld studying algorithms that compute
geometry. A procedural model consists of a sequence of parameterized operations that
are able to construct a variety of geometric forms.
For example urban procedural modeling aims to create algorithms for the construction
of cityscapes. As we shall see in Chapter 2 these tools are of use to several disciplines.

1.1. Motivation

2

Architects and urban planners use them to provide layouts for large scale plans, and
to provide background geometry for visualisation of planned developments. Historians
appreciate the ability to reconstruct environments from partial information, such as a
building’s foundations, and video game designers use PGM to create large cityscapes
for players to explore.
The additional level of abstraction oﬀered by PGM has signiﬁcant beneﬁts over singleinstance modeling, but introduces a number of challenges. The beneﬁts of PGM include:
• An arbitrary quantity of geometry can be created to describe a virtual environment in constant time; the time it takes to construct the procedural model.
• The removal of the existing restriction that the size of a virtual environment is
proportional to the time spent creating it.
• The quality of the environment is consistent at no additional cost.
• Procedural geometry tools could lead to runtime environment generation. A
virtual world would be generated as the user explores it, giving an experience
with more variety and less repetition to the user [94].
• Procedural methods oﬀers the potential to generate content that reacts to various
stimuli. For example it could respond to current hardware availability, to users
level of expertise, the length of their attention span, or the medium on which it
is presented.
The drawbacks of PGM include:
• Designers must undertake the more complex task of designing a class of geometry,
rather than a single instance.
• Traditional artists are not familiar with classical methods of describing algorithms, such as programming languages.
• Traditional software engineers do not possess a classically trained sense of aesthetic.
• There are a large number of use cases of PGM, with each likely to require diﬀerent
solutions. We explore some of these in Chapter 2.
In this thesis we are concerned with removing several of these drawbacks, speciﬁcally
the requirement that current PGM systems require considerable programming expertise.

1.2. Thesis Statement

1.2

3

Thesis Statement

Procedural modeling without written programming languages is possible using the
straight skeleton and is able to generate high ﬁdelity results that have many applications
within urban procedural modeling.

The papers written in the course of this thesis were Interactive Architectural Modeling with Procedural Extrusions [116] and Procedural Generation of Parcels in
Urban Modeling [247]. These papers were written with a variety of co-authors.
The work is also related to my 3 month Master’s Dissertation, City Architecture
Generation [117].

4

Chapter 2
Readings: A Spectrum of
Proceduralisation
This chapter introduces some of the technical background of procedural modeling
within the ﬁeld of graphics. Procedural modeling is a broad subject that borrows
from many established ﬁelds; we give an overview of the subject’s context within a
broad spectrum of proceduralisation.
This spectrum leads from general purpose languages to a speciﬁc instance of a model.
At one extreme we visit general models that are able to create a wide variety of geometry, for example a programming language (not to be confused with a single program
in a language) is capable of creating any geometry we can describe. As we progress
we visit models that only work within a speciﬁed domain or produce models similar to
an example. At the most speciﬁc end of our spectrum we visit “models” that are only
single instances, such as a 3D mesh of the Glasgow School of Computer Science.
A general language can describe any computable geometry, while an instance is a
single, unchanging object. However an instance is ready to use, while a language takes
considerable specialisation to create any results. Furthermore, an instance requires no
intelligence on the part of the user and guarantees good results, while a fully general
language requires lots of intelligence and provides no assurances as to the ﬁnal quality
of the geometry.
In line with the content of the thesis this section will provide an emphasis on those
techniques relevant to urban procedural modeling, although context is provided by
sketches of the surrounding topics. We begin by examining the most general geometry
production systems — languages, grammars and their variants, before moving onto
the more speciﬁc combinatory modeling approaches, simulation and inverse procedural
modeling techniques. The most speciﬁc techniques form the end of our spectrum —

2.1. General Purpose Programming Languages

5

public void p a i n t ( Graphics2D g )
{
int count = 1 ;
do
{
g . r o t a t e ( Math . PI /2 ) ;
g . s c a l e ( 1+ ( count / 1 0 0 . ) , 1 + ( count / 1 0 0 . ) ) ;
f o r ( double d : new double [ ] { 0 , Math . PI } )
{
g . rotate ( d );
g . t r a n s l a t e ( −50, 0 ) ;
g . draw ( new Arc2D . Double ( −5, −5, 1 0 , 1 0 , 9 0 , 1 8 0 , Arc2D .OPEN ) ) ;
g . t r a n s l a t e ( 50 , 0 ) ;
}
} while ( count++ < 2 0 ) ;
}

Figure 2.1: A small example of a 2D geometric program in Java.
shape deformation and 3d tools. We conclude by examining the eﬀect of this spectrum
of proceduralisation upon scientiﬁc evaluation of procedurally generated geometry.
There are two common uses of the word model in PGM — to represent some system
that may create some geometry (“a grammatical model of architecture”), and to
refer to the geoemtry itself (“The 3D elephant model”). In this chapter we will
attempt to only use the former description, reserving model and a synonym for
system to avoid confusion.

2.1

General Purpose Programming Languages

We ﬁrst encounter an extreme – the general purpose programming language. Predominantly these languages are text-string based and Turing complete[240], such as
FORTRAN[110], Haskell[106] or Java[83], Fig. 2.1. Appropriate libraries and interfaces allow these languages to create descriptions of geometric objects.
Being general, these languages can describe any computable geometry. However doing
so is quite complex, especially for users unable to write programs. In particular a
random string is most likely not a valid program, while a particular random program
will be unlikely to create geometric output.
There are a wide variety of libraries available to generate geometry via a general purpose
programming language. Many of the original library functions were intended to interface with graphics hardware such as OpenGL[264], others were languages for realistic
renders, such as RenderMan[242]. More recently higher level interfaces have emerged
such as Open Inventor[257] and the Generative Modeling Language[101]. Havemann

2.2. Formal String Grammars
N
Σ
S
P

6
=
=
=
=

A, B
a, b
A
A
A
B

→ Bb
→ a
→ Ab

Figure 2.2: A Chomsky type 3 grammar that produces a regular language. A rule
x → y indicates that the symbol x may be replaced by the symbol y.
string
A
Bb
Abb
Bbbb
Abbbb
abbbb

via rule
S
A
→
B
→
A
→
B
→
A
→

Bb
Ab
Bb
Ab
a

Figure 2.3: The derivation of a string in the language deﬁned in Fig.2.2. The language deﬁned is the symbol a, followed by an even number of the symbol b; there are
an inﬁnite number of strings in this language.
introduced GML to construct procedural graphical primitives via Euler operations to
generate meshes, which may be interpretted as multi-resolution subdivision surfaces.
GML has been applied to several procedural domains such as Gothic windows[102],
castles[78] and underground infrastructure[150].

2.2

Formal String Grammars

Procedural modeling has been strongly inﬂuenced by the study of grammars. There
are a wide range of grammars, each with diﬀerent properties[44, 200], however a geometrically useful subset is given by the Chomsky hierarchy[42]. A formal grammar
is a concise deﬁnition of a language. A language is the (often inﬁnite) set of all the
allowable strings of symbols from a ﬁxed alphabet. Eventually we will introduce geometric interpretations of these strings for PGM, but formal grammars are concerned
with the generation of these strings alone. The range of languages expressible by formal
grammars are a subset of those recognisable by the general languages, a specialisation
within our procedural spectrum.
A formal grammar consists of a set of non-terminal symbols, N , a set of terminal
symbols, Σ, a set production rules, P , and a start symbol, S ∈ N . An example is given
in Fig. 2.2.

2.2. Formal String Grammars
Chomsky designation
type 3
type 2
type 1
type 0

rule format
n1 → σ 1
n2 → n3 σ2
n4 → φ•
1
φ• n5 φ• → φ• φ• φ•
2
3
2 4 3
φ• → φ•
5
6

7
language name
(left) regular
context free
context sensitive
recursively enumerable

Figure 2.4: The Chomsky hierarchy of grammars. σx ∈ Σ, nx ∈ N and φx ∈ Σ ∪ N .
Repeated elements from a group are marked• .
The initial string consists of a single character, S, which is repeatedly altered by the
production rules. During this manipulation the current string consists of a mix of
terminal and non-terminal symbols. When only terminal symbols remain in the string
the production terminates. The ﬁnal string is an member of the language deﬁned by
the grammar. We evaluate the earlier example in Fig. 2.3.
Diﬀerent classes of languages can be deﬁned by diﬀerent forms of production rules.
The example in Fig. 2.2 is a type-3 grammar in the Chomsky hierarchy. A type-3
language may replace a single non-terminal symbol, with either a terminal symbol, or
a non-terminal symbol followed by a terminal.
Type-3 grammars deﬁne the set of regular languages. A more expressive grammar may
be allowed to replace the symbol with a longer string (a type-2 language), examine the
context of the single symbol to be replaced (type 1), or replace any string with any
other (type 0). Chomsky named this increasingly powerful hierarchy of grammars as
types 2, 1 and 0, as shown in Fig 2.4. Each expresses a super-set of the languages of
the previous type by relaxing the restrictions on the context of the replaced symbols.
There are a wide variety of other string rewriting systems[119]. For example, if we remove the distinction between terminal and non-terminal symbols, and the requirement
for a single starting symbol, then we instead have a semi-Thue process[49]. Another
variation is a parallel grammar, which applies a rule to every symbol in the string with
each iteration. If we use a parallel context sensitive grammar over a symbol set consisting of the binary digits, then we have cellular automata[262], a popular example
of which is Conway’s game of life[77]. 3D cellular automata have been used to create
procedural models of creeping plants[87]. Alternately every production rule in a grammar may manipulate attributes associated with a speciﬁc instance of a symbol, leading
to attributed grammars[121]. Finally we may operate on graphs, instead of strings,
leading to the concept of graph-grammars.

2.3. Graph Grammars

2.3

8

Graph Grammars

Graph Grammars specialise the concept of string grammars to include a topological
element. Instead of replacing a symbol or string, we replace a node or sub-graph of
a graph. Therefore a graph grammar deﬁnes a set of graphs in a speciﬁc language of
graphs.
Pfaltz and Rosenfeld introduced graph grammars as web grammars in their 1969
paper[182], although their terminology is no longer in popular use. In a similar manner
to formal string grammars, the paper describes production rules as triples consisting
of a left target graph, a replacement right graph, and an embedding function.
This embedding function describes how the edges to and from a sub-graph of the
host matching the left graph will relate to edges in its replacement, the right graph.
However, the paper by Pfaltz et al. does not deﬁne the structure of this embedding
statement, rather descriptions are given in prose. There are a large number of such
embeddings function and much of the remainder of the theoretical work on graph
grammars concerns itself with the diﬀerent forms this embedding function may take.
For our purposes a graph, γ, consists of a set of nodes and edges between these nodes.
The set of nodes, P , is labelled by a ﬁnite alphabet, V . As with string grammars, these
labels are either in the set of terminals, Σ, or non-terminals, N . The set of directed
edges, E, consists of pairs in (p1 , p2 ) where p1 , p2 ∈ P , and are optionally labelled from
V.
A graph grammar is a 4-tuple, G = (V, N, γ0 , R), where γ0 is the initial graph and R
is a set of production rules. A production rule r = (γl , γr , E), consists of the left and
the right graphs, and an embedding function, E.
As with formal string grammars, the host graph is initially γ0 , and production rules
are applied until no more nodes or edges with non-terminal symbols exist. A simple
graph grammar is given in Fig. 2.5, deﬁning a simple lattice-like language of graphs.
However, without well deﬁned embedding functions several questions are unanswered.
For example, as each rule is applied, are any edges from the host graph to the right
hand side of the graph created? or how are edges to the removed left graph treated?
The two main competing approaches to embedding functions are set-theoretic and algebraic. The algebraic approach utilises category theory to deﬁne gluing functions[62],
while the set-theoretic approach utilises set-expressions to deﬁne the embedding function, typiﬁed by [165]. We refer the reader to the citations for the full details, but
demonstrate a single production rule from each in Fig. 2.6 and Fig. 2.7.
As with string grammars, there are a large number of variations on the theme of
graph grammars. L-systems (Sec. 2.4) inspired parallel graph grammars[61]. These

2.3. Graph Grammars

9

V = {A, B, C, a, b, c}, N = {A, B, C}
initial host graph, γ0 = C
production rules, R =
c

a

c

A

B
a

A

c

b

C

a

c

b
B

b

B

a

b

c

b

B
a

A

a

A

a

c
c

b

b

a

a

b

b

a

b

a

b

c

Figure 2.5: Left: an overly simple graph grammar, overlooking embedding rules.
Right: several graphs in the language deﬁned by this grammar. Note edge labels are not
shown here.

A

1

1

a

1

d

R=
B

2

C

3

2

a

b

3

a

c

2

3

a

A

a

d
= result

γ0 =
B
b

C

b
c

b

d

b

c
d

Figure 2.6: The application of an set-theoretic production rule, R, using the double
pushout method[62]. Note that numeric values establish node identity in these diagrams.
Top row: the two stages in the production rule. Top left: the left graph to match. Top
middle: any nodes to be renamed have their labels removed and edges to be deleted are
removed. Top right: the new labels and edges are applied. Bottom: the application of
R to a graph (bottom right).

2.3. Graph Grammars

10

C
1

2

R= A

3

a i

4

b

b

j

5
γ0 = B

a

i

lj = (B Li (1); 3, 4)

A

ri = (5; Rj Li ∪ Li (1))
node replacement

C
j

C
B

j
B
i

2
a i

1
A
lj = (B Li (1); 3, 4)

3
b

5
a

C

C

j

C

j

B

j

4
b

B
j

j

B
i

2

1
a

A

3
i

ri = (5; Rj Li ∪ Li (1))
j
C
B
j

b

4
b

5
a

2
a i

C

A

a

3
i

b

4
b

5
a

2
a i

i

i

B

2
a

b

5

C

j
1

b

4

j

B
i

3

j
3
b

4
b

5
a

Figure 2.7: The application of an algebraic production rule using the system speciﬁed
by Nagl[165]. First row: the rule, R which consists of the left graph, the right graph,
and the embedding components lj , ri . Numeric node identities are given outside each
node in the rule. The graph we will apply the rule to is γ0 , replacing the node labelled
A with the right graph (second row). Third row: the application of the embedding lj
creates new edges by walking over the graph (dashed arrows). The origin of the walk is
the node with identity 1, traversing all outbound edges labelled i and ﬁltering for nodes
labelled B. The destinations are the nodes with identity 3 and 4, the new edges are
shown in bold. The embedding ri proceeds similarly, except the ∪ operator performs
two walks to use as the destinations. The resulting graph is given in the bottom right.

2.4. L-Systems

11

divide the graph into covering subgraphs, each of which matches the right hand side
of one production rule; each rule is then applied at the same time, in parallel with
one another. Negative application conditions[166, 91] specify situations in which a
particular rule should not be applied. Programmed graph grammars, as introduced by
G¨ttler[85], take this concept further and replace the set of production rules with a list
o
of production rules to be applied sequentially, via conditional statements or loops.
Unfortunately identifying matching subgraphs in graphs (to identify the portion of
graphs to be replaced) is an instance of the computationally NP-complete subgraph
isomorphism problem. While there are situations where this complexity is alleviated,
such as in the case of planar graphs[64], this complexity may be a reason that graph
grammars are not widely used in PGM. Another problem is that graph grammars are
no more expressive than string grammars as there is an encoding of any graph in string
form (typically an adjacency matrix). This string representation may be manipulated
in equally expressive ways via a type 0 string grammar.
In spite of these shortcomings there are several graphical applications of graph grammars, such as the design of technical diagrams[84], production of system ﬂow diagrams[56],
the design of a visual languages[88] and CAD-systems[89]. In particular graph grammars oﬀer a topological-oriented description of the otherwise geometry oriented shapegrammars[273], introduced in Sec. 2.5.

2.4

L-Systems

Lindenmayer-systems[137] introduced a parallel string replacement grammar in 1968,
speciﬁcally motivated by the study of plant growth. Unlike the sequential model described by Chomsky, every biological cell in a plant may divide simultaneously. To
simulate this, a production rule is applied to every symbol in the string concurrently.
Meanwhile in the 1980’s the computer graphics ﬁeld was producing tree models, these
were lacking a formal grammar, such as the tendril-like forms[114], or detailed models of speciﬁc varieties of trees[28]. In 1986 L-systems were combined with graphical
techniques[189] to produce a graphical interpretation of a grammar’s language. This
combination of a string grammar and a turtle became synonymous with the term Lsystem. In binding their domain to graphics, and usually botany, L-systems are a more
specialised system than formal grammars, the ﬁrst true procedural geometric modeling
system we examine.
A basic L-system speciﬁes a parallel string replacement grammar, a number of iterations, a starting string, and a turtle interpreter to create graphical output. Unlike

2.4. L-Systems

12
n
δ
initial string
production rule

=
=
=
=

F

8
90◦
F
→ F+FF+

Figure 2.8: The description of a simple L-system.
F
1: F+FF+
2: F+FF++F+FF+F+FF++
3: F+FF++F+FF+F+FF+++F+FF++F+FF+F+FF++F+FF++F+
FF+F+FF+++
Figure 2.9: The ﬁrst three terms in the evaluation of the string grammar of Fig. 2.8.
grammars their output is a single result, rather than a language. We deﬁne an example
L-system in Fig. 2.8,
The string replacement grammar doesn’t contain any terminal symbols, and is parallel
in that at every derivation step every symbol in the string is replaced by a matching rule.
The grammar also diﬀers from a formal string grammar in that there is no distinction
between terminal and non-terminal symbols. Instead, a ﬁxed count of parallel rule
applications occur, Fig. 2.9, after which the string is interpreted by a turtle.
A turtle uses this string to create geometry by evaluating one symbol of the string
at a time, using a left-to-right ordering. The turtle’s 2D location and rotation is
manipulated by each symbol in turn, creating geometry as a side eﬀect, Fig. 2.10.
Typical mappings for symbols are F to move the turtle a unit length in the forwards
direction creating a line segment as it moves, + or − to rotate the turtle an angle, δ,
clockwise or counter-clockwise respectively, [ to store the turtle’s current location and
orientation on a stack, and ] to restore it’s location and orientation by popping the top
location from the stack.
To summarise, a simple L-system is deﬁned by an initial string, S, a number of rule
applications, n, a set of production rules, P and a rotation angle, δ.
An extension to these basic L-systems is context sensitivity for the string grammar,
reminiscent of a move from a type 2 formal grammar in the Chomsky hierarchy to type
1. For example to state that a b between an a and a c should be replaced with a d we
would use the notation:
a

b

c → d

For example, given the context sensitive L-system in Fig. 2.11, we may evaluate the
string grammar as in Fig. 2.12, and ﬁnally produce our geometric output, Fig. 2.13.
The result from these systems is generally pleasing given the compact description, and

2.4. L-Systems

F

n=1

13

F+

n=2

F+F

n=3

F+FF

F+FF+

n=4
n=8

Figure 2.10: Top, left-right: incrementally constructing a graphical interpretation of
a string using a turtle. Bottom: the turtle’s evaluation of terms 1,2,3,4 and 8 of the
L-system in Fig. 2.8

n
δ
#ignore
initial string

production rules

=
=
=
=

=

0
0
0
0
1
1
1
1

0
0
1
1
0
0
1
1
+
-

39
22.5◦
+-F
F1F1F1
0 →
1
1 → 1[-F1F1]
0 →
1
1 →
1
0 →
0
1 →
1F1
0 →
1
1 →
0
→
→
+

Figure 2.11: A self-sensitive string grammar (example 1.31,b from TABOP[190]).

2.4. L-Systems

14

F1F1F1
1: F1F0F1
2: F1F1F1F1
3: F1F0F0F1
4: F1F0F1[-F1F1]F1
5: F1F1F1F1[+F0F1]F1
6: F1F0F0F0[-F1F1F1]F1
7: F1F0F1F1[-F1F1][+F1F0F1]F1
8: F1F1F1F1F0[+F0F1][-F1F1F1F1]F1
9: F1F0F0F1F1F1[-F1[-F1F1]F1][+F0F0F0F1]F1
10: F1F0F1[-F1F1]F1F0F0[+F0[+F0F1]F1][-F0F1F1[-F1F1]F1]F1
Figure 2.12: Some statements given in the language. The evaluation of the grammar
given in Fig. 2.11 for the ﬁrst 10 iterations.

Figure 2.13: The evaluation of a simple L-System given in Fig. 2.11 over n =
0, 3...36, 39 iterations shown clockwise from vertical. Each result is drawn a factor of
0.7 times smaller than its predecessor.

2.4. L-Systems

15

initial string: A(0, 0)
production rules:
1 : A(x, i) → S(x)B(x, i)A(x + ∆, i + 1)
2 : S(x) → @R(0, 1, 0, 0, 0, 1) + (Y (x))&(P (c))F (δ(x))
3 : B(x, i) : {
if (i%2 == 0) θ = 0;
else θ = 90;
} → [/(θ)L(x, i)R(x, i)]
4 : L(x, i) : {
if(i%2 == 0){
angle = ϕL (x);
length = hL (x);
}else{
angle = (ϕL (x) + ϕR (x)) ∗ 0.5;
length = (hL (x) + hR (x)) ∗ 0.5;
} → [+ (angle) Organ (length)]
5 : R(x, i) : {
if(i%2 == 0){
angle = ϕR (x);
length = hR (x);
}else{
angle = (ϕL (x) + ϕR (x)) ∗ 0.5;
length = (hL (x) + hR (x)) ∗ 0.5;
} → [/(180) + (angle) Organ (length)]
Figure 2.14: A parameterised programmable L-system from[14] to model the biological
phenomena of decussate phyllotaxis. The necessity of referring to the previous iteration
adds considerable complexity.
simulates a discrete form of growth as successive evaluations occur. The book The
Algorithmic Beauty of Plants[190], from which this example was taken, gives a very
detailed introduction to the modeling of ﬂora using L-Systems.
A basic L-system has several limitations, including a lack of environmental sensitivity,
non-realistic rendering and a complex grammar editing process. To overcome these,
L-systems have been periodically extended. The remainder of this section explores
some of these extensions and their applications:
• Context sensitive. As described above, symbol replacement can occur based on
the surrounding elements.
• Stochastic. Each production rule is given a corresponding probability with which
it occurs on each iteration[270]. For example the branching characteristics of a
tree may be encoded in a stochastic L-system[192], or the choice of which building
to place on a given parcel of land[176] may be made stochastically. While a basic

2.4. L-Systems

16

L-system is deterministic in that it always creates the same output, a stochastic
L-system may produce diﬀerent output every time it is evaluated.
• 3D. By using a three dimensional turtle, instead of the two dimensional standard,
three dimensional geometry can be created. For example [191] uses a two-axis
rotation system to manoeuvre the turtle in 3D, while using L-system rules to
determine the developmental cycles.
• Parametric. Here each symbol is given a set of parameters, and a replacement can
only take place if a logical statement associated with the parameters is true [97].
Parametric L-systems are comparable to the parallel case of attributed formal
grammars[121]. These parameters can model the ﬂow of morphogens such as
genes or hormones[35].
• Table. These use a variable table of production rules to simulate step-changes
in the applicable rules. For example one table may model the plant in a winter
(non-ﬂowering) state, and another the summer (ﬂowering) state.
• Map. This early approach to produce a graphical interpreter for L-systems uses
a parallel grammar to manipulate a geometric graph as “cells”[136]. Because this
system works directly on geometry it is unnecessary to interpret the results using
a turtle. Map L-systems are a geometric analog of graph grammars, see Sec. 2.3.
• Environmentally sensitive. There has been a large quantity of work to allow
L-systems to interact with their virtual environments. Table-L-systems provide
a discrete phase-transition in response to external stimuli, while context sensitive L-systems give only topological self-sensitivity. L-systems that are physically
constrained by their environment are introduced by [192], although the eﬀect of
the plant on the environment are not modelled. To address this issue, bidirectional information exchange is introduced by [163], using physical simulations to
describe the availability of water and light to developing foliage and root systems. Geometrically self-sensitive L-systems are used by[176] to generate road
networks; these modify a production rule with both global goals and local geometric constraints.
As they have been extended to overcome their limitations, L-systems have become
increasing complex. One case study is that of phyllotaxis, the pattern that plant
organs (leaves or ﬂowers) form around the stem; in particular decussate phyllotaxis
alternates between pairs of leaves at 90◦ . It is instructive to compare an L-system
for a phenomena such as decussate phyllotaxis from Fig. 2.14, to the same description
in a general purpose language, Fig 2.1. It becomes clear that it is more complex to

2.5. Shape Grammars

17

represent this phenomena in parallel production systems than in Java. This suggests
an issue for the designer of the L-system in comprehending the consequences of an edit
to an L-system. To address this usability issue, there is limited work to reconstruct
L-systems from an image representations [216, 206] or user sketches[14], avoiding the
issue of writing grammars altogether.
The above argument suggests L-systems are an over simpliﬁcation of botanical systems, that are not gracefully extended to all observed plant models. It is strengthened
by recent research into physical simulation to model the Auxin hormones that cause
phyllotaxis[212]. More generally, algorithmic botany has moved away from L-systems,
towards deeper physical simulations such as the simulation of tropisms by [175] or
geometric simulation of the apical meristem (growing tip of a plant shoot)[167].
There are similarities between programming an L-system and multicore (parallel) programming. In particular the current string is reminiscent of the shared state of some
parallel models of computing, and developmental delay[191] is similar to message passing. The similarities suggest that some of the problems of multicore programming may
be present when designing large L-systems. These may include synchronisation issues,
dead and live locks, as well as race conditions.

2.5

Shape Grammars

In the previous sections we have examined grammars that are formed by production
rules over strings of symbols (formal grammars and L-systems), as well as graphs. In
contrast, shape grammars consist of production rules that match and replace certain
shapes in a ﬁgure. The high level description of the grammar remains the same —
a start state is given, and production rules transform it to a shape in the language;
however the states and rules are expressed as shapes rather than graphs or symbols.
Stiny and Gips created the concept of shape grammars in 1971[222]. They have since
been used in a relatively unchanged form to design a wide range of procedural models
within academia. We may position shape grammars in our spectrum of proceduralisation by noting that like L-systems they are constrained to the construction of geometry.
They are also Turing complete[81].
In comparison to L-systems, shape grammars are indeed grammars. They specify a
language, a set of valid statements, but do not say which speciﬁc sentence should be
generated at a particular evaluation. The order of the rules applied maybe determined
manually or automatically depending on the application.
The formalism behind a shape grammar eventually[219] came to consist of a set of
shapes, S, a set of symbols, L, an initial labelled shape, γ0 , and a set of production

2.5. Shape Grammars

18

initial shape

initial shape

rule 1
T T T

rule 1

T T T

T T

rule 2

T T

rule 2

T T T
T T T
T T T

T

T
T T

T T

rule 3
rule 4
rule 5

T

rule 7

T

rule 4
T T
T T
(2) rule 8

rule 6

T

T T T

rule 8

T T
(2) rule 6

Figure 2.15: Left: We introduce a shape grammar consisting of 8 shape rules. The
shapes on the left of each arrow may be replaced by the shapes on the right of the same
arrow. Right: An example derivation of this shape grammar that creates a bungalow.
The number of applications of a rule are speciﬁed in parentheses.
rules, R; each production rules takes the form α → β. The left hand side, α, speciﬁes
zero or more labelled shapes, (S, L)∗ , that are matched against the current shape. The
right hand side, β gives a labelled or unlabelled replacement, ∈ (S, L)+ ∪ S+. As
with the previous grammars, we begin with γ0 , applying rules until all symbols have
been removed. At this point the current shape, γ is an element in the language deﬁned
by the grammar.
In contrast to L-Systems, the production rules are not applied in parallel to all matching
instances, rather in a serial manner reminiscent of Chomsky grammars[41]. Given the
lack of restrictions on the context of the shape, we may see similarities with a type-0
Chomsky grammar.
An example of a very simple fa¸ade shape grammar is given in Fig. 2.15, left, using the
c
symbols L = , T . We show the evaluation of one shape in the language in Fig. 2.15,
right, by repeated production rule application until no symbols remain. Various other
shapes in the language are shown in Fig. 2.16.
A single grammar production rule can often be matched to an inﬁnite number of

2.5. Shape Grammars

19

...

a
rule 1
rule 2
rule 4
(2) rule 8
(2) rule 6

b

d

c

(4) rule 1
rule 2
rule 3
(9) rule 7
(4) rule 6

(3) rule
rule 2
rule 5
(3) rule
(2) rule
(5) rule

1

7
6
8

(*) rule 1
rule 2
rule 3
(*) rule 6
(*) rule 8

Figure 2.16: Four evaluations of the shape grammar given in Fig. 2.15, with the
rules that created them.

A
A

...

A

A

Figure 2.17: Left: A shape grammar production rule that positions a tree on an
arc. Right: If we allow subshape matching under rotation we may position trees at an
inﬁnite number of locations on a circle. We show the result of several applications of
the production rule upon a circle.
positions on the current shape by matching subshapes. For example a rule containing
an arc may be positioned at an inﬁnite number of points around a circle, as in Fig. 2.17.
Given this ﬂexibility of rule application, it is a natural that the categorisation of the
diﬀerent varieties of shape-grammars concerns itself with the mechanism for matching
α against the current shape, γ, the subshape problem. Common variations include:
• the shapes that may be matched — such as only lines, rectangles or curves in 2D
or 3D,
• the type of matching that occurs — whether only whole shapes (such as rectangles), or subshapes (such as one corner of a rectangle), may also be matched. The
advantage of subshape matching is that it allows more “emergent” (unexpected)
shapes to be generated,

0)

)

y1

y5
,

10
,

(x
5

y4 )

(x

y5
,
(x
5

(x
4,

)
y3
,

,

y7
(x
3

(x
3

y1 )

)

(x
1,

(x

(x
6,
y6 )
(x
1,
y1 )

)
y2
,
2

(x
7

y3

)

)
y2
,
2

,

(x

20

)

2.5. Shape Grammars

(x
8,
(x y8 )
(x 4 ,
9,
y9 ) y4 )

Figure 2.18: A single parametric shape grammar production rule inspired by[219].
The accompanying schemata might specify that the new point (x6 , y6 ) lies on the line
between existing points (x1 , y1 ) and (x2 , y2 ), and similarly for the other new points.
This parametrisation permits a language of nested pentagons to be deﬁned.
• the transform we are allowed to apply to alpha to locate a match — such as
isometries, rigid transforms or aﬃne transforms, and
• whether any parametrisation of α is allowed.
These parametric shape grammars[219] are variants which allow the arbitrary parametrisation of production rules. We show an example parametric rule in Fig. 2.18. There
are no computational limits placed on these rules, and are typically expressed in the
corpus by prose[218], or omitted entirely[71]. These parametrisations can be also used
to limit the repetition of rules, for example by adding area or height conditions.
The computational complexity of ﬁnding potential matches of α in the current shape,
γ, the subshape problem, is well studied. The matching of whole labelled shapes has
a linear computational complexity in the number of the current shapes. Therefore
there are well developed algorithms and systems for matching rectilinear[126, 125] and
curved 2D shapes. However parametric subshape recognition is NP-hard[273], even in
the case of a rectilinear shape vocabulary. This has not stopped implementations of
the parametric case in 2D[148]. The theory of shape recognition in 3D is addressed by
[127], against straight line ﬁgures only, while [38] introduces an implementation that
limits their use to circles and arcs. The issue of subshape matching with general curves
and surfaces in 3D is still unaddressed in the literature.
Despite these complexity issues, shape grammars have been widely applied in academia.
The initial examples were artistic drawings[222] and 2D architectural plans[221]. These
were extended to 3D isometric plans of houses, generated using parametric shape
grammars[123]. 3D shape grammars are less common, and tend to be simple, such as
modeling historic soft drink bottles[38]. A wide range of applications have been found

2.5. Shape Grammars

21

for shape grammars include modeling the morphospace of chair-backs[120], Harley
Davidson motorbikes[194], and coﬀee machines[4].
A subtlety of shape grammars are their termination criteria. The language speciﬁed
by the grammar does not contain all possible evaluations of rule sequences, but only
those shapes that do not contain symbols. There are sequences of production rule
applications in Stiny’s well cited Palladian grammar[221] that lead to dead-ends in
which the grammar can never terminate, Fig. 2.19. Of particular issue is the fact that
there are no guarantees as to how many times we might have to evaluate statements
in the grammar before a valid result in the language is generated.
The lack of a mechanism to specify situations in which a rule cannot be applied causes
additional diﬃculties with self intersection and termination (negative application conditions in graph grammar terminology). A shape grammar rule with a β that is a
superset of the corresponding α gives rise to an inﬁnite language. We present an example in Fig. 2.16d, in which the fa¸ade may be indeﬁnitely tall. This poses the problem
c
of how to stop a sequence like this from intersecting other geometry, especially in
non-parametric shape grammars.
Because of the requirement for shapes in the language to not contain symbols, and
the inﬁnite nature of certain shape grammars, we may characterise shape grammars
as a search through some shape-space. The order of search can either be manually
deﬁned (as in most of the corpus) or automated to produce ﬁgures automatically[86].
Regardless of the mechanism for choosing rules, sequences of rules will behave in one
of the following ways:
• All symbols will be removed, and a ﬁgure that the grammar describes will be
produced.
• Symbols remain in the ﬁgure, but no further rules may be applied. The evaluation
stalls at this invalid shape (Fig.2.19).
• The evaluation continues endlessly. Either by force or choice the sequence of
applied rules is unending, and evaluation continues indeﬁnitely. There are similar
situations in formal grammars, graph grammars and L-systems.
Other common issues surrounding the use of shape grammars are well summarised by
[81], for example
• the subshape and termination problems introduced above,
• the design of an adequate interface for the construction and application of shape
grammars,

2.5. Shape Grammars

22

(0,0).A

A’

rule 1
rule 3
(2) rule 5
rule 4

O
(3) rule 7
rule 6

(0,0).A
rule 1
A’
A O A
A’

O

rule 2

(4) rule 10
(2) rule 8

O
rule 7
A’
O
O
rule 11

rule 6

P

B

P

O

P

B

P

Figure 2.19: Top Left: An example from Stiny’s Palladian shape grammar[221].
Bottom left, right: Example rule sequences in the same shape grammar that lead to
dead ends. After these rules, there is no way to remove the symbols •, or O, leading
to evaluations of the grammar that are not in the language.

2.6. Split Shape Grammars

23

• the lack of robust implementations for parametrised shape grammars,
• the diﬃculty in application to non-linear geometry, such as curved surfaces,
• the lack of a standardised shape-description, and ﬁnally,
• the lack of production grade or commercial systems for working with shape grammars.

2.6

Split Shape Grammars

The computational complexity of classical shape grammars seems to have limited their
use to small scale academic projects. However in 2003, Wonka et al. created a specialisation of shape grammars, split shape grammars[263], with lower complexity. To
simplify their computation these extend set grammars, initially within a 2D domain
of labelled nested shapes using only whole-shape matching. These grammars have
been shown to be well suited to large urban environments, and fa¸ade generation in
c
particular.
As the name implies, a split shape grammar consists of production rules that take a
labelled shape and split it into a number of covering labelled shapes. Unlike a shape
grammar these labels are categorised as terminal or non-terminal. This delegation of
area to subsequent rules continues down a hierarchy until only shapes with terminal
symbols remain.
A principle assumption is that this hierarchical split operation is well suited to the generation of designed structures. There is ample justiﬁcation for this assumption in the
literature of early urban modeling pipelines, such as the book A Pattern Language[10],
which introduces a hierarchy of 35 guidelines for the design of of urban areas, ranging
from “major city structures” and “common land” to “structure of the ﬂoor and walls”
and “furnishing”:
“The elements of this language are entities called patterns. Each pattern describes a
problem which occurs over and over again in our environment, and then describes the
core of the solution to that problem, in such a way that you can use this solution a
million times over without ever doing it the same way twice.”
The book is representative of the architectural literature in that it purports to present
solutions to urban design problems, without providing suﬃcient details for an computational implementation, for example:

2.6. Split Shape Grammars

24

“Pattern 10...Do this by means of collective regional policies which restrict the growth
of downtown areas so strongly that no one downtown can grow to serve more than
300,000 people.”
This hierarchical split approach to urban languages presented by A Pattern Language
is quite pervasive in the computer graphics literature, with examples such as [69], [94],
[12], and [176] using variations on the theme of a hierarchical urban decomposition.
Returning to Wonka’s 2003 paper[263], we observe that this concept of a strict hierarchy
in urban design is exploited to simplify shape grammars.
Compared to shape grammars, split shape grammars have the advantages of fast evaluation and no dead-ends during the evaluation. The subshape problem is bypassed by
using a set grammar[220] in which matching takes place based on a whole shape and
a symbol. This removes the emergent behaviour of subshape matching, but permits
ﬁnding all possible shape matches in linear time of the size of the existing ﬁgure. While
certain split shape grammars may be evaluated endlessly, if they do terminate they are
guaranteed to supply a valid shape, in contrast to shape grammars.
M¨ller et al.’s later inﬂuential paper, Procedural Modeling of Buildings[159], extends
u
the concept of a split shape grammar to 3D and introduces a written formalism for split
shape grammars, CGA Shape. The system has gained widespread use and notoriety as
it has been successfully commercialised [66].
A CGA Shape grammar consists of an initial labelled shape and a set of production
rules, each with a certain priority. All the applicable rules with the highest priority
are executed before others; this priority mechanism is exploited to produce diﬀering
geometry based on the required level of detail. Models with higher details are generated
by executing rules with lower priority.
To deﬁne the reference frame for the production of geometry, a scope is introduced
that deﬁnes a frame, as well as an extent, as in Figure 2.20. This is reminiscent of an
L-system’s turtle. When geometry is created, the scope deﬁnes the size, location and
orientation. When the current shape is split, it deﬁnes the orientation and number of
splits.
A production rule of a given priority in CGA Shape consists of a unique ID, a parametric
symbol to match on, an optional condition, a labelled successor shape that is generated,
and a probability which which the rule will be applied: id: predecessor : cond
successor : prob. The successor operation has an involved syntax that is able to
manipulate the scope via transforms, splits, repeats and dimension reduction. A 2D
example is given in Fig. 2.21. The condition is used to limit the applicability of the
rule, for example to shapes of a certain size, or if certain occlusion conditions are met.

2.6. Split Shape Grammars

25

x
z

y

1: hex
T(1,0,0)
S(0.4, 0.5, 0.5)
I(“hex”)

3: hex
Subdiv(“x”,1r,1r,1r)
{A|A|A}

x
y

2: hex
Comp(“sidefaces”) {A}

Figure 2.20: The current scope in a CGA Shape grammar deﬁnes a frame and extent
for the production rules. Given the initial 3D scope, shown in the top left, and the initial
geometry, top middle, we show the result of three production rules. Rule one translates
and scales the frame before adding another hexagonal prism of dimension speciﬁed by
the transformed frame. Rule two performs a component split, creating 2D faces, giving
them each their own 2D frame. Rule three subdivides the current shape along the x axis
into 3 equally high prisms, and matching scopes.
These occlusion queries form a domain-speciﬁc environmental sensitivity that is used,
for example, to stop the production of windows occluded by roof geometry. This is the
only context sensitivity available in the system.
Split shape grammars have been successfully applied to the reconstruction of several
historical sites such as Mayan ruins[164], the ancient Roman city of Pompeii[158, 58]
and Malay houses[202]. Novel uses of split shape grammars include the presentation of uncertainty in archaeological ﬁndings by presenting several derivations of a
grammar[93], and animatable articulated objects structures[108].
Writing the production rules for split grammars is somewhat involved and required
specialist knowledge. Several attempts have been made to simplify the process. The
ﬁrst presents the production rules as a graph[179], giving an understanding of the
relationship between application possibilities of the rules. However using this system
requires the user to comprehend the underlying grammar before using it. An alternative
is given by Lipp et al.[139], who allows the user to construct a grammar by editing an
example instance. By constraining the modeling tools to those that may be translated
to production rules, the user is able to quickly produce a PGM without interacting
with the grammar itself. When a user edits a single feature in an example instance,
this edit must be encoded into the grammar, in a persistent manner. To do this Lipp
introduces instance locators to store user edits in a split shape grammar, Fig 2.22.

2.6. Split Shape Grammars

26

u

w

w

w

u

w

w

w

w

l

fa¸ade
c

w

w

d

w

w

a

wl
wr

wt
wm
wb

dt

dm

dl

wc

dc

dr
1: fa¸ade
c
2:
u
3:
l
4:
w
5:
d
6:
wm
7:
dm
8:
wc
9:
dc

Subdiv(“X”, 2, 0.2, 1r, 1r){l|a|u|u}
Repeat(“Y”, 1.5){w}
Subdiv(“Y”, 1.5, 1.5, 1.5, .1.5){w|d|w|w}
Subdiv(“X”, 0.3, 1r, 0.1){wt|wm|wb}
Subdiv(“X”, 1r, 0.3){dt|dm}
Subdiv(“Y”, 0.15, 1r, 0.15){wl|wc|wr}
Subdiv(“Y”, 0.15, 1r, 0.15){dl|dc|dr}
I(“window”)
I(“door”)

Figure 2.21: The production of a fa¸ade in CGA, top, via the given grammar, bottom.
c
Rule 1 splits the fa¸ade into 3 ﬂoors and a architrave (top middle). Rules 2 & 3 create
c
repeating windows and doors according the ﬂoor (top right), while rules 4–7 further
reﬁne the window and door positions. Rules 8 & 9 position geometry to create the
doors and windows (middle right).

Figure 2.22: The instance locators of Lipp et al. [139] identify a component by its
position in a derivation tree (left). After each production rule the index referred to
(dashed lines) can be stored relative to the start, middle or end of the split sequence.
The instance locator can be used to store modiﬁcation to a procedural object, such as a
modiﬁcation to the style of a window, right.

2.7. Data Flow Programming

27

Figure 2.23: Left: The strict hierarchy may cause problems for coordinating features,
as in this evaluation of the grammar of Fig. 2.21, showing a lack of synchronisation
between the ground ﬂoor and upper windows. Right: The over-compartmentalisation
means that it is impossible to place some features that cross over the hierarchy’s bounds,
such as positioning an intercom near the door (black rectangle).
Strict hierarchy and over-compartmentalisation can cause problems when working with
shape grammars[103]. For example sharing information about the number of elements
in a fa¸ade(), as in Fig. 2.23, left. Additional diﬃculties are caused by problems placing
c
objects over two or more disjoint portions of the hierarchy, as in Fig. 2.23, right. In
these situations it is necessary to re-write the grammar to add a new shape, or to
add some portion of the shape to two separate portions of the hierarchy. Recently
work has begun to address this issue by creating connection patterns between portions
of two diﬀerent shape grammars[124]. The problem of over-compartmentalisation is
uniquely critical to split shape grammars; while some shape grammars do use such a
hierarchy[221], many do not[141, 123].

2.7

Data Flow Programming

Data-ﬂow graphs are a model of parallel computation introduced as an alternative to
the classical von Neumann model.
Written imperative programming languages are typically a 1D sequence of symbols
which explicitly sequence instructions. This ordering of instructions is typically associated with the von Neumann model, which executes a single instruction at a time. In
contrast, a parallel model of computation may execute many instructions concurrently.
To schedule the execution of a single instruction, a general requirement is that the
instruction’s inputs are available — whether they have been entered by the user or
calculated by a previous instruction. The necessity of the inputs’ availability creates
a dependence of the following instruction on the previous instructions’ execution, and

2.7. Data Flow Programming

28

a

b

mul

c

d

mul

1
add

2

3

Figure 2.24: A data ﬂow graph that calculates ab + cd given the mathematical convention that multiplication instructions are performed before addition. The circular
nodes are instructions, while the directed edges are the data ﬂows. An inbound edge
is an input to the instruction, while an outbound edge is a use of the output output.
Each instruction requires that all of their inputs be present before calculating an output.
For example instruction 3 requires both instruction 1 and instruction 2 to be complete.
However the order of the operations are not speciﬁed in a data ﬂow graph, so the execution order may be 123, 213 or instruction 1 and 2 may be executed in parallel before
3.
may be represented as a data ﬂow from the previous function to the next, as in Fig. 2.24.
In this way data ﬂow languages are declarative, allowing the executing system’s scheduler to determine the order of operations given the data ﬂow constraints.
We introduce data ﬂow languages, and in particular graphical data ﬂow languages for
geometry as a typical example of a general non-written PGM system, before looking
at an example commercial application. The topic of data ﬂow programming occupies a
wide range of our procedural spectrum. A data ﬂow language with loops may be Turing
complete, and has many applications from parallel programming to task scheduling.
However there are a number of implementations that are graphical and geometrical —
their user interface is a graphical graph editor, and their output is geometrical. These
are the use cases that are of most interest to PGM, being of similar generality to shape
grammars, being concerned with the graphical domain.
There are several varieties of data-ﬂow graphs in the literature, we shall brieﬂy examine
the token based model of Dennis from [54], introduced in 1974. Fig. 2.25 shows an
example graph for generating nested rectangles, showing examples of splitting and
combining data ﬂow arcs. A token based data ﬂow model models the arcs in data ﬂow
graphs as FIFO queues of tokens. Each token is associated with a value, in our example
this value is either a rectangle or a Boolean. When a node has a token available on
each of its inputs it removes these token from its input arcs, computes an output, and
adds a token representing this output to any output arcs. The FIFO queues may be

2.7. Data Flow Programming

29

input rect a

false

t

f
select

e

area > 3 c

d

shrink rect b

distribute f
t
f

display
h

g
Figure 2.25: A token based data ﬂow graph (left) that generates nested rectangles
(right). The data ﬂow graph takes an input rectangle (a), shrinks and positions it (b)
or terminates if the area is less than a constant (c), otherwise the sequence repeats itself.
The sequencing issue of whether to take a new input rectangle, or iterate on the existing
is addressed by the select and distribute nodes. The select node (d) outputs either the
new input rectangle, or the result a previous iteration, based on the horizontal input;
it is initialised with a token of value false (e) to initially take a new input rectangle.
The distribute node (f ) sends the output of the shrunk rectangle to one of two locations,
based on the result of the area test. It is either discarded (g), or output (h) and used
in a subsequent iteration via the select node (d).
initialised with tokens before the system is executed (as Fig. 2.25e). Ensuring that the
correct sets of input tokens arrive at the front of the FIFO queues at the same time
is challenging for the user, as demonstrated by the involved select/distribute syntax
of our example. This sequencing issue is one that will occur frequently in data ﬂow
graphs.
We note that the graph of Fig 2.25 can only be used for the generation of one ﬁgure
at a time because of loops, negating the advantages of parallelism. This is somewhat
mitigated by the use of tags[54, 254], in which each invocation of the graph uses tokens
with diﬀerent tags, allowing the same instruction node to execute on diﬀerent sets of
input concurrently.
An alternative data ﬂow model oﬀers a diﬀerent way to mitigate the sequencing issue,
by removing loops from data ﬂow graphs. The structural data ﬂow model[47] models

2.7. Data Flow Programming

30

Figure 2.26: A visual data ﬂow diagram used for controlling the temperature of a
virtual water tank.
arcs as arbitrary and possibly inﬁnite data structures. As computations are completed,
these data structures are updated, and their values used by subsequent nodes. Structural data ﬂow diagrams do not require loops as the token ﬂows do, however this comes
at the cost of storage; all computed values are retained by the data structures. Additionally nodes must be equipped with the logic to comprehend the, possibly involved,
input data structures.
While textual systems, such as LAU[184] and CAJOLE[98], focused on parallelism and
eﬃciency, another early justiﬁcation for data ﬂow programming was ease of use. Curiously the development of easy to use graphical user interfaces to data ﬂow languages
preceded these formal textural languages. In particular Sutherland introduced a data
ﬂow editor[225] in 1966, 8 years before Dennis’s work. This system used a light-pen
to edit the structure of data ﬂow graphs, and deﬁne functions by drawing nodes and
arcs. There followed many graphical data ﬂow research languages, with examples such
as the Graphical data-driven Programming Language[48] and Grunch[50], a graphical
interface to CAJOLE. Many of the graphical programs were more visually complex
than their textural counterparts. In particular embedding a data ﬂow graph into the
plane often leads to the crossing (without connecting) of graph arcs, making reading
the graph quite diﬃcult. However this did not stop the use of graphical data ﬂow
languages in industry, with systems such as Prograph[147] for general programming
and LabVIEW[109] as a digital laboratory, Fig 2.26.
There are several interesting diversions at this point that are beyond the scope of this
document:
• Data ﬂow graph editors cannot express anything more than a written language (at
their most expressive they are still only Turing complete) despite their additional
dimensions. However many authors make the claim that graphical programming
is easier as it is more diﬃcult to introduce syntax errors than when writing text
based programs.

2.7. Data Flow Programming

31

Figure 2.27: A random walk (red line, top right) programmed in the Scratch visual
programming language[195]. Statements are chosen from the palette on the left to be
added to the program in the centre. The execution of the program is performed by the
cat sprite in a turtle-like manner, top right. Note that invalid expressions may not be
programmed, for example there is no attachment point to add a further operation after
a “loop forever” statement.
• There are a signiﬁcant number of graphical editors for imperative programming[229,
82]. These exploit the ease of use of graph-based systems to appeal to, for example, those new to programming. For example Scratch[195] shown in Fig. 2.27
is able to create geometry. These control graphs describe the sequence of operations, rather than the data dependencies, usually allowing side eﬀects and
mutable data structures which data ﬂow programming avoids.
• We may create graph based graphical visualisations of many aspects of a program. For example the data structures may be modelled by the Uniﬁed Modeling
Language (UML) or we may animate the ﬂow of data[205]. These are analytical,
not generative, applications of graphs to programming.
As graphical hardware advanced it became clear that the graphical editing of data ﬂow
programs was a good candidate for create geometric programs. To clarify, not only
is the program edited graphically, but also creates geometric output. These systems
provide a widely used example of PGM without written programs, albeit under another
name.
The Fabrik Programming Environment[144] allowed 2D graphics, user interfaces, and
their elements, such as scroll bars, to be constructed within a dataﬂow environment,
but suﬀered from “poor performance”. Conman[92] utilised data ﬂow graphs on more
complex graphics hardware to create 3D objects. A user of the system could construct
nodes that interact with the user, allowing interaction between user interface sliders,
2D curve editors, and arbitrary scripts to create 3D objects. Later Lovejoy et al. used

2.7. Data Flow Programming

32

Figure 2.28: An example of data ﬂow being used to conﬁgure the visualisation of
a surface via OpenDX. The two paths the data takes through the graph construct the
isosurface and surface velocity, before combining them into the single 3D view.
the Prograph data ﬂow language to control a 2D turtle[143], and Abram et al. use
data ﬂow languages to visualise 3D data[3]. More recently data-ﬂow as a programming
paradigm has been seen use in the graphics literature. For example the strict hierarchy
and lack of side eﬀects in split shape grammars can be modelled as a visual graph[179].
In [25] a message-passing approach, reminiscent of data-ﬂow programming, is used to
connect an otherwise disjoint L-systems.
Perhaps more signiﬁcantly the data ﬂow model is used extensively in recent commercial
software; 3D modeling packages frequently utilise some form of data ﬂow graph as an
alternative to scripting languages. Both Alias’ Maya’s Hypergraph and Blender’s Nodes
use data ﬂow graphs to describe causality within complex kinematic systems, and the
relationships between diﬀerent texture channels. OpenDX[232] uses data ﬂow graphs to
allow users to quickly visualise data sets of a wide variety of types, as in Fig 2.28. The
hierarchical compartmentalisation makes shape grammars a target for data ﬂow graph
editors, as implemented in CityEngine[66]. A more general dataﬂow programming
system is given by the likes of Generative Components[26] or Grasshopper[46].

2.7. Data Flow Programming

v1

33

v2

v3

Figure 2.29: The result of varying the parameters v1, v2 & v3 in the Grasshopper
parametric model of Fig. 2.30.
To conclude this discussion of data ﬂow graphs we introduce details of Grasshopper to
give an indication of the typical tools available in these languages. Grasshopper uses a
structural data ﬂow graph to describe procedural geometry. We give an example of a
Grasshopper data ﬂow graph in Fig 2.30, to create the geometry of a procedural truss
bridge in Fig 2.29.
The structures transmitted along the arcs are nested lists, each nested to a uniform
depth. Because only lists with the same nesting depth can be used as inputs to the
same function, Grasshopper’s UI indicates the nesting depth by the type of line between
nodes (undecorated, double or dashed lines for single elements, lists-of-elements or
lists-of-lists-of-elements respectively), as in Fig 2.30. To address the sequencing issue,
when an operation node takes more than one input Grasshopper speciﬁes several datamatching techniques, demonstrated in Fig. 2.31, based on the number of evaluations
of the operation — either the shortest, longest, or product of the sizes of the inner
most list. In addition there are a number of operations for re-ordering or selecting
elements from the data structure, marked by ∗ in Fig. 2.30. However they are only
able to manipulate elements in the inner-most list; more complex patterns require
writing programs to order the nested lists.
As an aside we note that data ﬂow programming in no way alleviates the standard
numerical computation issues, as witnessed by the removal of a small delta in two
places of the computation, marked ‡ in Fig. 2.30.

*

‡

v3

*

Figure 2.30: Top: A graphical geometric data ﬂow graph in Grasshopper. The model is controlled by three numeric parameters v1, v2
& v3, controlling the number of vertical beams, the curve of the arch and the number of horizontal beams respectively. Bottom: The
truss structure generated, colour coded to indicate the graph nodes that created the geometry, starting with the grey rectangle input to
the system (top, far left).

v2

v1

2.7. Data Flow Programming
34

2.8. Simulation Approaches

35

Figure 2.31: Data matching in Grasshopper. When joining the horizontal truss
members, three techniques are oﬀered — Left to right: Shortest list, longest list and
cross reference.

2.8

Simulation Approaches

Creating grammars to describe man made objects is somewhat natural, as we are
able to encode the design process that a human may go through to create an object.
However there are many non-designed artifacts that we may wish to model in a procedural manner, for example terrains, the historical growth of cities or damage to trees
and plants. Simuation approaches to procedural modeling involve the immitation of
observed processes to approximate the interactions within a model, and between the
model and its enviornment.
Simulation is used in a wide variety of ways to create geometry; we have already seen
examples of grammars simulating the growth of plants using L-systems[51] and complex
systems via data ﬂow graphs[109]. We may even consider that view the exploration of
grammar derrivations are simulating the human design process. This section explores
a collection of systems that have simulation in common.
A very simple form of simulation are cellular automata; a speciﬁc example is provided
by Conway’s Game of Life[77] in which every simulation step updates a 2D array of
cells (boolean values) using very simple rules. As illustrated in Fig. 2.32, these simple
rules are executed in parallel on every update step, possibly changing the value of a
cell. Despite the simplicity of the rules, diﬀerent starting values for the cell yields a
wide range of persistant and varied forms.
Attemping to program Conway’s Game of Life for a particular purpose is often quite
involved, however it delights in the unexpected behavours that may be observed as
the simulation progresses. These unexpexted or emergent behavours have been better
studied in simpler still automota, such as those 1D systems studied by Wolfram[261].
Fig. 2.33 shows certain very simple rules creating complex patterns. There are 256
similar sets of rules, and this example is one of two examples that exhibit these emergent
properties, generating aperiodic, non-local structures.
Emergent behavour seems to be very powerful as it produces intricate patterns from

pr
ev

io
ne us
ig
hb
ne our
xt
s

2.8. Simulation Approaches

36

n=0

0-1
2-3
4-8
0-2
3
4-8

n=10

n=200

Figure 2.32: Left: Conway’s Game of Life[77] simulation takes place on a 2D grid,
the transition from a living (black) to a dead (white) state occurs based on the current
state and the eight neighbours (top). Middle: The glider pattern, which self-propogrates
along a diagonal as the simulation progresses. Right: A space-ﬁlling pattern by Hartmut
Holzwart, at simulation steps 0, 10 and 200.

...

Figure 2.33: A Wolfram cellular autamata deﬁnes a transition over a 1D sequence
of cells who are either alive (black), or dead (white). Left: In this particular case “rule
30” speciﬁes these eight transitions given a context of three cells (the cell to the left,
the cell itself and the cell to the right). Middle: When applied in parallel these rules
mututate a start state consisting of a single black cell in a deterministic manner. Right:
We may repeat this procedure a large number of times to generate an complex emergent
system of local structures throughout the right hand side of the pyramid.

2.8. Simulation Approaches

37

very concise descriptions. For these reasons simulation seems to lie on a cusp on
our spectrum of procedural modeling. Those general models that we have already
examined, may exhibit emergent behavour, while those that follow are less likely to.
However, by deﬁnition, emergent behavours are not intended. It is diﬃcult to engineer
these system with particular properties; perhaps the only way of working with these
systems is to have a large library with known behavours, and to select the system with
the most desirable properties.
Turing’s work on emergent patterns in physically based simulations[239] suggests that
this library approach may be the one favoured by natural selection; appropriating
emergent patterns into situations where they are evolutioanry advantagous. However
these approaches have not found much traction in the computer graphics and procedural modeling mainstream. Examples are limited to corpora to texture synthesis [149]
and the physical simulation of plants. Smith et al. construct a time-based 3D growth
simulation of the meristem (growing tip of a plant’s shoot) in [212]. By modeling the
ﬂow of growth hormone auxin through this region, and the geometric changes that
it produces, the model produces a realistic geometry demonstrating several modes of
Phyllotaxis.
As well as simulating the processes within a plant, there is also a body work that
simulates the environment surrounding a plant. 3D (voxel ) cellular automata may
be used to model the intersection, proximity and occlusion of a plant[87]. Traumatic
events, such as branches breaking may be modeled as step events during the simulated growth of a plant[51]. The growth of a tree through a volume can be simulated
as a space colonization algorithm[201] while structural simulation can create balanced
trees[100]. Finally some systems simulate the interaction between both internal and external factors; for example work by Prusinkiewicz et al. growth[163] simulates both the
plant-state, via L-systems, and exogenous factors such, as the availability of daylight
and water.
Another frequently simulated domain are cities. Many systems exist for modeling land
use, populations and travel costs within cities[250, 208]. Mostly these use with grids
of data points, or ﬁxed-structure cells to represent design and layout, some even use
cellular automata to model these processes[9, 104].
The introduction of PGM to urban modeling simulations has allowed the geometry
of a city to varied and variable, as well as creating rich visualisations of the resulting
cityscapes. Typically geometric city simulations follow the same procedural urban
modeling “waterfall” pipeline as time-static procedural cities[176], an example of which
is given in Fig. 2.34. Major roads, such as motorways and A-roads provide access to a
quarter, an area with particular characteristics. Access within the quarter is provided

2.8. Simulation Approaches

38

Major Roads
Quarters
Minor Roads
Blocks
Parcels
Mass Models
Fa¸ades
c
Figure 2.34: A typical urban modeling pipeline, similar to [255] and [245].
by minor B-roads. The area between B-roads becomes blocks, which are futher split
into parcels of land. Finally buildings are positioned on the lots - the 3D geometry
described by mass models, each face of which is then assigned a fa¸ade. When working
c
with discrete time-step simulations, as in the 2D model by Vanegas et al.[244] or 3D
model by Weber et al.[255], it is necessary to repeat this course to ﬁne hierarchy with
every time step. Examples of Weber’s resulting land-use and transport map are given
in Fig. 2.35.
This concept of a single pipeline is a gross simpliﬁcation of the processes that occur
within a real city, in which many other factors are considered — for example major
roads must take into account and avoid historical buildings. However the waterﬂow
pipeline is an computationally eﬃcient system with proven results. A system that
allows for interactive feedback between users of the simulation and the system itself
is preseted by Vanegas et al.[246]. The user may edit values in the simulation using
a paintbrush tool, after which the simulation then commences and the system brings
the underlying behavioural and urban models back into equilibrium under the new
assumptions. This is useful urban planning tool for quickly examining the results of
decisions, such as building new roads in neighborhoods.
A further use for simulation at the building level is for the investigation of the physical
strength of a system. For example we may wish to:
• identify the safe range of parameters in a parametric model, such that our building
is able to support itself[259].
• design a truss structures to support certain loads[211].

2.9. Inverse Procedural Modeling

year 10

year 20

39

year 30

year 40

Figure 2.35: The work of Weber et al. simulating the geometric growth of a city[255].
• ﬁnd self-supporting freeform surfaces[249] that are suﬃcently strong to be constructed.
• build furniture that is both stable and durable[241].
Each of these systems allow the user to specify a model and then simulation is used
to search for physically stable variation. This approach blends artisic human design
elements with automated reasoning about the properties of such a design.
Finally we examine systems that use simulation for interior design. Two recent systems attempt to position a given set of furniture in room by maximising an evaluation
function. Merrel et al.[153] encode various interior design guidelines, such as the distance chairs should be from one another to permit conversation. Starting from a
user suggestion, the system is able to ﬁnd a solution that accomodates these guidelines. Alternately Yu et al.[272] learn pairwise relationships between items of furniture
from several examples, and include occlusion constraints to ensure clear paths between
doorways. Both of these systems simulate a walk through an evaluation function by
Markov Chain Monte-Carlo sampling. While this is perhaps not simulation in the classical sense, it may be seen as simulating a human designer’s exploration of the design
decisions.

2.9

Inverse Procedural Modeling

As we have seen, the creation of procedural models is quite involved, requiring considerable knowledge of grammars and languages. Recently there have been attempts to
generate procedural models from real world examples, the process of inverse procedural modeling. As with much of the shape grammar literature, the focus has been on
applications to the urban environment.
The data from the input examples may have been captured via multiple cameras and
terrestrial or aerial LiDAR (Sec. 2.12 contains further details); therefore it may contain

2.9. Inverse Procedural Modeling

40

signiﬁcant quantities of noise. Identifying landmarks in this data is the ﬁrst challenge,
for urban environments in particular repeated landmarks are of signiﬁcant importance.
Recent techniques[154, 180] for identifying such landmarks in noisy data cluster the
transforms between similar local features to determine prevalent transforms. To reduce noise in the input data, RANSAC[70] is a popular algorithm, and is utilised
by GlobFit[133] to clean meshes making assumptions about features such as planar
surfaces, repeated distances and shared angles. Finally we can form descriptions of
3D meshes as a tree of such patterns and symmetries[253] for compression and error
correction.
The grammar extraction techniques presented in this section mainly use the models
derived to compress data, rectify noisy captured data, or to extrapolate data to ﬁll
holes. There has been relatively little work to re-target the extracted procedural models
to create novel geometry.
Before we examine systems that derive entire grammars themselves, we note that there
is a quantity of work on ﬁtting parametric models to existing data. In the ﬁeld of
urban layout reconstruction Aliaga et al.[13] learn descriptive parameters for a road
network via statistical analysis; this is then used to create new road maps. Alternatively a template shape grammar may be parameterised to match input from vision
techniques[146].
The construction of grammars from examples has proved diﬃcult, and the majority of
solutions rely on meta-heuristic techniques to search for a suitable candidate. Typically
these techniques repeatedly manipulate the grammar and compare the current results
with the noisy input data. In early work, Dick et al.[55] ﬁt a grammar from several
images using a reversible jump Markov chain Monte-Carlo technique. The grammar
used is relatively simple — a set of walls formed the model, and each wall having a
set of associated decorations. The work is notable as it was able to reconstruct unseen
portions of buildings. Another system that uses a simple grammar and rjMCMC is
that of Ripperda et al.[198, 199] who utilise minimum description length of the derived
grammar as an evaluation criteria. By simplifying the grammar to an assignment
of a parameterised mass model to a number of quads covering the ﬂoor plan, [128]
successfully used rjMCMC to reconstruct large cities from aerial data.
More generally, rjMCMC has been recently used to force the derivation of an arbitrary
stochastic context free grammars to posses some speciﬁc qualities[227]; for example the
silhouette of a derived tree to some speciﬁed shape.
An alternative meta-heuristic for creating grammars are evolutionary algorithms. Simon et al.[209] exploit a Pareto evolutionary algorithm to evolve a fa¸ade shape gramc
mar matching a number of images. In this system the appearance from multiple views,

2.10. Combinatory Modeling

41

and the depth correspondence form the evaluation (evolutionary ﬁtness) function.
An incidental generation of grammars occurs in several places in the urban reconstruction literature. As [96] and [23] typify, the grammar complements the bottom-up
landmark cluster analysis with a top-down grammatical description of the scene, enhancing feature extraction. An alternative approach[234] is to use only the bottom-up
clustering analysis, using the grammar to describe the properties derived from the
input data.
To avoid the need for meta-heuristics entirely M¨ller et al.[161] use the concept of
u
mutual information to identify repeating patterns in images of fa¸ades. The presence
c
of strong horizontal or vertical lines is used to determine the split-locations to generate
a CGA Shape grammar. This leads to a compact representation of the fa¸ade that can
c
be manually extrapolated to 3D. Another assumption that simpliﬁes the construction
of grammars is that of a Manhattan World[243], in which all objects are orthogonal
polyhedra.
M¨ller’s automated extraction of fa¸ades is one example of using the extracted gramu
c
mars to retarget content. In this case the resulting fa¸ade could be re-sized arbitrarily.
c
Another example are Style Grammars[12]; a building grammar is created from 3D geometry, such that it may be retargetted to a diﬀerent ﬂoorplan or height. This system
works principally by analysing the 1D patterns of sequences within a shape-grammar
like environment to predict a split rule for the resulting grammar. Finally Vstava et al.
extract L-systems from 2D vector designs by identifying similar components and then
analysing the transforms between them[216]. These L-systems may then be edited to
create unique new designs.
Inverse procedural modeling has the potential to create models that may be retargetted
to model novel situations, such as constructing buildings of diﬀerent heights or ﬂoor
plans. However the results are, by design, derivative of the examples provided. For this
reason we may consider inverse procedural techniques to be more speciﬁc than general
purpose or simulation systems, yet more general than geometry capture or modeling
systems.

2.10

Combinatory Modeling

A subset of the inverse procedural modeling techniques that have an emphasis on
usability are combinatory modeling techniques. Combinatory modeling assembles subcomponents of example objects to create unique new geometries. These techniques fall
into one of three broad categories based on the level of input that the user is required
to supply.

2.10. Combinatory Modeling

42

Figure 2.36: Texture synthesis by the method of Wei et al.[256]. Left: An example
tree bark texture. Middle: The results of the synthesis. Synthesising a pyramid of
textures helps preserve large features. Right: Each pixel in a scan-line ordering of the
new texture is synthesised in turn. The feature vector of the red pixel is shown in the
bottom right, This will be compared to the example texture to identify a suitable colour
for the pixel.
Combinatory modeling obtains its procedural element from the choices made during
automated assembly. When there is a choice of the choice of parts to attach, a range
of designs may result. However, whatever algorithm is used to make the derivation
choice, the result can only comprise subcomponents of the examples. For this reason
combinatory modeling is a very domain speciﬁc technique in our procedural spectrum.
Early work in combinatory modeling was inspired by the 2D case of synthesising textures. Given an example texture in the form of a bitmap, texture synthesis aims to
generate additional bitmaps that are at the same time characteristically similar to the
input and yet unique. As in Fig. 2.36, the standard technique is to grow an image
from an example texture by combining pixels from the example in a novel order, based
on their neighbourhood. To synthesise a certain pixel adjoining the patch, local pixels
from the patch form a feature vector. This is compared against all possible vectors in
the example texture to ﬁnd the best match[59, 256].
Variations of texture synthesis include image quilting[60], which creates a reasonably
coherent grid of overlapping square texture tiles from the example texture. A minimum
error cut then determines the exact boundary through the overlapping pixels. An
alternative approach is to ensure that the tiles are always positioned in such a way
that adjacent borders do not contain discontinuities. An example of this approach is
given is Wang tiles[43].
When attempting the synthesis of 3D mesh-based geometry, local features, such as
those in texture synthesis, have been successful in reconstructing small missing patches

2.10. Combinatory Modeling

43

of meshes[204] using iterative reﬁnement of nearest neighbour search and blending techniques. The synthesis of entire objects has been attempted by tiling 3 space with compatible cuboids, with early examples using Wang Cubes[207]. Later examples by Merrell et al.[151] use learnt adjacencies between neighbouring cuboids. Merrell extended
his work to arbitrary meshes[152], from which common adjacencies are extracted, and
a backtracking search constructs a new model consistent with these adjacencies. The
system is able to create a large quantity of architectural models with only a single
mesh as input, and no further user interactions. However the work with tiling geometry retains the limitation that only transformations allowed by the tiling, rather than
arbitrary transforms, are present in the output.
Domain speciﬁc tools use specialised techniques to relax this limitation and consider
non-local portions of the geometry when combining portions of meshes. Two notable
examples by Aliaga et al. synthesise city layouts, and fa¸ades. The ﬁrst system[12]
c
extracts statistics about the roads and parcels in an example city layout and and uses
them to synthesise new portions of a city. The gaps between the roads are ﬁlled with
textured parcels generated using a Voronoi tessellation; the textures for these parcels
are taken from similar shapes from the example, and morphed to ﬁt. Given a segmented 3D fa¸ade the second system[12] decomposes it into a simple split grammar by
c
identifying 1D patterns, which can be retargetted to new geometry or ﬂoor plans. More
recently work has taken place to allow “intertwined” 1D sequences of elements over
such a fa¸ade, allowing for more irregular elements to be represented in a retargettable
c
fashion[135].
To overcome tiling limitations generally symmetry analysis techniques have been developed[154]
to identify compatible (symmetrical) subcomponents and valid location site, from an
example model[31]. To address the subsequent issue of controlling which of several subcomponents is positioned at a certain site, systems such as those by Kalogerakis et al.
introduce a probability based approach[113] which learns the conditional probability
of certain classes of geometry being adjacent, and the spacial relationship between the
parts. To gather these probabilities, a large number of examples with subcomponents
are required, but the result is a realistic combination of those subcomponents. For
example when working with a corpus of aeroplanes, propellers are not combined with
jet-engined chassis.
In contrast to these unsupervised combinatory modeling techniques, interactive combinatory modeling of arbitrary meshes is addressed by Funkhouser et al.[74]. This
work introduces a tool-chain to allow the user to quickly create detailed models using
subcomponents from existing libraries. A shape-based search ﬁnds components in a
database, and both positioning and mesh blending tools are provided to the user to
align and attach those subcomponents to the existing model. This work is later ex-

2.11. Shape Deformation

44

Figure 2.37: Two geometry errors with combinatory modeling systems. Left: From
[113], the rigging of this novel boat is not attached to the deck because there is no
mechanism to deform subcomponents. Right: From [135], if subcomponents are not
carefully selected it is easy for the large scale geometry to contain undesirable patterns,
such as the roof on this model of the Parthenon.
tended to search for 2D sketched proﬁles of shapes in a library[130]. Other systems
specialise in the interactive synthesis by example of repeating 1D systems[172] and the
use of genetic programming to inspire the exploration of subcomponent-space[266].
An obvious limitation of combinatory approaches is that they are only capable of
imitating local and global patterns that have already been observed. While these
systems are very successful in combining geometry in new and interesting ways, they
are also limited by various geometric cases, where geometric continuity is required
between the subcomponents, as demonstrated in Fig. 2.37.

2.11

Shape Deformation

Moving towards more speciﬁc procedural modeling techniques we may decide to only
manipulate existing geomtry, rather than attempting to design geometry from scratch.
Shape deformation is the continyous manipulation of an existing geoemtry. Typically
these models create a range of designs as they deform a shape, and so are a more
general procedural tool than geometry construction techniques.
Recent work has begun to explore the overlap between combinatory and shape deformation techniques. Bokeloh et al. continued their work[30] on identifying symettery to
exploit these symmeteries to deform models, typically architectural, that contain repeating elements. These repeats are often reminiscent of combinatory modeling techniques. For example [31] resizes a repeating 1D sequence by repeating symmetrical
elements, either chosen randomly, or by a user. An alternative interface is given in [32]
which introduces sliding dockers as user positionable handles to deform meshes with
repeating elements. An underlying elastic deformation is combined with constraints

2.11. Shape Deformation

45

Figure 2.38: An example of the ‘morphing system of Beier and Neely[24]. Left: Two
images (black) and their control points (pink, blue). Right: The result of a 50% warp
between the two.
to preserve observed symmetries, such as straight lines or 1D repeating patterns. The
most recent system in Bekeloh’s series of papers [33] uses a linear system to maintain
basic relationships, after factoring out 1D or 2D repeating elements.
The ﬁrst 2D image warping method was created by D. Smythe for the movie Willow [213] in 1988; used to smoothly deform a goat into an ostritch, and ﬁnally a tortoise. The user speciﬁes a the location of key points between the images by positioning
a grid, and the system would create an image at a certain interval between the examples, allowing the features to ﬂow to diﬀerent locations smoothly. To achieve this
eﬀect the grid was smootly interpolated between the two states, and the content of
the meshes blended. A similar technique was presented in 1992[24], that used discrete
handles instead of a grid, that weighs each pixel’s location relative to each handle. An
example is given in Fig. 2.38. A recent system by Igarashi et al. has a diﬀerent goal; to
allow an image to be deformed as ridgidly as possible[107]. This is applied to examples
to allow the interactive animation of images. A pair of linear solvers allow a mesh to
retain a physical ridgidity, while being retargetted to a new shape. An alternative image deformation technique is image resizing. seam carving is a 2D technique to resize
images, whilst retaining the most important features[22]. By discarding low-energy
seams from an image, the most intersting features of an image can be retained, at the
cost of global distortions.
One of the earliest system to deform 3D objects was created by Sederberg[203]. This
scheme, analogous to the 2D system of Smithe, utilises 3D lattice is positioned over
the object to be deformed. By moving the points of this lattice, the geoemtry within
can be smootly reshaped without introducing discontinuities. This technique is said
to be global, in that the entire mesh is deformed when a lattice point is manipulated.
Another global technique[34] allows the user to position handles on the 3D mesh. After
moving these to a new location the system deforms the mesh such that it again touches
the handles.
One issue with global deformations is that it is diﬃcult for two physically local sections

2.11. Shape Deformation

46

of geometry to have diﬀerent deformations without interference. For example, when
deforming the middle ﬁnger of a hand, it is likely that the index ﬁnger will also be
repositioned. A response to this was a local deformation — skeleton based deformation
techniques, in which portions of a 3D mesh are deformed in response to only a subset of skeleton. Diﬀerent portions of the mesh are associated with diﬀerent portions
of the skeleton, allowing for nearby verticies to be manipulated by entirely diﬀerent
deformations. There are many diﬀerent methods for deﬁning a skeleton, including:
• In early work[131] the bones that comprise the skeleton are coordinate frames
deﬁned by the user.
• Later systems[27, 271] use the medial axis of the mesh to deﬁne a skeleton as a
“shrunk” version of the mesh that can be animated and reconstrctured.
• Lastly we may analyse a mesh to descover mechanical joints, and the joint limits
that may be present[267], to assoicate the correct portions of the skeleton with
the mesh.
One issue that is common to most deformation techniques, but skeleton based deformation in particular, is the undesirable self-intersection of the mesh under aggressive
editing. Various approaches have been suggested to address this issue, including changing the weights near a sharp bend in the skeleton[131], or deforming the mesh based
on self-proximity[271].
Both the local and global techniques examined so far have been unable to identify
and preserve the symmeteries and patterns present in man-made objects. To this
end, there have been several recent eﬀorts to create tools speciﬁcaly targetted to the
deformation of man-made objects. For example Cabral et al.[36] resize meshes using
contraints that specify that the angles must remain constant, and the edge lengths
must remain as similar to the original as possible. These linear systems can then be
solved at interactive rates to allow urban geometry to be resized by a number of userplaced handles. iWires[76] instead analyse the geometry of the given object, to extract
a number of wire-like handles that can be used to deform the object. The analysis
reveals the symmeteries between the wires visible in the shape, and these may then be
retained under user edits. Given a model that has a number of constraints given, such as
orthogonality or planarity, Habbecke et al[90] present a method for deformation when
the user drags an arbitrary vertex. A combination of a linear model and compressed
sensing are used to ensure as few verticies as possible are moved.
Some mesh representations, such as planar quad (PQ) meshes, have underlying constraints on the location of verticies. PQ meshes require that all the faces of a mesh are

2.12. Geometry Construction

47

planar quads; and are useful when, for example, we wish to build curved glass roofs
from a patchwork of planar tiles. Yang et al[268] introduce a framework for deforming
such meshes by exploring a high dimensional space. This space is bounded by the
given constraints, and may be explored via 2D maps. The resulting mesh is found by
projecting back to 3D.
As a form of deformation parametric modeling is an often-overlooked subject in both
general academia and computer graphics[101]. Computer aided design (CAD) systems
are used to design 3D geometry in many industries. Typically these operate on similar
principles to geometrical modeling, but with the end goal of producing domain specic
results, such as AutoCAD[19] for standard-compliant archiect’s plans, ArcGIS[18] for
maps, or Mastercam[214] for computer numerical controlled (CNC ) fabrication machines. Paremetric modeling is an extension to CAD to consider the design of elements
where parameters may vary, producing a range of objects, as in procedural modeling.
This oﬀers a way for a draftsman to encode domain knowledge into a model[15]; as they
work the designer speciﬁes which measurements are parametric, and the contstraints
that are necessecary for each measurement. As with PGM, there is no standard format
for parametric components[129].
An example of a deformation technique that is typically used to create a single instance of a 3d mesh is digital sculpting. Commercial projects such as zBrush[183] and
Mudbox[21] provide the best example of this technique - users are able to manipulate
a 2.5D or 3D mesh by drawing strokes on the surface to mark the location of deformations. Typically users can push and pull the surface, real-world clay. These tools
are use widely by 3D mesh artists to create high detail models and have been used for
purposes as broad as reconstructing extinct animals from their fossils[217].

2.12

Geometry Construction

Towards the most speciﬁc end of our procedural specturm the systems we examine
do not create true procedural models, but only create a single geometric instance,
such as a 3D mesh. Typically every new geoemtric instance will require signiﬁcant
human interaction. We begin our overview of this expanisve subject by looking at
some examples of domain speciﬁc geometry modeling tools, then sample some geometry
caputre methods, and ﬁnally examine 3d mesh construction techniques.
An overwhelming variety of domain speciﬁc geometric modeling tools are avaiable.
Chen et al. exploit tensor ﬁeld editing systems to design street networks in an urban
environment[39], exploiting the literature on the subject to build a novel urban geometry design tool. The “Arches”[181] framework presents a novel representation of

2.12. Geometry Construction

48

terrains, and sculpting and editing tools to manipulate the mass of of rocks, or introduce features such as cracks. Another domain that has been approached is to allow
the easy modeling of ﬂexible objects[252], by reducing the degrees of freedom that such
objects have in an intelligent manner.
Freeform architectural surfaces are characterised by large smooth curved areas, that are
not regular geometric structures. The work in graphics on these surfaces is largely connected to modeling these surfaces as 3D meshes, with each face, having certain physical
properties. The faces are often constructed of planar glass sheets, often quadrilateral.
These surfaces are well represented by PQ meshes, but many mesh editing techniques
do not guarantee these properties. One approach by Pottman et al. is to optimize
a given thin PQ mesh such that each quad is within some planar tolerence[142], another is to allow the user to explore the space of such meshes[268]. The generation
of thick, oﬀset, surfaces to PQ meshes is studied in later work[186]. Instead of PQ
meshes, we may wish to construct our freeform surfaces from bendable strips of ﬂexible material[188], or use such strips to create gedesic patterns[187]. These technqiues
use elements of simulation to create one-time models, with a typical example being the
simulation of a cost function for the physical manufacture of the mesh faces[63]. The
authors present a cost function based on the reuse of face shapes and deviation from
the speciﬁed design.
A quantity of work aims to reconstruct 3D objects from 2D plans[269]. We may, for
example attempt to interpret 2D vector plans, typically created by CAD software, into
plausible 3D objects. Lewis et al.[132] introduce technqiues to re-structure plans in such
a way as to make the data suitable for extrusion. However if we only possess a bitmap
image of the plan, without any of the meta data associated with vector plans, a range
of machine vision technqiues must be used to identify the diﬀerent features[57]. These
techniques have also been used for rapid video-game enviroment construction[72].
Academic projects also explore sketch based deformation techniques, such as Keraut et
al.[118] who utilise shape from shading techniques to allow users to construct 3D meshes
from their 2D drawings of an object lit from several angles. More recent work allows
users to deform 3D meshes by sketching the position of highlights or silhouettes[80]. An
alternative to sketch based deformation, is the photo based approach of Xu et al.[265],
who use a photo to deform a 3D mesh to replicate the form of a certain 2D image in
3D. This is achieved by decomposing the symmetery of the mesh and re-aligning it to
the silhouette given in the photograph.
Utilising 2D images to aid in 3D geometry synthesis forms an extensive subﬁeld of
geometry capture from sources such as single photographs, sets of photographs, LiDAR
and GPS data. In Sec. 2.9 we explored several systems that exploit a procedural

2.12. Geometry Construction

49

model as a reconstruction tool; there is considerable overlap between such systems and
the geometry reconstruction techniques given here that reconstruct a static 3D mesh.
A thorough treatment of this spectrum of reconstruction techniques is given in[162],
although we now give an overview.
Manual reconstruction from a single photograph is quite unconstrained and so relies on
domain speciﬁc information produce early results. Early attempts[105] required futher
human assistance and exploited assumptions about objects always touching a known
ﬂoor to infer depth. More recent attempts exploit domain speciﬁc properties, such as
the strong rectilinear nature of fa¸ades[161], or the symmetrical nature of a certain
c
class of buildings[112] to automatically reconstruct geometry.
Given several photographs we may reconstruct a 3D point cloud over the surface of a
building, using techniques such as structure from motion[53]. To construct accurate
meshes from a low number of images, together with user interaction, one approach is
to use such 3D data as a mesh modeling aid. The Fa¸ade[52] system pioneered this
c
approach, allowing several images, with edges identiﬁed by the user, to reconstruct the
geometry from basic blocks. Another approach is given by Sinha[210] et al. who allow
the user ot sketch polygonal faces that are then ﬁtted to the recovered 3D point cloud
using the RANSAC algorithm. This is then followed by automated texture extraction
from the source images. A similar vision approach is used in[173] to reconstruct a
corse 3D representation of a building site, such that the user can sketch the walls of a
building on embedded 2D planes.
To perform fully automatic reconstruction, we may make assumptions about the geometry in the scene. For example Werner et al.[258] assume an architectural scene with.
To automate reconstruction from general images, generally a larger set of iamges are
required. For example, an automated version of the Fa¸ade system uses dense polygoc
nal reconstruction from several photographs[185]; this is suﬃcient detail to reconstruct
a course mesh of a single building. Larger scale reconstructions require using hundreds
or thousands of photographs to reconstruct urban areas in ﬁne detail. Gathering sufﬁcient data for these approaches is challenging, with researchers using image-sharing
websites[5], crowdsourced callibrated capture[111] and novel games[237] to collect a
suﬃcient number of images covering the geometry to be reconstructed.
An alternative to optical photography is light detection and ranging(LiDAR) reconstruction. LiDAR uses laser rangeﬁnding to plot a depth-map of some geometry. Common examples include street level LiDAR for fa¸ade reconstruction[193], and aerial
c
LiDAR for urban[274] or forest environments[156].
The industry default 3D mesh creation technique are mesh construction tools, these
have become ubiquitous, with commonly used commercial packages such as Maya[20],

2.12. Geometry Construction

50

a

b
d

g

e

h

i

c

f

j
k

Figure 2.39: A slightly contrived mesh construction workﬂow to create a house (centre). The walls, windows, door and roof are created using lofting, constructive solid
geometry, bevelling and manual modeling tools respectively.
Blender[73] and Sketchup[235]. In the most part this chapter has been discussing more
general alternatives to these techniques, however this tool chain is used to create the
majority of 3D geometry in use.
A typical workﬂow to create a 3D mesh of a house in a is show in Fig 2.39. To create
the roof (Fig 2.39, ab), a user may manually add verticies (red points), and select
groups of verticies to form faces. Rotational, translational and scaling tools allow
these elements to positioned appropriately, (c). A door may be constructed using the
bevel tool. A cross section and path are deﬁned (d) using manual modeling techniques;
an application of the bevel tool then sweeps the same cross section along the proﬁle,
creating faces (ef). The loft tool is similar but takes a list of curves with the same
topology, but changing geometry (g) and creates solid faces between them (hi). The
loft tool creates the walls of the house, but to inset the windows we use constructive
solid geometry tools[233] to subtract the volume of a set of carefully positioned cuboids
(j) from the result of the loft operation (k). We note that there is no correct choice for
the tool for each element. For example manual vertex construction could have been

2.13. Digital Libraries

51

Figure 2.40: A single model by Bob1938 from the Timble 3D Warehouse[236], that
was found using the search term “victorian house”. The time to ﬁnd and download
the model was 30 seconds, a signiﬁcant improvement on many of the PGM systems
presented in this chapter.
used for the entire mesh, or the walls could have been constructed via CSG over an
approapriate set of cuboids.
However a wide variety of research is still undertaken to create meshes, here we only
have space to present small sample. For example given only a 2D sketch of a 3D
object, reconstruction is an under constrainted problem; a problem that Structured
Annotations[79] approaches by asking the user to annotate a sketch to provide more
constraints and FiberMesh[168] approaches using a sketch-and reconstruct cycle. A
novel tool is the application of texture cloning to 3D to allow interative mesh geometry
copying from one mesh to another[226]. Finally Li et al.[134]. address the issue of the
manipulation of irregular verticies in near-PQ meshes to achieve aethetic or structural
beneﬁts.

2.13

Digital Libraries

The most speciﬁc extreme of our spectrum of PGM contains libraries of objects. Given
the range of geometry creation systems available it should be not suprising that repositories such as TurboSquid[238] contain upwards of 200,000 3D meshes.
Given such a variety of geometry, some search tools are required to allow users to
locate the geometry they require. Most of the commercial webistes such as Trimble
Warehouse[236] or Turbosquid use text based search, an example result is show in
Fig. 2.40. However searching large collections of 3D meshes remains a active research
area. The seminal work in this area by Funkhouser et al[75]. indexes and retreive
meshes by sketches or example models. The rotation invariant properties of spherical
harmonics are used to construct easily indexed feature vectors. An alternative featrue
descriptor is given by [170], which uses the low frequencies of the the depth map of

2.14. Summary

52

the rendered object. The rendering stage ensures the system is robust to irregular
meshes, such as those which contain holes. A diﬀerent approach is to exploit the
continuous variablity in a set of models to allow users to explore the set of models
interactively, as in [171]. For example, users navigate from one airplane mesh to another
by indicating that they wish the wings to be futher forwards on the fuselage. Recently
fuzzy correspondences have been introduced as a technique for exploring a library of
meshes uses regions of interest that the user speciﬁes on an example model.
Because each model in the library has been manually created, they are free from many
of the artifacts that recovered geometry may contain. Futhermore they are free from
many technical concerns that come with many of the more general procedural systems,
such as termination criteria in the case of shape grammars. However, the user faces
several other issues in using this content — for example, given an existing lot in a
city ﬁnding a house of the correct style to ﬁt, depends on the contents of the library.
Generating a large cityscape may require repeating objects from the library, or mixing
meshes of diﬀerent styles and level of detail.

2.14

Summary

In general there are many axes on which we can classify the work on procedural modeling, such as quantity of human interaction, or applicability to real-time situations.
However in this chapter we have introduced one such axis — a continuum of geometric
specialisation from the general purpose to the speciﬁc tool.
We have given examples examining the range of geometry that may be generated
with each system. From general purpose programming languages, that only happen
to be used for geometry creation, through complex grammar and inverse procedural
techniques, to simply ﬁnding the closest possible item of geometry in a library. Unfortunately it is hard to make a quantitive argument about the trade oﬀ between power
and ease of use over this spectrum. This is due to the diﬃculty in capturing ease of
use information given the wide range of users’ ability (both programming and artistic),
and in quantifying the range of results that a system can create. We may imagine some
future work in which users create a model with each system in the spectrum, and we
then evaluate the time it took the user, the fedelity, and the range of geometry the
created model creates.
Complicating matters we have observed an increasing number of cross over systems in
recent years — combining separate parts of this spectrum to increase the utility of the
system. For example,

2.14. Summary

53

• grammars are used in urban reconstruction via inverse modeling to more tightly
ﬁt geometry.
• the 3D meshes created by tools can be positioned to form a facade using a shape
grammar, that itself is implemented in a general purpose programming language.
• simulation is used to evaluate the results of L-systems to create models of trees.
Given the broad range of geometry synthesis systems available today, users would be
well advised to ﬁnd the most speciﬁc technique that has the required ﬂexibility. For
example a video game artist may wish to “synthesise a large set of alien towerblocks”
with a shape grammar, a town planner may wish to “visualise this area of a city after a
10% increase in public transport usage” using simulation techniques, or residents may
only care to “visualise the new statue outside the town hall” using mesh construction
tools.

54

Chapter 3
Various Skeletons

This section contains both literature survey and novel components. As introduced
in Interactive Architectural Modeling with Procedural Extrusions [116] I contribute
both the general intersection event and the mixed weighted straight skeleton. My
further contribution is the analysis of the weighted skeleton degeneracies, as published online, and the description of the pincushion problem.

The straight skeleton is a geometric subdivision of a 2D shape, based on the notion
of “shrinking” the shape. In the following we will introduce the skeleton, its properties, degenerate cases, computational complexity, and how to construct it. We extend
the standard deﬁnition of straight skeleton in several steps, introducing a a hierarchy
of several skeletons, each of which is a generalisation of the previous skeleton. These
generalisations introduces additional degeneracies which we catalogue and suggest techniques to resolve. The two subsequent chapters of this thesis exploit various properties
of these skeletons for interactive PGM.

3.1

Ways of Shrinking Polygons

There are many ways in which to shrink a polygon. Fig. 3.1 illustrates four published
techniques which translate shrinking edges in a self-parallel manner. These techniques
only vary in their treatment of reﬂex corners. Those illustrated in Fig 3.1 include:
b) The medial axis [29]. A reﬂex vertex becomes a parabola as it shrinks, maintaining
a constant distance from the original polygon. The medial axis itself is a skeleton
deﬁned as the set of all points within the polygon which are equidistant to two or
more points on the boundary of the polygon.

3.2. The Straight Skeleton

55

c) The straight skeleton (SS) [7], moves reﬂex verticies with the intersection of the
two adjacent edges. We investigate further properties of the straight skeleton in
Sec. 3.2.
d) The linear axis [228] introduces hidden edges into reﬂex corners of the skeleton to
approximate the medial axis using only straight line segments. These hidden edges
immediately grow to “blunt” such verticies, reducing their “speed” as the polygon
shrinks.
e) A weighted variation of the straight skeleton (WSS ) was introduced by similarly
timed later papers by both Eppstein and Erickson [65], as well as Aicholzer and
Aurenhammer [8]. Both papers only give a passing mention to WSS and degenerate
cases are not been introduced. The edges of the WSS are assigned independent
speeds for shrinking, which shall be examined further in Sec. 3.3.

a

b

d

c

e

Figure 3.1: Techniques to shrink a polygon (a). These include the medial axis (b),
straight skeleton (c), linear axis (d) and weighted straight skeleton (e). The result of
using each technique to shrink the polygon by a small distance is shown (the light green
areas are lost to the shrinking process).
Our interest here is in the straight skeletons (SS and WSS), as these structures do not
introduce curved or additional edges, and, as demonstrated in Chapters 4 and 5, are
well suited to modeling certain classes of man-made objects.

3.2. The Straight Skeleton

56

Figure 3.2: Composite grey cubit crystals of galena with purple cubic crystals of
ﬂuorite. Cave-in-rock, Hardin Co., Illinois, USA.

3.2

The Straight Skeleton

Let us consider the growth of a crystal, as in Fig. 3.2. As Aichholzer observed in [8], if
we were to watch such a crystal growing we would see that each face grows outwards
in a self-parallel manner, and the edge between two such faces moves outwards as the
intersection of these faces. Thijssen et al.[231] earlier explored the statistical properties
of such growth in crystals, introducing a 2D proxy for the original 3D geometry, Fig. 3.3.
This model of self-parallel growth is the reverse of the process that is performed to
calculate the straight skeleton, which is calculated by the shrinking of a polygon.
The straight skeleton (SS) is a 2d graph of arcs generated from this shrinking of a

Figure 3.3: Given a set of square seeds (grey) on a line, the polycrystalline growth
moves outwards (green), and the movement of the corners traces out lines (blue).

3.2. The Straight Skeleton

57

Figure 3.4: Left: A shrinking polygon. Right: The arcs of the straight skeleton (blue)
are formed by tracing the edges of the shrinking polygon.
polygon. Each of the edges of the polygon moves towards the interior at a constant
speed in a self-parallel manner. Occasionally the topology of the polygon changes as
we observe events such as an edge shrinking to zero length. As shown in Fig. 3.4, the
movement of the corners of the decaying polygon trace out the “skeleton” itself. These
arcs describe the path of the verticies as the polygon shrinks. Several examples are
shown in Fig. 3.5.

3.2.1

Constructing the Straight Skeleton

The SS is a graph of straight edges in R2 . However we can interpret it as a terrain – a
set of faces in R3 which form a “landscape” [7], Fig. 3.6 right. This approach is taken
as it allows a comparison between the standard, unweighted straight skeleton, and
the various types of weighted straight skeletons (WSS), a generalisation introduced in
Sec. 3.3. The terrain constructed touches the polygon on each edge, and the projection
of the edges of the terrain onto the polygon forms the 2D straight skeleton.
The shrinking process is modeled as a sweep plane that rises with constant speed
from the input polygon, carrying with it the evolving polygon. Each edge of the
polygon moves inwards with a constant speed relative to the sweep plane motion. The
sweep plane rises and the polygon shrinks, encountering various topological events.
Eventually the polygon shrinks to nothing and the skeleton is complete. The terrain
approach allows the events to be modelled as the intersection of three planes, rather
than three 2D edges, allowing the geometry of Chapter 5 to be constructed trivially.
To distinguish between the under constrained term “polygon” and a similar structure
with additional constraints, we introduce a plan, Fig. 3.6. A plan is a planar partition
(a straight line planar embedding of a planar graph) that divides the plane into ﬁnite
inside and inﬁnite outside regions. A plan is a set of polygons consisting of corners
and edges, these are embedded in a plane parallel to the xy (“ground”) plane, so that

3.2. The Straight Skeleton

58

Figure 3.5: A variety of polygons (green) and their straight skeletons (blue).
all corners of a plan have the same z (height) value. The jth polygon is described
by nj polygon corners cj ∈ R3 with 1 ≤ i ≤ nj . Each corner cj is connected to the
i
i
j
next corner (according to the polygon orientation) by an edge ei . The loops of edges
are oriented counter-clockwise, but polygons describing holes are oriented clockwise.
Additional bounded regions may be recursively located inside a hole. When discussing
plans, indices are treated cyclically, so that in a polygon with corners cj , cj , and cj ,
1
2
3
the vertex cj means cj .
4
1
Unlike the medial axis, there is no trivial description as to whether a particular point
input-edge
corner

face
arc
input plan

active plan

straight skeleton

roof model

Figure 3.6: Straight skeleton terminology. The input plan deﬁnes the starting state of
the construction, while the active plan deﬁnes the state part way through the shrinking
process. The ﬁnal straight skeleton is a 2D graph consisting of arcs adjacent to faces.
The roof model is an alternative 3D representation, the projection of which onto the
ground plane forms the 2D straight skeleton.

3.2. The Straight Skeleton

59

lies on the SS of a polygon. Instead, the skeleton is deﬁned in the literature as the
result of the process of shrinking a polygon. That is — the only description of the SS
we have, is the algorithm for its construction.
To construct the skeleton a sweep plane that rises vertically from the input plan. This
sweep plane carries with it an active plan that deﬁnes cross sections of the terrain.
This 3D approach was ﬁrst suggested by Eppstein et al. [65], although in spirit similar
to the original 2D proposal by Aichholzer[7], with data structures inspired by Felkel
and Obdrˇalek[67]. However we use our own notation for continuity. The output of the
z´
system is a series of skeleton faces that make up the 3D terrain. The edges between
the faces are named arcs after Aichholzer et al.[7], a term that we shall use in both 2D
and 3D interpretations of the skeleton.
As the SS is constructed, the sweep plane rises with constant speed, and the active
plan shrinks. In the case of the basic straight skeleton every plan edge moves with a
constant and uniform speed towards the interior of the polygon. As both the speed
of the sweep plane and plane edges are constant, each plan edge remains within the
same 3D plane. One of these direction planes is associated with, and intersects, every
edge in the input plan. As both the speed with which the sweep plane rises and the
movement of the edges is equal, the direction plane associated with each edge ej forms
i
an angle π/4 with the input plane. Each skeleton face lies in one of these direction
planes. To obtain a steeper or shallower roof from the SS we may scale the faces in the
Z direction appropriately. At all times in this process we must ensure that the active
plan remains well formed. That is:
• The enclosed region remains to the left of every directed edge.
• No edge intersects another edge, with the exception of touching the neighbouring
edges only at shared corners.
• Every enclosed region has a positive, ﬁnite and non-zero area.
• There must be a ﬁnite number (zero or more) of such enclosed regions.
In the SS every active plan edge has the same constant, positive, speed. As the edges
move, the corners remain deﬁned by the intersection of the adjacent direction planes
and the current sweep plane, as in the plans of Fig. 3.7. Therefore each corner in the
active plan, cj , moves between events with a constant, and often unique, speed and
i
slope relative to the input plan.
Fig. 3.8 shows that as sweep plane rises and the active plan shrinks, the plan may
become badly formed (red). To ensure that the active plan remains well formed, we

3.2. The Straight Skeleton

x

x

60

x

x
x

x

Figure 3.7: As the active plan shrinks, the edges move with a constant speed. Several
plans (left, middle, right) are shown (green), along with their shape at a later time
(grey lines). In a certain time, every edge moves the same distance (x), but movement
of the corners is deﬁned as the intersection of the corners and so the distance moved
typically varies. Very sharp reﬂex or acute angles between edges may cause corners
to move with high speed (right). This speed approaches inﬁnite as the interior angle
approaches 2π from below, or 0 from above.

b
a

Figure 3.8: Left: the anti-clockwise oriented input plan. Middle: The active plan
at a split event (orange). Right: Without a split event, a portion of the active plan
becomes badly formed. There are self-intersections at a and b, and the red region is
deﬁned by a clockwise loop; that is, the edges deﬁne an inﬁnite inside region outside
the red area.
detect when more than two or more edges intersect and we make topological changes
to the active plan. We call these events; as introduced by Aicholzer et al. [7] there are
two types of event:
• Edge events occur as the length of an edge shrinks to zero. When a plan edge
shrinks to zero the direction planes deﬁned by three consecutive (linked by corners) edges collide (Fig. 3.9, 2).
• Split events take place when two adjacent direction planes, and one non adjacent
direction plane collide (Fig. 3.9, 3). These split the region bounded by the active
plan into two parts.
.

3.2. The Straight Skeleton

61

f
a

1.

c

e

d

(def)

b
2.
(acd)

(acd)
(def)

(adf)

3.
(abc)

Figure 3.9: Left: the straight skeleton is given by arcs (blue lines) tracing the verticies
of a shrinking polygon (black lines). Each edge moves with a constant speed towards
the interior of the polygon, and as it does the topology of the polygon changes in several
diﬀerent ways (dark green lines), during events. Right 1-3: The calculation of the SS
is primarily a sequence of such events.

before
b

c

during

after

a

d

a

b

c, d

Figure 3.10: Edge (a) and split (b) events that occur as a polygon shrinks. Peaks
(c & d) comprise three co-sited edge events.

3.2. The Straight Skeleton

62

Figure 3.11: The active plan in two conﬁgurations in which intersection of unbounded
direction planes planes (intersection with active plan shown as red, cyan and orange
lines) does not lead to an event as they occur outside the bounds of the associated edges.
We can describe these events in terms of the local plan around the direction plane
intersection point, Fig. 3.10. Here we see the local active plan region before, during
and after edge events (a), split events (b) as well as peaks (c & d). As these peaks
may be considered to be three edge events occurring together, we classify them as edge
events.
Each of these events is witnessed by the intersection of three direction planes. However
not all intersections between three unbounded direction planes indicate an event. As
identiﬁed in Fig. 3.11, we must be sure that the faces intersect within the bounds of
the associated edges on the active plan. Also of interest to optimisation is that at least
one pair of adjacent plan-edges must be involved; an SS event consists of three edges,
at least two of which must be adjacent.
Every event creates one or more output arcs, a portion of the boundary of a terrain
face. Every arc is the boundary between two faces.
We present a crude algorithm in Fig. 3.14 that maintains this queue as new corners are
introduced by events. We defer describing the event handling in detail until Sec. 3.2.4,
noting that Felkel [67] simply gives a terse set of manipulations to the data structure
in the case of edge or split events.
The active plan is stored in a data structure that holds the corners of each polygon in
a doubly linked list, as illustrated in Fig. 3.12. There is such a list for every polygon
and associated holes. Each corner, therefore, has a pointer its next and previous
corners (assuming counterclockwise order), as well as a pointer to its previous and next
direction planes. The corner is a point in R3 at the lowest intersection of the adjacent
plan edges. We may ﬁnd the position of a corner in the active plan by intersecting the
corner’s next and previous direction planes with the sweep plane. Correspondingly,
an edge on the active plan is given by the positions of two consecutive corners in the

3.2. The Straight Skeleton

63

Figure 3.12: Left: The initial set of corners (yellow circles) and points in the doubly
linked list (yellow arrows) that make up the input plan. Not shown are the pointers
to the adjacent direction planes. Centre: As the sweep plane rises, and various events
occur the active plan may split. Corners are added and removed from the linked lists.
Here two linked lists store an active plan with two polygons (yellow, purple lists). Right:
By projecting the intersection of the corner’s direction planes onto the sweep plan, we
store the implicit active plan (purple, yellow polygons)

Figure 3.13: Left: After all events have been processed, every arc is associated with
two input plan edges. Middle: A single input plan edge has a set of edges, which may
be traversed (right) in a counter clockwise direction to construct a face (right, orange).
linked list. In this manner the linked list implicitly stores the active plan at the sweep
plane, via corners at or below the plane.
To simulate the rising sweep plane approaching events, a priority queue ordered by
height (z) is kept, specifying triplets of edges colliding at a certain height. We assume
that the queue only holds one event for each unique set of colliding direction planes.
Before an event is processed, the algorithm checks that it is at or above the sweep plane,
and within the current bounds of each face — previous edge events may even have
removed the edges and their direction planes entirely. The details of the HandleEvent
routine of Fig. 3.14 are introduced in the following section, which may add arcs to
faces, and add or remove corners and edges from the active plan. Arcs are stored in
a list associated with each input-edge; events add arcs to these lists. The algorithm
continues until all events in the queue have been processed. After all events have been
processed we traverse an input-edge’s arcs in a counter clockwise direction to determine
the 3D face. This process is illustrated in Fig 3.13.
Given a “random” or irregular input plan these two (split and edge) event types are

3.2. The Straight Skeleton

64

Main begin
Q = new priority queue;
sweepZ = 0;
foreach corner c in active plan do
CreateGIEEvents ( c, Q );
while !Q.empty() do
event = FindNextEvent(Q);
event.removePlanesNotInActiveplan();
event.removePlanesOutOfBounds();
if event.getPlanes().size() ≥ 3) and
event.z ≥ sweepZ then
newCorners = HandleEvent( event );
sweepZ = event.z;
foreach corner c in newCorners do
CreateEvents(c, Q);
foreach edge e in input plan do
ReconstructFace (e);
end
CreateGIEEvents( corner c, queue Q ) begin
p1 = c.nextEdge.getPlane();
p2 = c.prevEdge.getPlane();
foreach direction-plane p3 in the input do
location = Intersect (p1, p2, p3);
Q.insert (new Event(location, p1, p2, p3));
end

Figure 3.14: Pseudo-code for the SS algorithm
the only features we are likely to see, Fig. 3.15. This is because the skeleton of irregular
polygons rarely have events where more than 3 faces meet at one point.

3.2. The Straight Skeleton

65

Figure 3.15: The straight skeleton of a complex plan in which only three faces meet
at every node in the graph.

3.2. The Straight Skeleton

3.2.2

66

Computational Complexity of the Straight Skeleton

The algorithm presented in the previous section, Fig. 3.14, runs in a time complexity of
O(n2 log n), where the number of input plan corners is n. This is due to the observation
that there are a maximum of n events that must each search for new adjacent planes
to intersect (O(n2 )), and insert any new events into the priority queue (log n). Filling
the priority queue initially also takes O(n2 log n) time.
Originally Aichholzer et al. presented a similar analysis in 2D[7], and a variation with
a similar result in[6]. These papers also prove the above lemma stating the number
of events is O(n). It is also given that calculating the SS of a convex polygon is
possible in O(n log n) time since an edge on the active plan will only intersect with its
neighbours. The higher complexity in the concave case is caused by the propagation of
reﬂex verticies, and the requirement to identify which other edge they intersect with.
The following year Aichholzer and Aurenhammer[8] introduced an elegant triangulation based method. The key observation is that every event is witnessed by a shrinking
triangle reaching zero area and collapsing, Fig 3.16. By keeping a list of triangles,
ordered by their collapse time, the propagation of the oﬀset (wavefront) is simulated.
This would give a linear time complexity, except that the collapse of certain triangles does not signify an event. Due to an inability to place a non-trivial bound on
these ﬂip events, the algorithm has a total time complexity of O(n3 log n). Recent
research has lead to strong evidence that such an algorithm delivers O(n) performance
in practice[174].
Eppstein and Erickson[65] introduced the sweep-plane component used in the previous
algorithm to construct a 3D terrain. This was augmented by a powerful closest-pairs
data structure and advanced ray-casting techniques to give a sub-quadratic time complexity of O(n1+ + n8/11+ r9/11+ ), where r is the number of reﬂex verticies, and is
a arbitrarily small constant controlling time/space trade oﬀ. Given that r is of order
O(n), and as approaches 0, a time complexity of O(n17/11 ) is achieved.

Figure 3.16: Aicholzer introduced[8] a triangulation based algorithm for the calculation the Straight Skeleton in 1996. As the shape shrinks, the events (above; left to
right) are each witnessed by a collapsing triangle in the triangulation (bordered by white
lines). By ordering the triangles by their collapse time, it is possible to identify a correct
sequence of events.

3.2. The Straight Skeleton

67

Figure 3.17: Eppstein’s motorcycle[65] graph divides the polygon (left) into concave
regions, considering only the reﬂex verticies (orange points) and their propagation (orange line) with time. These propagation lines may not be crossed by another vertex, if
they do the vertex terminates (red points). The time complexity of constructing such a
graph is introduced as O(n3/2 ). The resulting tessellation of the polygon may then be
used as an acceleration structure when constructing the straight skeleton.
Eppstein and Erickson also introduced a model of the problematic reﬂex verticies that of calculating the motorcycle graph. A brief introduction is given in Fig. 3.17.
Chen and Vigneron[40] continued this work to produce an algorithm that isolates parts
of the skeleton based on the motorcycle graph. Chen’s algorithm to calculate the
√
motorcycle graph in a time of O(r r log r) leads to a randomised algorithm to calculate
√
the skeleton with a lower bound of O(n log2 n + r r log r).
Recently Huber et al. introduced a robust, implementation-oriented approach with
time complexity O(n2 log n), which exhibited O(n log n) in practice. The algorithm
introduces additional Steiner verticies to account for the eﬀects of reﬂex verticies.

3.2.3

Straight Skeleton Degenerate Events

Thus the algorithm presented in Sec. 3.2.1, in line with the literature, is applicable to
general input plans, however in contrived degenerate situations, we may see complex
arrangements of active-plan edges intersecting at a point. The previous work leaves
these events badly deﬁned; here we detail several observed situations: loops of two,
many edges colliding and parallel consecutive edges. In contrast, the following Sec.
3.2.4 will introduce a general intersection event which calculates a well-formed active
plan after all events – edge and split events, as well as the degenerate cases introduced
here.
The literature is limited in its discussion of events. The original work by Aichholzer[7]
describes split and edge events, but does not describe an algorithm to compute them.
Eppstein[65] presents the many edges colliding degeneracy, under the classiﬁcation
vertex events, but does not detail an algorithm to resolve them. Only the work by

3.2. The Straight Skeleton

68
before

during

after

a

a

b
b

c, d
e

d

*
*

c

e

*
*

**
Figure 3.18: In degenerate situations, more than three edges will collapse at one
time (a,b & e). We also note that sometimes the active plan collapses to a loop of two
(c,d & e). We show these coincident edges as curved lines, with asterisks.
Felkel[67] explicitly addresses the topology manipulation at events, but then does not
discuss degenerate events, beyond a special check for loops of two. As we introduce
generalisations of the straight skeleton these degenerate events, and the algorithms
used to resolve them, become more important.
Fig 3.18, c,d and e, shows one degenerate case in which the active plan becomes a region
with only two edges and zero area, a loop of two degeneracy. A more involved example
is shown in 3.19. After all the events at a certain height, parallel edges may cause the
active plan to become partially or entirely composed of these zero-area regions. Felkel
at al.[68] require a special case to identify and remove these degeneracies.
Another type of degeneracy occurs as four or more plan edges collide at a point, the
many edge degeneracy. Several connected edges may intersect at the same time, as
illustrated in Fig 3.18 a, in which only the ﬁrst and last edges exist after the event, as
the intermediate edges shrink to zero length. Alternatively we may see reﬂex verticies
in the input plan form several connected sets of edges involved in a single event, as in
Fig 3.18, b. These types of events are ignored in some of the earlier work[7], introduced

3.2. The Straight Skeleton

69

Figure 3.19: A more complex example of a straight skeleton, left, that creates a zero
area plan, right. Note that the curved line segments are in reality straight, but again
drawn as curved segments to represent the topology.
as a third type of vertex event in[65], and dramatically changes the expected time
complexity of the algorithm in[40].
A ﬁnal degenerate case occurs when adjacent, yet parallel, edges in the active plan
become consecutive, the parallel consecutive edge (PCE) degeneracy. Fig. 3.20 demonstrates such a case. Because we have deﬁned the movement of corners over the active plan the intersection of the adjacent direction planes, the intersection of parallel
collinear edges neighbouring a corner is a line, rather than point, causing a special case
to arise. Existing work[7] leaves the outcome undeﬁned. It appears that there are two
resolutions techniques applicable to this degeneracy:
• The separate solution shown in Fig. 3.20, left-centre. After the PCE, the faces
remain separated by an arc. This approach maintains a single face for every edge
in the input plan. However deﬁning the movement of such a vertex is problematic
as the adjacent direction planes are co-incident.
• The merge solution illustrated in Fig. 3.20, right-centre. When a PCE occurs,
the two faces are joined together. This has the advantage that no vertex is created with parallel adjacent edges. However this removes the one-to-one mapping
between the edges in the input plan and the output skeleton faces.
In the unweighted case a further resolution is to deﬁne a special case for this situation.
In this case the corner would move perpendicularly to both the neighbouring plan
edges, towards the interior of the plan. This is inelegant, and is not able to generalise
to the weighted case in Sec. 3.3.

3.2. The Straight Skeleton

70

a

Figure 3.20: Left: The PCE problem, what is the resolution to the event marked
a? Left-Centre: The separate rule. Right-Centre: the merge rule. Right: When there
are PCE in the active plan, a resolution must still be applied to determine the initial
direction and speed of the corner.

Figure 3.21: Figure from [65], demonstrating that perturbing the sequence of events
at a point (orange), rather than solving them together, may lead to wildly diﬀerent
results (left).
It is interesting to note that [7] seems to exclude such PCE in the input, however
there is no easy way to tell if parallel edges will become consecutive as the skeleton is
constructed. By symmetry we would expect to see PCEs in the input computed using
the same solution, as illustrated in Fig. 3.20, right.
The PCE resolution technique chosen in a given SS implementation will depend on the
desired properties of the resulting skeleton.
In order to process any of these degenerate events it may be suggested that we perturb
the active plan slightly. However, as in Fig. 3.21 from Eppstein and Erickson[65], there
are situations in which small perturbations cause undesirable large changes in the
resulting skeleton. In this situation two reﬂex corners form a third reﬂex corner. It is
therefore necessary for a single event to process these collisions between many direction
planes. The earlier Fig.3.5, bottom right, gives another example where successive pairs
of reﬂex corners meet, are resolved, and carry on to create additional reﬂex corners.

3.2.4

The Generalised Intersection Event

This section demonstrates that we can unify the split, edge and vertex events into
a generalised intersection event (GIE). This avoids the involved categorisation in the
literature and allows a single algorithm to compute well formed results, even when
events contain loop of two, PCE or many edge degeneracies.

3.2. The Straight Skeleton

71

Figure 3.22: Two regions of active plans corresponding to Fig. 3.18b on the left and
Fig. 3.18a on the right. We can group the active plan edges involved in an event into
chains (red, yellow and blue edges) by asking which edges are consecutive in the linked
list data structure.

a

d

b

c

e

Figure 3.23: As three chains approach an event (a, orange), we can imagine their
eventual topology by viewing the active plan if no event takes place (c). We observe
that the last edge in the previous chain and the ﬁrst edge in the following chain become
adjacent, also that every chain is split into two (e).
The GIE is consistent with the split and edge events observed on the active plan.
We begin by deﬁning chains of edges that are involved in an event, Fig. 3.22. A
chain is a list of consecutive edges that are colliding at the event. They are ordered
corresponding to the edge’s direction. These form the partial boundary to our possibly
bounded topological disc region of the active plan that is collapsing at the event.
In the case of the SS we can order the chains themselves around the event’s location,
Fig. 3.23 d. That is the chains themselves may be ordered in a cyclic list. We can
note that after an event the last edge in the preceding chain, and the ﬁrst edge in the
following chain become adjacent, Fig. 3.23 c and e.
The intuition behind the GIE is that at an event’s location, an inside area on the active
plan collapses and transitions to an outside area. As this occurs, adjacent chains that
before bounded interior regions split in two, with the two halves of adjacent chains now
bounding an exterior region. These newly created chains do not intersect each other

3.2. The Straight Skeleton

72

a

b
c

Figure 3.24: The intra chain step removes all edges in the interior of a chain, joining
the ﬁrst edge to the last. Left: The edges a,b and c intersect at the orange point. The
corner’s next and previous pointers are shown (black arrows). Right: New arcs are
added from the old corners to the intersection location (blue lines), and the pointers
are manipulated to remove the central edge, b.
as their single shared vertex is moving away from the event’s location, in a unique
direction. Our algorithm ﬁrst removes edges that shrink to zero length, and then
“cycles” the chains in such a manner to bound the interior regions.
To resolve and event using the GIE we ﬁrstly pre-process the edges involved in the
clustered intersection events into a set of chains. A chain deﬁnes a connected portion
of the active plan boundary involved in the event. A chain, hi , is a list of consecutive
1
bmax
active plan edges, i ... i
1
hmaxi . A cyclic chain list, b, contains all such chains, h ...h
(we assume a cyclic index). The chain list is ordered by the edge’s orientation around
the intersection. After this pre-processing we perform the following sequence of steps,
a pseudocode summary is given in Fig. 3.26.
• Intra chain step (Fig. 3.24): Within each chain, any edges in the middle (not
the ﬁrst or the last edge in a chain) shrink to 0-length and are removed from the
active plan. Formally, we remove all interior edges from a chain hi , leaving only
the start, i , and the end, i
1
hmaxi , of the chain. That is, if hmaxi ≥ 3, then edges
i
i
2 .. hmaxi −1 are removed from the active plan, being replaced by a new corner at
the event location, connecting the end of i to the start of i
1
hmaxi .This leaves only
chains of length one or two remaining.
• One chain step: Chains of 1 edge are split at the location of the event. All chains
are now of length 2.
• Inter chain step (Fig. 3.25): We split each each chain into two and connect the
start of the last edge in the previous chain to the end of the ﬁrst edge in the

3.2. The Straight Skeleton

b

73

a

e
c
d

Figure 3.25: An intra chain manipulation followed by an inter chain manipulation,
colouring as Fig. 3.24. Left: the active plan before the event. Middle: Additional arcs
are created during the intra chain stage. Right: The pointer manipulations swap edges
with their neighbours around the intersection point.
following chain. The chains therefore swap an edge with their neighbour; all
chains remain of length two. Formally the inter-chain stage takes place between
each adjacent pair of chains, hx and hx+1 in the cyclic chain list b. For each pair
of adjacent chains we create a new corner at the event location and connect the
start of the last edge in the proceeding chain, x x , and the end of the ﬁrst edge
hmax
in the following chain, x+1 . Finally the inter-chain stage ﬁnishes by removing
1
any unreferenced corners from the active plan.
• PCE step: We resolve any newly parallel consecutive edges according to the
merge or separate solutions.
Because more than three planes may meet at a single point, we must modify the
FindNextEvent routine of Fig. 3.14 to search Q for all co-sited events. The new event
contains all directions planes that intersect at one point. Because Q is ordered by
sweep plane height, we are able to ﬁnd such planes eﬃciently.
The single GIE event with PCE handling allows the active-plan to remain well-formed
after both collisions with more than three edges involved, and successfully handles the
loop of two situation, as in Fig. 3.27.

3.2. The Straight Skeleton

HandleEvent( EventCluster ec ) begin
RemoveAllInactiveEdgesFromCluster( ec );
chainList = BuildEdgeChains( ec );
if chainList.countEdges() < 3 then
return;
/*intra chain stage*/
foreach chain chainj in chainList do
foreach consecutivePairOfCorners ck , cl in chainj do
AddSkeletonArc(ec.location, cl );
cl .inactive = true;
PerformOneChainStep();
/*inter chain stage*/
foreach consecutive chainj , chaink in chainList do
c1 = ﬁrstCornerOfLastEdgeOf chainj ;
c2 = ﬁrstCornerOfSecondEdgeOf chaink ;
cnew = createNewCorner( ec.location );
cnew.prevDirectionPlane = c1.nextDirectionPlane;
cnew.nextDirectionPlane = c2.nextDirectionPlane;
InsertCornerBetween( cnew, c1, c2 );
PerformPCE();
return newCorners();
end

Figure 3.26: Algorithm for the generalised intersection event.

74

3.2. The Straight Skeleton

75

Figure 3.27: The results (right column) of applying the GIE to several diﬀerent types
of situation (left column). From the top: an edge event, a split event, a peak event, one
pair of collapsing non-parallel edges, a three chain situation, four pairs of collapsing
non-parallel edges and an event that includes a straight line and parallel edges. Bold
solid coloured lines show chains both before and after.

3.3. The Positively Weighted Straight Skeleton

3.3

76

The Positively Weighted Straight Skeleton

The positively weighted straight skeleton (PWSS) is a variation of the straight skeleton.
Each edge is allowed to move with an independent speed towards the interior the
bounded region as the sweep plane rises. The PWSS was introduced in [8] and [65] as
the weighted straight skeleton, however for reasons that will become clear in the next
chapter the naming convention in this document has been altered. Neither of these
publications investigate any of the new features and degeneracies that may occur with
the weighted skeleton. Later work[17] addresses only the convex cases.
The increased degrees of freedom that varying the edge speeds introduces, again leads to
a new class of degeneracies. As with the SS, there are a class of PWSS-like constructions
which are similar, except in their behaviour when certain borderline events arise. We
have already seen one example in the case of the SS, the parallel consecutive edge
degeneracy, which can be solved using either the merge or separate rules. The new
class of degeneracies that occur in the PWSS are a generalised version of these SS PCE
events.

3.3.1

Introduction

To enable independently weighted edges we must introduce another degree of freedom
j
for every edge in the input plan, ej . This is an angle, θi , which measures the angle bei
tween the vertical (perpendicular to the input plan), and the direction plane, Fig. 3.28.
As the edges may not move over the active plan with unbounded speed, we enforce the
limit 0 ≤ θ < π .
2
Because of the etymology of straight skeleton terminology we use the terms angle and
weight interchangeably to refer to the speed of propagation of an edge in the active
plan.
The construction of the PWSS is identical to the SS for nearly all events. However it
is instructive to note that the resulting skeletons may have diﬀerent properties. For
example, as shown in Fig. 3.29, the skeleton faces may contain holes. This necessitates
a new approach to constructing the faces of the terrain, in which we traverse all arcs
that have been created and assigned to an input edge. As in the SS case, we traverse the face boundary counter clockwise, starting from the input plan edge. Finally
all remaining arcs are traversed, and oriented, in a counter-clockwise manner on the
associated direction plane to form holes.
Compared to the faces of the unweighted skeleton, the faces of the PWSS have a more
complex geometry. For example, Aichholzer proved in [7] that every face of the SS

3.3. The Positively Weighted Straight Skeleton

77

j
θi

ej
i

direction plane

Figure 3.28: In the PWSS, every input edge is associated with an angle that deﬁnes
the slope of the associated face.

Figure 3.29: Top: The 3D terrains or roof models of two skeletons. Bottom: Their
corresponding 2D PWSSs. Left column: An unweighted skeleton. Right: A PWSS in
which one face (red) has a shallow angle which causes it to contain a hole.

3.3. The Positively Weighted Straight Skeleton

78

Figure 3.30: A PWSS in which a face (red area) is non-monotone with respect to
it’s associated input plan edge (red line).
is monotone with respect to the edge that lies on the input plan, however this is not
the case with the PWSS. Fig. 3.30 introduces an input plan in which reﬂex corners
and steep angled edges combine to cause a shallow edge to become non-monotone with
respect to its edge.
Although degenerate cases do not occur frequently, the additional degrees of freedom
that the PWSS has over the SS allows more input plans to become degenerate, given
particular direction plane angles. The output of all possible PWSSs are are a superset
of all possible SS; the possible PWSS events are also a superset of the SS events. As
with the SS, given a random input plan, we are likely to see only events involving three
edges. However, the degenerate cases become more intricate, and must be addressed
on a global scale. It is hard to defend the use of the PWSS when a complete algorithm
for all possible plans cannot be given, and so we continue to introduce, and suggest
resolutions to these PCE-like events.

3.3. The Positively Weighted Straight Skeleton

3.3.2

79

The PCE event revisited

The parallel consecutive edge problem of the SS can again be observed in the PWSS.
This may occur in the same manner as the SS, as in the earlier Fig. 3.20. The input plan
edges which cause the degeneracy no longer need to be colinear since a faster moving
edge may catch up a slower edge. Therefore there are a larger range of input plans that
lead to PCEs in the PWSS than the SS, as illustrated in Fig 3.31. This degenerate
case arises when two (or more) neighbouring edges in the active plan become colinear
on the sweep plane. This happens, for example, when edges previously separating the
colinear edges are eliminated, via the intra-chain step of the GIE.

a

Figure 3.31: A plan that leads to a PCE, a. The algorithm must choose between the
red (middle ﬁgure) or yellow (right ﬁgure) faces to dominate.
If the two neighbouring and colinear edges bound diﬀerent sides of a region, the output
is an arc. This arc is a roof-ridge and the computation proceeds as normal – at the
opposite end of the ridge the two edges will collide again. This is not a degenerate
event and we can distinguish the regular “roof ridge” case from a degenerate event by
making use of the fact that we use directed edges to describe a plan. However, when
the edges have the same orientation (they bound the same side of a region) we are
not able to determine the direction of the subsequent arc, Fig. 3.31. The intersection
of the adjacent direction planes is a horizontal line, parallel with the sweep plane,
which causes the direction of the new corner to be under-constrained. For example in
Fig. 3.31, left, it is unclear, at point a, whether the corner should move to the left, or
the right.
It is unhelpful to examine situations where the edges are nearly parallel for guidance. As
the angle between the edges approaches π/2 from diﬀerent directions, we get suddenly
diﬀerent results. Either one or the other edge will be predominant. This singularity
means that the limiting case is of little help when resolving the degeneracy.
To complicate matters further, more that two edges may become parallel, and consecutive, upon the sweep plane at a single height. If these events are addressed sepa-

3.3. The Positively Weighted Straight Skeleton

b

80

c

Figure 3.32: A PCE that requires global coordination to resolve. If the events at b
and c do not coordinate, we may end up with non-enclosed regions on the plan (middle).
To address this issue one edge is globally determined to dominate, right.
rately, we may create further PCE degeneracies, leaving a poorly deﬁned skeleton face,
Fig. 3.32 middle. Therefore the PCE degeneracies need to be solved consistently and
globally. This requirement for a global solution sets the PWSS apart from the SS,
which can be constructed from local events that occur at a single point.
Our strategy to resolve this degeneracy replaces the set of PCEs with one or more of
the approaching edges, which share a single angle. We take inspiration from our merge
resolution of the unweighted SS PCE to combine these skeleton faces.
Given a set of edges that form the PCE degeneracy, {ej } ∈ P CE, and their angles,
n
j
j
j
{θn }, we identify one angle, Θ = f ({θn }) | en ∈ P CE. The edges and faces associated
with Θ, are merged, and the remaining edges and faces are removed from the active
plan.
To select this angle, Θ, we propose using a priority scheme, f , derived from the angles of
the edges. This scheme selects one or more edges with the same angle. We then use the
SS merge solution (Sec. 3.2.3) to combine these faces, and remove the others. Fig. 3.32,
illustrates the case in which each angle is unique, whilst Fig. 3.33 demonstrates a
situation in which Θ is shared between two edges.
Typical priority schemes for f are:
• volume maximising (lowest θ), or
• volume minimising (highest θ).
The choice of ordering scheme, f , very much depends on the application for which the
PWSS is being used for. This PCE resolution method is the most convenient of a large
number of alternatives. We can imagine other schemes, Fig 3.33, right, but ﬁnd ours
is a simple and practical approach.

3.4. The Negatively Weighted Straight Skeleton

d

81

e

Figure 3.33: Left: A PCE degeneracy with two edges sharing an angle (red), and
a shallower edge (yellow). Middle: Using the scheme f = volume maximising, Θ
is chosen to be the angle of the red edges. Therefore the two red edges and their
faces are merged, and the yellow face is removed. Appropriate arcs are added to the
output. Right: There are many alternate consistent resolution systems apart from the
one presented here.

3.4

The Negatively Weighted Straight Skeleton

In passing we may also note that the same degeneracies and techniques are applicable
to the negatively weighted straight skeleton (NWSS), an example of which is show in
Fig. 3.34 left. This skeleton is the dual of the PWSS, representing an ever-growing
polygon. We omit further details of this structure here due to its similarity to the
PWSS. Indeed, we obtain the same 2D skeleton by taking the PWSS of weighted
polygon, and the NWSS of the same polygon with each edge’s direction reversed, a
situation illustrated in Fig.3.34, right.

3.5. The Mixed Weighted Straight Skeleton

82

Figure 3.34: Left: A negatively weighted straight skeleton (NWSS), in which every
j
edge, ej is associated with an direction plane speciﬁed by an angle θi ≤ 0. Right:
i
The skeleton constructed is identical (barring degeneracies) to a PWSS in which every
j
edge’s direction is reversed, and θi is negated.

3.5

The Mixed Weighted Straight Skeleton

The ﬁnal variation of the SS we will introduce is the mixed weighted straight skeleton
(MWSS). This new structure allows the angle of the direction planes, θ, to be positive
or negative over edges in a single plan. Thus regions of the active plan can shrink
inwards or grow outwards. Once again the increased degrees of freedom introduce new
types of degeneracy. This section introduces some of the issues surrounding these point
degeneracies, presents an algorithm for simplifying them, and introduces one theorem
as to the solution of such cases.
As in the PWSS case, θ is limited in the MWSS to avoid inﬁnitely fast edges on the
active plan, allowing only − π < θ < π . Therefore a θ < 0 implies that an active plan
2
2
edge is moving away from the interior of the polygon, a θ = 0 implies an edge that does
not move, and a θ > 0 implies an edge is moving towards to interior of the polygon.
Fig. 3.35 gives an example of both a PWSS and MWSS.
The MWSS enables a wider variety of 3D terrains to be deﬁned; the set of skeletons
deﬁnable are a superset of the SS, PWSS and NWSS schemes. For example the active
plan can grow, as well as shrink, or can be a mixture of both. Therefore certain
MWSSs may not terminate after the ﬁnal event, the enclosed area may continue growing
indeﬁnitely as the sweep plane rises. It is an open problem to determine if a given
MWSS will terminate if it contains any values of θ < 0, without executing the skeleton
algorithm itself. Fig. 3.36 gives an example in which the resolution of a borderline case
diﬀerentiates between an non-terminating skeleton, and a terminating one.
As with the PWSS, the active plan can split as the sweep plane rises. But as Fig. 3.35
shows, in the MWSS regions can also merge.

3.5. The Mixed Weighted Straight Skeleton

83

Figure 3.35: . Left: A complex event in a PWSS, over a plan (green). Right: A
MWSS in which four areas merge to become one. Note that the 3D models are the
resulting terrains of a skeleton as some MWS skeletons are diﬃcult to illustrate in 2D.

Figure 3.36: MWSS that are bounded (left) and unbounded (right). The red face
grows to an inﬁnite area as the sweep plane rises. A small perturbation to the input
plans is the only diﬀerence between the input plans, all θ value are equal. The PCE
event which occurs along the orange line determines the behaviour of the skeleton.

3.5. The Mixed Weighted Straight Skeleton

84

We note in passing that MWSS events exist in which no resolution is necessary. The
edges intersect only at the event, but not after it. We disregard these grazing events
in what follows, as they are trivial to test for and may be simply ignored.
Given the additional degrees of freedom available in the MWSS we expect to encounter
the degenerate situations observed in the SS and PWSS cases. In addition there are
are a new class of point degeneracies observable

3.5.1

Point degeneracies

Given the additional degrees of freedom available in the MWSS, it is unsurprising that
the GIE solution no longer solves all situations. Fig. 3.37 gives one simple example
event in which the GIE causes the active plan to become badly formed.
Indeed every edge of an arbitrary input plan may be coerced to collide at single point
by altering the values of θ. A more complex example of a simple event is introduced
in Fig. 3.38, which shows a possible event with many edges colliding. Here we can see
chains of edges representing bounded, as well as unbounded areas, loops, and chains
surrounding other chains, colliding at in a simple event.
If all the edges are moving inwards or outwards, as with the PWSS or NWSS, the
SS GIE introduced in Sec. 3.2.4 is still suitable. However in the complex degenerate
events that may occur with some angles of θ > 0 and some θ < 0, another algorithm
is needed. Fig. 3.40 gives one such situation and a number of plausible solutions.

Figure 3.37: A MWSS topology at (left) and after (middle, right) an event (orange)
that is not suitable for the GIE. The GIE output (middle, purple) is self-intersecting,
and thus badly formed. A non-intersecting solution does exist (right).

3.5. The Mixed Weighted Straight Skeleton

85

* *
Figure 3.38: Left: The active plan just before an event. A complex set of chains
collide at a single event (orange). Right: after the intra-chain step and one-chain step
of the GIE the topology is simpliﬁed. Note that the curved edges marked with an asterisk
represent the topology of two colinear straight edges.

a
φ

γ
b

Figure 3.39: We describe the chain a as enclosing chain b, as b lies inside a, and
therefore φ < γ, φ < π radians. The chains are shown here before a collision at the
orange point.

3.5. The Mixed Weighted Straight Skeleton

before

a

86

during

b

after

c

d

e

Figure 3.40: Above: Four chains collide at an event (orange point). The desired plan
topology after the event is unclear. We must keep the interface edges (above, right: bold
green arrows) in the same locations to remain compatible with the remainder of the plan.
Below: There are many possible options for the topology change at the event. (Note
that we show the active plan a time after the event). Some solutions use existing edges,
others create new zero length edges (below: red shadows). During the event these edges
have zero length, but subsequently grow).
Characteristics that are logical in an algorithm for such events include:
1. The plan remains well formed.
2. Consistency with the SS when all angles are a positive constant.
3. Consistency with the PWSS when all angles are positive.
4. Consistency with the NWSS when all angles are negative.
5. Invariance to rotation of the plan. As with the the straight skeleton the result of
an event should not depend on the orientation of the plan.
6. No creation of new zero length edges during the event. The SS, PWSS and NWSS
do not introduce additional edges; for consistency, neither should the MWSS.
We have been unable to ﬁnd a elegant general solution to this problem!
We hypothesise that it is always possible to ﬁnd a solution in the events we encounter.
Fig. 3.41 shows several events and potential solutions, however an algorithm to compute
these events has not been discovered. In particular it is condition 6, ﬁnding solutions
that do not introduce zero length edges, that rules out many obvious algorithms.

3.5. The Mixed Weighted Straight Skeleton

87

Figure 3.41: Several example events and solutions that do not require 0-length edges
to be introduced into the active plan. The geometry (green area) is shown after the
event, and consists of length 2 chains colliding. A good solution for each topology is
shown in purple. All examples except that in top, middle, fail when the GIE is used.
We continue by introducing one further processing step that simpliﬁes these point
degeneracies by removing parallel edges; ﬁnally we conclude by introducing a concise
description of the unsolved problem, given this simpliﬁed event.

3.5.2

Removing Parallel Adjacent Edges

As per the GIE introduced in Sec. 3.2.4 the topology of the event can be simpliﬁed by
the intra chain and one chain steps. These steps simulate the plan as the sweep plan
reaches the height of the event. Zero length edges, including chains that form a closed
loop are removed and chains of length 1 are split, leaving a homogeneous topology of
chains of length 2.
At an event all the edges involved in the collision approach the location in an ordering
deﬁned by the edge’s orientation. Fig. 3.42, left, shows the orientation-ordered points
for Fig. 3.38. Any edges that do not approach according to their angle must have
been removed by an earlier collision, Fig. 3.42, right. This property is known as the ≥
approaching edges property. This refers to the fact that the angle between consecutive
edges around an intersection is equal to, or greater than, zero.
The simpliﬁcation we would like to perform is the removal edges which are adjacent
and parallel as they approach the event. That is when two parallel edges separated by
0◦ approach an event from the same side. The area between these edges approaches
zero near the event. If we connect these adjacent edges together, the event at the other
end of the parallel lines will remove the loop in it’s intra chain stage. Therefore it

3.5. The Mixed Weighted Straight Skeleton

88

Figure 3.42: As the chains of edges in the MWSS approach the event (orange) they
become ordered (left). If this were not the case (right), they would have intersected
during an separate earlier event (red).
can be ignored for the purposes of this event. After we remove these lines, we can say
that the event has the > approaching edges property as all the angles between adjacent
approaching edges are greater than zero.
This basic approach is hampered by the fact that more than two parallel edges may
be adjacent at an event. If there are an even number of such edges at one event, the
adjacent pairs of edges can be connected together, as in Fig. 3.43. However if there
are an odd number of edges, one edge must be chosen that is not connected to another
and remains. This decision should be independent of the order co-heighted events are
processed in. Here we present two resolutions:
• interior bias: The pairs of lines surrounding an interior region of the are always
connected.
• exterior bias: The pairs of lines surrounding an exterior region of the plan are
always connected.
The earlier example in Fig. 3.38, is resolved using these two resolutions as shown in
Fig. 3.44. Note that although the edges remaining have the same orientation, they may
have diﬀerent speeds. A consequence of the necessity of choosing an interior or exterior
bias is that otherwise symmetrical plans may produce an asymmetrical outcome after
an event. For example Fig 3.45 shows a plan that before the event is not changing
area, but after will either be gaining, or losing area if the interior or exterior biases are
chosen respectively.

3.5. The Mixed Weighted Straight Skeleton

(acd)

89

d
c

e

a
(acef)

g
f
b

(abcfg)

v

w

x

y

Figure 3.43: Given a plan before the event (top left) that leads to a number of events
with parallel adjacent edges at the same height (top right, red blue and yellow circles), a
deterministic and reproducible decision must be made as to which of the parallel edges
are connected. The solutions given are to connect the parallel adjacent lines with an
interior bias (bottom left) or exterior bias (bottom right). The areas v, w, x and y are
all removed by subsequent events.

3.5. The Mixed Weighted Straight Skeleton

*

90

* *
*
*
*
*

*
*
*

* *

Figure 3.44: After the intra chain step and one chain steps, we have a simpliﬁed
topology (top, left). The chains are shown just before the event for clarity. The black
lines connect (asterisked) edges which would become adjacent and parallel at the event.
We convert these pairs of edges into single chains as shown. We either use the interior
bias (top right) or exterior bias (bottom left). After any subsequent events at the same
height are processed we are left with simpliﬁed topology (bottom right, for exterior bias).

Figure 3.45: A MWSS event that has unchanging area before the event, but will
either grow or shrink after depending on the resolution strategy.

3.5. The Mixed Weighted Straight Skeleton

3.5.3

91

The Pincushion Problem

Once an event has been prepared in the above way, we wish to process it in such a way
that the plan remains well formed after the event. This is a unsolved problem, and
this section makes only deﬁnitions and observations.
Given a valid event that has been pre-processed such that it has the > approaching
edges property, the pincushion problem is to devise an algorithm that always ﬁnds a
solution that does not introduce new zero length edges in to the active plan. First
we will show that the plan is topologically invariant after an event, and then that
we can draw a circle around all possible intersections of edges involved in the event.
This “pincushion” circle, with “pin” edges leading into it encapsulates the problem of
solving a general MWSS event.
As the sweep plane rises towards an event, after it has processed any previous events,
the topology of the edges does not change. By deﬁnition the plan is well-formed
before the event, with no self-intersections. Furthermore we can note that there are no
topological changes as the sweep plane approaches the height; such changes would be
witnessed by other events. Of more consequence is that topological invariance may also
be observed after the event. That is, if we do not handle the event, the geometry after
the event only scales, rather than changing topology. We call this the sector property
of SS events, and is introduced in Fig 3.46. The sector property is summarised in the
trivial statement “between events, no events occur”.
The sector property follows from two previous deﬁnitions:
• The edges move over the plan in a self-parallel manner, at a constant speed.
• The edges involved in an event pass through the event’s location at the event
Applying these two deﬁnitions allows us to make the trivial observation that all intersections between any pairs of edges move directly away from the intersection point after

before

during

after 1

after 2

Figure 3.46: The plan (green triangles) undergoes an event (orange). The sector
property states that topology of the edges remains unchanged after the event if we make
no attempts at solving it (after 1, 2).

3.5. The Mixed Weighted Straight Skeleton

92

Figure 3.47: A PWSS event in which the only solution requires the extension of edges
(dashed line) from their unmodiﬁed post-event topology.
the event, each with constant speed. Therefore the order of crossings of any subset of
involved edges remains invariant, along with the topology.
We may note in passing that there are three topologies of the edges involved in the
event - before, at and after. The topology at the event only occurs for a single sweepplane height, at an instant in time. We deﬁne the pincushion problem on the topology
after the event.
To ﬁnd solutions in the MWSS case it is necessary to extend some of the edges. An
example where this is required is shown in Fig. 3.47.
Given the invariant topology at some time after the event in question, there are only
a ﬁnite number of edges involved. If we intersect all the edges we obtain a ﬁnite
number of possible intersection points that may make up the solution. We discount
non-intersections between parallel edges. Therefore we may attempt to encapsulate our
problem by drawing a circle that encompasses all these possible intersection points. An
example of the resulting pincushion diagram contains is given in Fig. 3.48. From the
edge of the circle, an even number of unbounded edge-rays are ordered by angle around
the perimeter. Rays are used since we may have to extend some of the line segments.
There are an even number of rays, for each edge of the active plan that enters and
leaves the circle.
A trivial observation is that for any successful solution only odd-numbered rays may
intersect event number rays and vice versa (for any ordering around the perimeter of
the pincushion). This matches the intuition that the orientation of the edges within
the active plan determines which other edges they may intersect with. To this end we
may colour the rays in the diagram with alternating colours; rays may only connect
with other rays of the other colour, but may not cross any other rays as in Fig. 3.48
bottom row.
In a valid solution all pairs of rays in the pincushion diagram are connected to form
chains of length 2, in such a way that the chains do not cross. We hypothesise that
it is always possible to solve the pincushion problem. Given a such a solution we can
update the active plan in all situations.

3.5. The Mixed Weighted Straight Skeleton

f2 m1
m2
f3

93

f1
m6
f6
m5
f5

m3
f4

m4

Figure 3.48: Top Left: It is possible to draw a circle around all possible edges that intersect at an event. Top Middle, Right: Given the sector property, we may summarise
the topology as rays entering the pincushion circle. Bottom Left: We may assign alternating colours to rays around the circle. Bottom Middle: A pincushion diagram
coloured in this way. Bottom Right: A solution to this pincushion consisting of the
intersections {(m2 , f1 ), (m1 , f2 ), (f3 , m4 ), (m3 , f4 ), (m6 , f5 )(m5 , f6 )}
The solution is not unique, as in Fig. 3.49. Given a number of solutions we may chose
to use the criteria of Sec. 3.5 to determine which solution is most suitable for our
application.
A brute force search has been implemented to ﬁnd which edge pairs to intersect.
Fig. 3.50 details an algorithm that applies the intra-chain stage of the GIE to all
allowable subsets of edges in the event. This algorithm, together with a visual interface, as in Fig. 3.51, never failed to ﬁnd a solution to a valid pincushion arrangement.
However, without a proof that there is always a solution to the pincushion problem,
we can not be certain that the brute force approach will return a valid active plan.
Another approach is a constructive methodology to incrementally add the next pair of
rays to an already valid solution, given some arbitrary order of rays. Since we theorise
that all such arrangements have a valid solution, such a solution should be possible.
However a counter example was found in the “5-star” structure of Fig. 3.52. In this
case, attempting to incrementally add rays around the circumference, always keeping
a valid solution with those lines already processed, either is not possible, or does not
terminate. In this case it is necessary to solve the system globally. In this case the GIE
provides such a solution. We therefore believe that a global solution must be found,
rather than an iteratively constructed one.
The failures of the GIE, brute force, and incremental approaches to the pincushion

3.5. The Mixed Weighted Straight Skeleton

94

Figure 3.49: Given the post-event topology (top left), and the corresponding pincushion diagram (top right), there are three diﬀerent solutions that do not introduce zero
length lines (bottom).

3.5. The Mixed Weighted Straight Skeleton

95

BruteForceEvent ( Event event ) begin
pincusion = preprocess( event );
Set<Set<Set<Chain>>> combinations = all covering combinations of pincushion.chains();
foreach Set <Set<Chain>> GIEChains in combinations do
Set<Chain> resolvedChains = new emptySet();
foreach Set<Chain> chain in GIEChains do
resolvedChains.add( interChainStage ( chains ) );
if noChainsIntersect( resolvedChains ) then
return resolvedChains;
return null;
end

Figure 3.50: A brute force approach to the pincusion problem. We hypothesise that
it will never return null.
problem are disappointing. Ultimately the lack of proof that the events of the MWSS
have well formed solutions is problematic to the deﬁnition of the MWSS. However
we may take solace that these are very degenerate situations and solutions that do
introduce zero length edges are common.
The pincushion problem was discussed with David Eppstein, author of [65] and
Antoine Vigneron, author of [40].

3.5. The Mixed Weighted Straight Skeleton

96

a

b

c

Figure 3.51: A user interface to the pincusion event solver. Top Left: The users
selects a resolution algorithm (a), draws the edges involved in the event around the
event location (b), and selects the time relative to the event (c). Top Right: The
system simulates the topology at the event. Bottom: The system shows the solutions
given by the GIE (Left) and brute force algorithms (Right) in purple after the event.

3.6. Summary

a

97

b

c

d

f

e

g

Figure 3.52: The “5 star” event arrangement of edges, shown after the event (a),
and the corresponding pincushion diagram (b). A constructive approach, which takes
an arbitrary ordering of edges (c, grey lines) and attempts to maintain a valid solution
with each additional line (d), runs into problems when it cannot alter a past result (e).
The correct solution in this case (f,g) must be found globally, and happens to be the
same as the GIE solution.

3.6

Summary

In this chapter we have explored a certain class of skeletons, formed by allowing the
edges of a 2D shape to move in a self-parallel manner. By observing intersection events
as the edges collapse we are able to trace out the arcs of the skeletons. Indeed it is by
the simulation of the edge movements that we are able to evaluation skeletons. We may
go so far as to describe the skeleton as a “procedural geometric construct”. However
the fact that we will use such a construct for “procedural modeling” would make such
a description less than helpful.
By specifying diﬀerent constraints over the speed of these edges, distinct classes of
behaviour can be witnessed. Four varieties of the straight skeleton have been introduced
– the unweighted straight skeleton, the positively weighted skeleton, the negatively
weighted straight skeleton, and the mixed weighted straight skeleton. Three of these
skeletons form a chain of generalisation as the requirements on the angle of the direction
planes are relaxed; SS ⊆ PWSS ⊆ MWSS, or SS ⊆ NWSS ⊆ MWSS.
Each additional generalisation has brought with it new degenerate cases that we have
presented, and suggested solutions for. For the SS, PWSS and NWSS we introduce a
GIE that speciﬁes a general behaviour at degenerate events at a point. However in the
deepest, most unlikely, degenerate cases we were unable to suggest a general solution
for the MWSS, managing only to formulate the pincushion description. The subsequent
chapters report on the applications of these skeletons, and their applications to PGM.
We hope that the utility of the SS constructs provides motivation for future research

3.6. Summary
into such the problematic degenerate cases.

98

99

Chapter 4
Procedural Generation of Parcels

The work in this chapter was based on a collaborative project published in the
paper Procedural Generation of Parcels in Urban Modeling[247]. I contributed the
skeleton parcel subdivision algorithm and implementation, the statistical ﬁtting
mechanism and the comparative analyses. The sections marked † were shared with
the other authors, but are included for the sake of completeness.

This chapter introduces two methods for the procedural generation of city parcels
from city blocks. Within an interactive procedural modeling environment the two
complimentary methods reproduce parcel subdivisions in distinct styles, given a small
number of user speciﬁed parameters and no additional user programming. Recalling
the urban procedural modeling “water-ﬂow” pipeline from Fig. 2.34 in Chapter 2,
the preceding stage in the pipeline produces city blocks, and the task of the parcel
subdivision mechanism is to generate parcels that cover each of these blocks entirely.
The ﬁrst algorithm utilises the geometric self sensitivity of the straight skeleton to
generate Modernist style parcel subdivisions. The second approaches the problem using
a recursive-split approach, to create traditional parcel subdivisions. The system is able
to retain parcel identity under interactive user edits such as moving a street intersection,
and is robust enough for integration into a commercial procedural modeling tool. We
conclude the chapter by comparing the results of these subdivision techniques against
real-world examples.
One of the challenges in procedurally generating parcels is creating geometry that is
adaptive to the block shape. In particular identifying the centrelines of rows of parcels
within irregular blocks is essential to many observed block subdivisions. We found
that the straight skeleton provided a very powerful and stable centerline detection
mechanism, that was well suited to interactive modeling.

4.1. Introduction

4.1

100

Introduction

The urban procedural modeling pipeline has been widely applied to several ﬁelds including virtual environments, urban reconstruction and architecture. For example the
commercial system CityEngine[66] has been used for special eﬀects in movies such as
Cars 2 (2011) Total Recall (2012), as well as architectural purposes such as planning
the Swiss Village within Masdar city. While there have been numerous systems for
the generation of street networks[39], buildings[159] and facades[161], there has been
relatively little attention paid to the generation of parcels from city blocks. Some of
those existing systems are not responsive to the block geometry, while others may not
be easily controlled. Increasing the ﬁdelity and speed of parcel subdivision beneﬁts the
quality and speed of the entire urban modeling pipeline.
Our high-level approach was to emulate two distinct modes of block subdivision from
the urban planning literature. Carmona[37] identiﬁes two such modes:
• Modernist patterns position “buildings as separate pavilions freestanding in a
more generalised type”, examples are given in Fig. 4.1, left. This design often
appears “in its pure form when built on greenﬁeld sites”, and is generally used
in lower density neighbourhoods that are homogeneously planned. The parcels
will typically be rectangular, have street access at the front, and neighbour other
blocks at the sides.
• Traditional patterns of subdivision are characterised by a “generalised highly
connected mass” and “streets and squares and a small-scale, ﬁnely meshed street
grid”. As demonstrated in Fig. 4.1, right, this design is prevalent in historic cities
and unplanned high density areas. The parcels may or may not have street access,
with small lanes and courtyards oﬀering access to occupants. Often traditional
subdivision patterns emerge in an ad hoc manner, rather than the block being
designed, as is common with Modernist patterns.
We present algorithms to model each of these varieties, with the goal to provide a
mechanism to model the majority of subdivisions found in cities. As Carmona notes
there is something of a continuum between these two ideals – “Indeed, it is not clear
at what point space between buildings becomes open space containing buildings”. Both
designs are often observed with a uniform structure with rectangular, quadrilateral or
sometimes polygonal[45].
After discussing the several parcel subdivision schemes in the corpus in the following Sec. 4.2, we will detail the inputs and outputs to our two subdivision systems in
Sec. 4.3. The Modernist subdivision style form the basis for the skeleton subdivision

4.1. Introduction

101

Figure 4.1: Clockwise from top left: Glasgow, Shanghai, Param, and Nevada (Google
Maps). Left: Modernist parcel subdivisions. Right: Traditional parcel subdivisions.

4.2. Existing Parcel Subdivision Techniques

102

algorithm, detailed in Sec. 4.3.2, while the traditional style is approximated by the
oriented bounding box (OBB ) algorithm of Sec. 4.3.3. Concluding, the application of
these techniques to real-world block patterns is presented and evaluated in Sec. 4.5.

4.2

Existing Parcel Subdivision Techniques

The existing literature addressing procedural parcel subdivision comes mostly from
computer graphics. Given a city block as a polygon, the task is to subdivide it into
a number of non-overlapping parcel-polygons, giving the user control via a number of
parameters.
Fig. 4.2 gives several examples of existing automated parcel subdivision techniques.
The ﬁrst approach that the authors are aware of from within computer graphics, by
Parish and M¨ller[177] (Fig. 4.2, brown), has gained the most traction and variations.
u
The parcel is recursively split into two using straight lines (top, with darker splits
created before lighter ones). The variations include diﬀerent criteria for selecting the
line to split a region, and the termination criteria, although the literature often gives
trivial treatment to the details —
• Parish chooses to split perpendicular to the longest pair of edges that are approximately parallel, until the resulting parcels are below a speciﬁed area.
• Weber[255] et al. assume mostly rectilinear parcels and select the longest edge
adjacent to a street, before splitting perpendicular to this edge at a randomly
displaced midpoint. If the resulting parcels do not have an undesired aspect ratio,
they are accepted, otherwise another randomly displaced midpoint is attempted.
Once the parcels are below a user speciﬁed area the process terminates.
• Vanegas et al.[246] use the population count and number of jobs to estimate the
area of such a subdivision scheme.
Another early approach was to use area division based on a number of sites. The
Voronoi [248] diagram of a set of sites is a geometrical construct that associates every
point on the plane with the nearest site. The area spanned by points associated with
a single site is known as a cell. These Vornoi cells have been used to generate street
networks from a set of sites sampled by population density[224], as well as being used
used to specify parcel boundaries[117] (Fig. 4.2, yellow). Because the cells boundaries
are rarely rectangular, the results are not characteristic of observed parcel subdivisions.
An alternative application of the Vornoi concept is given by Aliaga et al.[13] (Fig. 4.2,
green). They observe that blocks often have a centreline dividing two strips of parcels

4.2. Existing Parcel Subdivision Techniques

103

Figure 4.2: Comparison of the skeleton subdivision approach to existing approaches.
From left to right, the input, the parcel subdivision techniques from[177, 117, 13, 260]
and our result which gives realistic result of Modernist parcel subdivision on concave
blocks.
on either side leads. This line is approximated by the ﬁtting of an oriented bounding
box (OBB), minimising the space between the box (a rectangle) and the block, and
using the centreline of the box. Voronoi sites are then positioned on either side of this
line and the cells become the parcels. The assumption of a straight line as a centreline
fails for concave blocks, as in Fig. 4.2, and still suﬀers from non-rectangular blocks in
some situations.
In general the urban modeling community has performed block subdivision manually
according to desired patterns[230, 178]. Those systems that have been created are
very limited in their realism and available styles[251, 95, 145]. One such example,
[260], again ﬁts an OBB to the block and generates a centreline. As shown in Fig. 4.2,
blue, these strips are then divided to approximate a certain parcel width, speciﬁed
by a user-deﬁned parameter, and clipped to the blocks perimeter. The system also
generates additional access roads, a property that we do not wish to emulate since
this is an earlier stage of the urban procedural modeling pipeline. This system again
fails on concave parcels, and is inﬂexible to the local geometry of the parcel boundary.
The remainder of the work from the urban modeling community has focused on parcel
subdivision of course raster-grid environments[122, 11, 155], which are not detailed
enough to use for visualisation purposes.
If we wish to interactively edit a city we are faced with the further problem of retaining
consistency under edits. We wish that changes to the road network, when edited

4.3. Block Subdivision

104

interactively, only minimally aﬀect the associated parcels created. When the changes to
the shape of a block are small Lipp[138] utilises mesh-warping techniques to deform the
existing parcel subdivision to the new geometry while keeping the topology intact. We
are not aware of any techniques in the literature that allow for larger scale interactive
editing. The problem of retaining the identity of individual parcels between user edits
is also unaddressed.
We ﬁnd the existing work somewhat limited in the lack of interactive features and
ability to deal with planned Modernist parcel subdivisions over concave parcels. We
continue to introduce our solutions to these issues.

4.3

Block Subdivision

This section introduces the technical background to our parcel subdivision schemes.
We ﬁrst detail the data structures used for the input and output of the system, and
the requirements of the output. We continue to discuss both the skeleton and OBB
based subdivision algorithms.

4.3.1

Inputs, Outputs and Goals

The input to the system is a set of city blocks, generated by the previous stage in the
urban modeling pipeline, while the output is a set of parcel polygons, suitable for the
next stage of the pipeline, creating mass models. Our system is able to fulﬁl these
conditions, while delivering statistically similar subdivisions over concave city blocks,
controlled interactively by a few parameters.
The previous stage of the urban procedural modeling pipeline delivers a street-network,
in our case a planar graph, (V, E), of verticies, V , and edges, E. These verticies lie in
the same plane in R2 , at the road intersections. The roads represented by the edges in
E, posses a width, and may be straight or curved. We expect that the graph is planar,
and no two roads intersect, giving a 1:1 mapping between the faces of (V, E) and the
set of blocks. The topology of city blocks is therefore formed by the faces of (V, E);
unbounded faces are not considered at this time.
Taking the geometry of a street (street width, sidewalks, intersections) surrounding
the block, B, the street modeling subsystem creates a simple polygon describing the
border of the block, C(B). The polygonal border approximates curving streets and
any features of the street geometry, such as pavements. This boundary is formed of
m verticies C(B) = {b1 , b2 , . . . , bm } in a counter-clockwise direction. Note that such
street modeling is a previous stage in the urban modeling pipeline, and like the following

4.3. Block Subdivision

105

stage of mass-model generation is not addressed here. Every edge in the boundary is
associated with a street in E, and a set of parameters. In our implementation we
recompute the faces, blocks, and parcels as the street network is edited, or the block
parameters adjusted.
The city block, B, is associated with various parameters. Each of these may be speciﬁed
by the user or extracted from example block subdivisions. The parameters include:
• the algorithm to subdivide the block into parcels, either skeleton or OBB
• parcel area bounds, (Amin , Amax ): The upper and lower bounds on the area of
the resulting parcels.
• minimum parcel width, (Wmin , Wmax ): The upper and lower bounds on the length
of the sides of the oriented bounding box of a parcel.
• split irregularity, ω: The deviation of a split edge from its default position, normalised in [0, 1]. Larger values result in the split being further away from the
mid-point and a larger variety of parcel areas.
• various algorithm subdivision speciﬁc parameters.
The output of the system is a set of polygons describing the new parcels. For every B
a set of n parcels, L = {l1 , l2 , . . . , ln }, are created that exactly cover B with no overlap;
that is n li = B and ∀li ,lj ∈L (li ∩ lj = ∅). Every parcel, l, is a planar polygon.
i=1
Modern procedural urban modeling systems make use of non-ﬂat terrain and roads. In
this situation, we vertically project the blocks onto the plane before subdivision and
re-project the output parcels onto the terrain after. We assume that the terrain is
height ﬁeld and thus suﬃciently ﬂat to preserve the planar and covering properties of
the blocks and parcels.
To replicate the two patterns suggested by urban design work (Sec. 4.1) we introduce
two independent algorithms to transform each B to a L. Our implementation was in
the Java language, within the procedural modeling system provided by CityEngine[66].
The straight skeleton (“SS” or “skeleton”) algorithm produces procedural Modernist
subdivisions, and is introduced in Sec. 4.3.2. The central assumption of the algorithm
is that each parcel has a similar street-frontage. The distance that each parcel occupies
behind this frontage is the parcel depth. If the depth is shallow, the block becomes a
perimeter block, with a semi-private patio area in the centre of the block. An example
of such a block is given at the top left of Fig. 4.1. If the depth is high, there is no patio
area, and leads to the observation that there is often a centreline in the subdivision,
with a row of parcels on either side. An example of this is shown in the bottom left

4.3. Block Subdivision

106

of Fig. 4.1. The skeleton parcel algorithm uses a partial and complete applications of
the straight skeleton to model perimeter and centreline blocks respectively. Typically
the result of this algorithm is rectangular blocks on rectilinear street patterns, and
“wedge” shaped blocks on curved streets.
The OBB algorithm is detailed in Sec.4.3.3, and creates a block subdivision in the
traditional style. An adaptive recursive partitioning of the block is introduced, as
introduced by Parish and M¨ller[177]. Because of this street access is not guaranteed,
u
but controlled by the user via a parameter. Further parameters control the distribution
of width and area of the generated parcels. The parcels generated are commonly of
a rectangular shape, and may exhibit greater diversity in size that those from the
skeleton subdivision algorithm.
It is possible to combine both subdivision styles within one block by creating a perimeter block with the skeleton algorithm and then using the OBB algorithm to partition
the central patio region.

4.3.2

Skeleton-based Subdivision

The straight skeleton subdivision algorithm generates Modernist parcel division. Our
approach is to generate a contiguous area for a row of parcels along a street (we refer to
these areas as strips) before slicing these strips along the adjacent street into parcels.
This approach ensures that every parcel has street access, and that the length of streetfrontage is similar for every parcel.
We observe that both perimeter blocks and centreline blocks contained such strips, and
that both can be generated by varying the depth of a block from the street. However
determining borders between these strips, both parallel and orthogonal to the street is
an involved problem —
• We observe that at corners of blocks near street intersections one strip will give
priority to another to ensure more rectangular blocks
• To control the style of subdivision to be centreline or perimeter, the depth of the
blocks from the street must also be generated as speciﬁed.
• A special case in our algorithm is the treatment of narrow blocks, in this situation
only a single strip is generated. The narrow-block threshold parameter identiﬁes
the parcels in which this behaviour is appropriate.
Our insight into this problem came after we observed that the arcs of the partial straight
skeleton included a lot of the information that we required to identify the centrelines.

4.3. Block Subdivision

107

This lead to the solution presented here which uses a partial straight skeleton to specify
the depth of the strips, but cleans up the “diagonal edges” generated near the corners
to create more realistic rectangular strips.
There were several alternatives to the unweighted skeleton for generating centrelines.
One possible alternative was the medial axis. The axis would introduce curved sections into our geometry, and given the polygonal nature of our input and output this
introduced additional complications. The medial axis is also unable to “guide” the
splitting of strips in the same manner as skeleton faces. A further alternative was the
weighted straight skeleton. This would have enabled us to move the centreline relative
to each of the edges of the block, and to create perimeter blocks with diﬀerent depths
on each road. The weighted straight skeleton proved problematic for two reasons; ﬁrst
there was no easy mechanism to assign such depths to each road, and second there
were no known commercial weighted skeleton implementations available at the time of
publication.
The skeleton subdivision uses the following parameters in addition to those in Sec. 4.3.1.
• The maximum parcel depth, doﬀset , determining whether the centreline or perimeter styles of subdivision occur.
• A street priority scheme, either StreetWidth or StreetLength. This speciﬁes the
direction in which diagonal edges should be resolved.
Applying the Straight Skeleton
To deﬁne the depth of the strips, the user deﬁnes a perpendicular distance doﬀset from
the block contour C(B) to an inwards oﬀset contour C (B). This value corresponds
to the maximum depth (distance from the road to the rear) of the parcels. If doﬀset is
suﬃciently large (e.g., inﬁnity), then the area enclosed collapses and the rear side of
any resulting parcel will be directly adjacent to another parcel, leading to centrelines
between rows of parcels. Alternately, if the doﬀset value is suﬃciently small, the partial
skeleton application deﬁnes a closed inner patio region, with no direct access to roads.
This inner region may be disconnected if the initial block is concave, as in Fig. 4.3 right,
and can be further partitioned using an arbitrary subdivision style. While setting an
inﬁnite value for doﬀset is typical and better complies with the ﬁrst parcel variety,
inner patios are not uncommon and we designed our skeleton-based subdivision to
also support them. The contour C (B) is calculated (via the CGAL library [1]) by a
partial application of the straight skeleton to C(B) to oﬀset distance doﬀset , as shown
in Fig. 4.3, by computing the intersection of the roof model of [7] with a horizontal
plane at a speciﬁc height.

4.3. Block Subdivision

108

b

a
doﬀset

Figure 4.3: Left: The straight skeleton of a polygon, showing C(B) (black line).
Right: A partial application of the straight skeleton computes the oﬀset contour C (B)
(dashed lines) at distant dof f set . Note that the contour may split the innermost, or
patio, region into several portions (a,b). The individual faces of the straight skeleton
conform to our deﬁnition of a strip, and we may take the supporting edges to be portions
of the boundary of input polygon. We take these faces to be the initial set of α-strips.
The arcs of the skeleton application specify the division of the region between C(B) and
C (B) into a set of strip polygons. We initially refer to these as α-strips, to diﬀerentiate
them from the β-strips, from which we have removed some diagonal edges. These strips
are an intermediate value in our algorithm, representing a group of parcels with their
primary frontage on the same logical street. Collectively they form a single connected
region.
Formally we deﬁne a strip, si , as a simple polygonal area within B, such that a single
connected length of the polygon’s boundary forms part of C(B). These lengths are the
supporting edges, ψ(si ), of si . A block’s cyclic list of n strips, LS(B) = s1 . . . sn , is such
that it covers the area between C(B) and C (B) completely and without overlap. The
list LS(B) is ordered counter clockwise, such that the last supporting edge of si and
ﬁrst of si+1 are adjacent edges of C(B). Note that we take i + 1 to mean (i + 1) mod n
in the context of a cyclic list data structure.
We initialise LS(B) from the faces of the straight skeleton used to compute C (B).
We observe that these faces fulﬁl the strip properties — bounded by the arcs of the
skeleton, and supported by an edge of C(B). Any strip in LS(B) may be combined
with either of its neighbours and the union retains the strip properties; Therefore we
may union adjacent faces in LS(B) according to whether they lie on the same logical
street, e ∈ E in our street graph. In this manner we create a single α-strip for every
logical street, as in Fig. 4.4, b.
Removing Diagonal Edges
The α-strips computed from the skeleton faces suﬀer from diagonal edges at the intersection of logical streets as shown in Fig. 4.4, b. As illustrated in Figure 4.4c-g, we
correct these edges, by modifying LS(B) to transfer a near-triangular region from the

4.3. Block Subdivision

109

b

a

P
N

N
c

N

P

g

P
z

z

d

e

f

Figure 4.4: The α-strips (solid colours, b) are recovered from the skeleton (a) and logical streets (bold lines, b). This leaves undesirable diagonal edges, such as that between
the brown and green alpha-strips. Given the classiﬁcation T (vi ) ∈ None, Previous (P )
or Next (N ), we reassign regions (shaded, c), to create the set of β-strips. In the
example (c-e) we use the classiﬁcation scheme StreetLength, specifying the direction
Previous. The subsequent splits are computed over these β-strips (f ).
strip on one side of an oﬀending edge to the strip on the other side. We refer to these
corrected strips as β-strips.
Let the shared supporting vertex between each pair of α-strips si and si+1 , be designated vi . The shared boundary of these two strips forms the diagonal edges we
are concerned with, one end of which is vi . We provide a classiﬁcation T (vi ) ∈
{Previous, Next, None}, to specify which of the pair of strips will gain the region,
and which will lose the same region. A vertex with the property Previous (respectively
Next), will assign a region to the previous (next) strip, given the counter-clockwise
vertex ordering. No action is taken with a value of T (vi ) =None.
The values of T (vi ) may be assigned by one of two street priority schemes, determined
by a per-parcel parameter speciﬁed by the user. When the angle of the supporting

4.3. Block Subdivision

110

edges at vi is reﬂex we always assign T (vi ) =None. For the remaining v, we choose
between the following two schemes:
• StreetWidth. If the average width of the street edges associated with the supporting edges of si is greater (respectively lesser) than those of si+1 then T (vi ) =Previous
(Next).
• StreetLength. If the length of the supporting edges of si is greater (respectively
lesser) than those of si+1 then T (vi ) =Previous (Next).
We ﬁnd that in most most urban environments the parcels face the most important
and thus widest street; therefore we use the StreetW idth scheme by default. There
are situations in which this assumption is not suited. For example, residential street
patterns in which parcels prefer to face the quieter, and longer, residential streets,
rather than the wider and busier access-streets. In our experiments it proved diﬃcult
to make this distinction automatically, so we allow the user to assign this parameter
manually.
Given the parameter T (vi ), we calculate the direction in which to reassign the region,
shown in Fig. 4.4, c, creating the set of β-strips. The region is removed from strip sx ,
where sx = si if T (vi ) =Next, or sx = si+1 if T (vi ) =Previous. The region is removed by
cutting between two points. The primary point is the location on the boundary of both
si and si+1 that is furthest, at distance z, from C(B), (Fig. 4.4, d). The secondary
point is located on C(B) at a distance z from vi along psi(sx ). The region is then
unioned to the strip sy where sy = si+1 if T (vi ) =Next, or sy = si if T (vi ) = Previous.
Finally we recompute the skeleton arcs to remain perpendicular to the local edges in
ψ(sy ), (Fig. 4.4f), in order to ensure we are able to guide the subsequent splits in the
following stage (Fig. 4.4g). After processing each pair of adjacent strips in LS(B), we
are left with the list of β-strips.
Strips with a small supporting edge are rarely observed, and so are undesirable. If a
strip loses area to both neighbouring strips, and the distance between the secondary
points is small, we move the secondary points to the same location. A threshold
distance of 2Wmin determines whether we move both points to the point closest to their
mean location on ψ(sy ). This ensures that the entire strip is reassigned to its neighbours
(Figure 4.4b, cyan and brown). Such a strip is removed from LS(B). On small lots this
routine may introduce “zig-zag” artifacts, these are resolved as in Fig. 4.5.
Splitting Strips into Parcels
To subdivide the β-strips into parcels, a set of points are sampled approximately
equidistantly on ψ(si ), as shown in Fig. 4.6. Rays from these points, perpendicu-

4.3. Block Subdivision

111

z

a

b

c

d

Figure 4.5: The green and yellow strips take enough area from the blue and red
strips to trigger their removal, as z become less than 2Wmin (ab). If we move the
secondary point to a mean location, we may be left with “zig-zag” artifacts after the
strip is removed (c). In this situation we average the location of the primary points
also. Given that the distance between these primary points is small, we have found that
this causes very few problems.
lar to the nearest edges of ψ(si ), split the β-strip into parcels. We “snap” rays to
nearby verticies to create cleaner geometry. The distance between the points is normally distributed around (Wmin + Wmax )/2, with σ 2 = 3ω, and clamped to the length
of ψ(si ). This process adds a random displacement to the ray-origin points to create
less uniform parcels. To prevent local perturbations in ψ(si ) adversely aﬀecting the
parcel geometry, we limit the rays to each skeleton face. If the ray crosses a skeleton
edge, it follows the edge to the boundary of the strip, as illustrated in Fig. 4.6b.
There are several special cases that are handled independently as post processing steps:
• There are situations in which the block is too shallow to accommodate the two
rows of parcels assumed by the algorithm. In this case we group shallow parcels
and replace them with parcels generated similarly to the skeleton subsequent split
technique.
• If a parcel is deep, the area may be unacceptably large. To mitigate this eﬀect,
blocks of area larger than Amax are split again, via a second ray cast from the
street.
• Triangular parcels and parcels with small areas are repeatedly unioned with their
neighbours until they are either larger than the minimum area (Amin ), neither
small nor triangular, or there is only one remaining parcel. We union such parcels
with the adjacent parcel with which it shares the longest boundary.
As illustrated in Fig. 4.7, the diagonal edge removal and the splitting of strips into
parcels works in the same way regardless of the value of doﬀset , that is whether we use
a partial or a full skeleton application.
The pseduocode for the complete skeleton subdivision algorithm is given in Fig. 4.8.

4.3. Block Subdivision

112

Figure 4.6: The split operation divides a β-strip’s area (solid colour) into parcels
with rays (dashed lines). Top: The naive approach leads to unrealistic splitting as an
eccentric local normal to the supporting edge (bold lines) may propagate in an uncontrolled manner. Bottom: We constrain split-lines to the skeleton faces they are within
to achieve a more realistic eﬀect.

Figure 4.7: Our algorithm to compute the partial skeleton (left), remove diagonal
edges (middle) and split the strips (right) demonstrated on a perimeter block.

4.3. Block Subdivision

subdivSkeleton(B)
L←∅
SS ← computeSkeletonOﬀset(C(B), doﬀset )
LS ← ∅
for each face f ∈ SS do
Append convertToStrip (f ) to LS
end for
LS2 ← mergeOnLogicalStreets (LS)
LS3 ← ﬁxDiagonalEdges (LS2)
for each strip s in LS3 do
slice (s)
end for
processSmallLargeOrTriangularParcels(LS, Amin , Amax )
ﬁxDiagonalEdges(LS)
for each strip si ∈ LS do
vi ← vertex between si and si+1
t ← triangular portion at vi
if T (vi ) = P revious then
assign t to si
end if
if T (vi ) = N ext then
assign t to si+1
end if
end for
for each strip si ∈ LS do
if ψ(si ) < 2Wmin then
remove si from LS
merge primary verticies
end if
end for

slice(s)
origins ← sample ψ(s) by n((Wmin + Wmax )/2, 3ω)
remainder = oﬀset faces of s
for each point p ∈ origins do
normal ← average normal of B near p
Create a ray, r, from p, in direction normal
[lef t|right] ← slice remainder by r
Append lef t to L
remaining ← right
Append remaining to L
end for
Figure 4.8: Skeleton parcel subdivision pseduocode.

113

4.3. Block Subdivision

4.3.3

114

OBB-based Subdivision†

The orientated bounding box algorithm generates parcels in the traditional style. The
resulting subdivision contains mainly rectangular parcels with and without street access. The OBB based subdivision algorithm has a single additional per-block parameter, ξ, to specify the preference for street access.
The algorithm recursively performs a binary partitioning of the block until certain
termination conditions are met, as in Fig. 4.9. The partitioning is via a straight line
that splits the block into two.
To determine each split line, the minimum-area OBB that covers the block is computed.
The pivot point of the split line is given by the midpoint of the largest edge of the OBB,
translated by a random distance proportional to ω. The direction of the split line is
given by the direction of the smallest edge of the OBB.
The process ﬁnishes when the area of a parcel is within (Amin , Amax ), or the street
frontage is within (Wmin , Wmax ). If the split-line would create a block without street
access, the orientation of the split line is rotated by 90 degrees with probability ξ. This
parameter controls the preference of a parcel towards street access, with higher values
(closer to 1) making it much more likely that all parcels in the block will have street
access.
Our method takes into account the following additional considerations during subdivision:
• edge alignment – to increase the performance of subdivisions under interactive
editing operations, we ﬁnd the best-ﬁtting OBB by ﬁtting OBBs that align with
at least one of the parcel edges,
• random seeds – to increase the stability of subdivisions under interactive editing operations, the random seeds for the recursive splits of a given parcel are
computed before the recursive call to the subdivision function,
• snap to block contour verticies – if the split line is within a threshold distance
from one of the verticies of the contour of the original block, the pivot point of
the split line is set to that vertex.
The OBB algorithm only considers local geometry, unlike the skeleton algorithm that
considers the entire block. However this gives the OBB the advantage that it is locally
robust against distant edits in the shape of the block.
The complete OBB algorithm is presented in Fig. 4.10.

4.3. Block Subdivision

115

Figure 4.9: Oriented bounding box subdivision. This adaptive algorithm recursively
splits a parcel into two smaller parcels along the minor axis of the oriented bounding
box of the original parcel. The subdivision continues until user-speciﬁed shape attributes
are satisﬁed.

subdivOBB(B)
L←∅
recSubdivOBB(C(B))
recSubdivOBB(l)
if area(l) ∈ (Amin , Amax ) and f rontSideW idth(l) ∈ (Wmin , Wmax ) then
/
/
s ← computeSplitLine(l)
[lA , lB ] ← split(B, s)
if lA or lB have no street access then
Rotate s 90 degrees about the normal vector of the plane containing B, with
probability ξ
[lA , lB ] ← split(B, s)
end if
recSubdivOBB(lA )
recSubdivOBB(lB )
else
Append l to L
end if
computeSplitLine(l)
OBB ← computeOBB(l)
Let the direction of l be the direction of the shortest side of OBB
Let the pivot point of l be the middle point of OBB
Apply a random translation of magnitude ω · dOBB to the pivot point of l, where
dOBB is the length of the shortest side of OBB
Figure 4.10: OBB subdivision pseudocode.

4.4. Parcel Consistency under Live Editing†

116

b
c
a
d

e

Figure 4.11: A street network (bottom left) may be interactively modiﬁed in several
ways (a-e). We use our matching function to compute the location of each parcel, and
show the location of a given parcel (blue house) after each editing operation; moving an
edge (a); editing the curve of two edges(b); changing the width of a street (c); changing
the subdivision style (d) or scaling the street network (e).

4.4

Parcel Consistency under Live Editing†

Given an urban procedural modeling pipeline that generates a road network, blocks,
parcels and mass models it is a common operation to allow users to edit the system
interactively. For example users may customise:
• the location of verticies in the street network graph.
• the parameters for a block’s parcel subdivision.
• the mass-model grammar associated with a particular parcel.
This raises the problem of maintaining the consistency of parcels under various editing
operations — as the user uses a mouse to move the verticies of a parcel, rotate or scale
the entire parcel, how do we ensure that the structures assigned to each parcel remain
consistent? Given that considerable time and eﬀort may have gone into customising a
building on a particular parcel, it is unreasonable that small editing operations would
undo this work. It is therefore necessary to give predictable continuity under live
editing to as greatest extent as possible. This is illustrated in Fig. 4.11.
The parcel subdivision algorithms themselves may produce a diﬀerent shape and number of parcels after such editing operations. It is inevitable that parcels must be added
and removed from a block during such operations to maintain correlation with parameters, such as minimum and maximum area. Therefore, in [247] the continuation of

4.5. Results

117

c
a

f
d

b

g
e

Figure 4.12: Examples of varying diﬀerent attributes of OBB (a,b) and skeleton,
subdivision (c-g); a large and small diﬀerence between Amin and Amax (a); the eﬀect
of enforcing street access (b); low or high parcel-width (c); editing the street widths, to
change T (vi ) (d); editing the criteria for shallow-parcel removal (e); low or high value
of doﬀset (f ); a higher value of ω, and a variety of subdivision styles in the patio region
(g).
this work presents a solution to the parcel matching problem, retaining the identity of
throughout an editing operation.

4.5

Results

In this section we evaluate the two subdivision algorithms against real-world data.
The presented algorithms are able to generate a wide range of styles of subdivision,
depending on the block shape and attributes selected. Fig. 4.12 illustrates the eﬀects
of altering several parameters over a constant synthetic block. However this level of
evaluation is insuﬃcient if we wish to demonstrate the ability to synthesise blocks in a
particular style observed in the real world.
The evaluation of PGM is an interesting proposition — we do not wish to produce the
same result as the input, but instead to generate a quantity of realistic geometry of a
particular style. While there is the question of evaluation against ﬁctional (unobserved)
styles for stylistic or inspirational reasons, we came to the conclusion that the most
important criteria was realism with respect to real-world data. This was especially
true since we desired to evaluate the urban design theory that our algorithms are
based upon.
We use an implementation of our algorithms within the CityEngine package to recreate subdivisions over urban areas with known data. Some of the parameters for the
algorithms are automatically derived, others were manually set. Several statistical mea-

4.5. Results
Name
Pasadena
Naperville
Wynneﬁeld
Germantown

118
Location
California,
USA
Illinois,
USA
Philadelphia,
Pennsylvania, USA
Philadelphia,
Pennsylvania, USA

Data Source
Propriety
Esri dataset
Esri “Local
Govt Basemaps”
Pennsylvania
Dept. of Records
Pennsylvania
Dept. of Records

Algorithm
Skeleton

Figs
4.14, 4.15

Skeleton

4.16, 4.17

Skeleton & OBB

4.18, 4.19

OBB

4.20, 4.21

Figure 4.13: Data sources used in the evaluation of our system.
sures were evaluated over the whole area, and per-parcel, to quantify the diﬀerences
between the observed and procedural subdivisions. These measures are visualised over
maps to assist in objective analysis of the quality of block subdivision.
The sources of the observed (ground-truth) parcel subdivisions are given in Fig. 4.13,
mainly GIS Government databases. The use of North American cities was due to
the ease of accessing parcel data in a suitable format, with the older cities, such as
Philadelphia, contrasting with newer cities, such as Pasadena. Neighbourhoods with
a consistent and locally representitive subdivision style were selected for study within
these cities. A number of GIS data irregularities were present, such as overlapping
parcels, long thin parcels or small gaps between parcels; these were manually removed.
The workﬂow consists of the following steps:
1. The road networks and blocks are traced from the GIS data, and street widths
manually assigned.
2. Per-block statistics are extracted from the GIS data for the mean and standard
¯
¯
deviation of both the parcel area (A, sA ) and minimum width (W , sW ). Assuming
a rectangular parcel, these ﬁgures are suﬃcient to estimate the average aspect
ratio of the parcels within a block.
3. The values of block subdivision parameters in the procedural model are set;
¯
¯
¯
¯
Amin = A − ksA , Amax = A + ksA , Wmin = W − ksW , Wmax = W + ksW , where
k is a positive constant that in our examples was set to 2.
4. The algorithm and remaining parameters, including ω, are manually assigned
using interactive feedback given from the system.
5. We calculate our statistical measures from the resulting subdivision – i) block
area (m2 ) ii) block aspect ratio (longest side on a ﬁtted OBB/shortest side) and
iii) the number of neighbours each parcel has (a neighbouring block is deﬁned as
being within 0.5m of another block’s boundary).

4.5. Results

119

area(m2 )

aspect ratio

neighbour count

Observed

2

0

2

4

6

8 10 12

5.
0

35
3.

4
2.
2

0
1.
5

00
1.

34
6
24
27

49

7

1

Procedural

Figure 4.14: Location and aggregate statistics for the Pasadena data set. Images
from Google Maps.
The results of this process are shown in Figures 4.14–4.21.
Pasadena is a relatively modern city, and has many areas that area well classiﬁed as
having a Modernist parcel subdivision. Fig. 4.14 shows the location of area studied,
and the aggregate results of observed and procedurally generated lots. The histograms
plot the frequency of blocks having certain areas or aspect ratios, while the bar-chart
plots a similar measure for the discrete neighbouring parcel count. Note that horizontal
axes of the histograms are logarithmic, while the horizontal axes of the bar-chart are
linear. The corresponding observed and procedural subdivisions are shown in Fig. 4.15.
Per-block shading illustrates each of the three statistical measures for the observed and
procedural parcels. Generally we found that our statistical measures agreed with our
intuition that the subdivision was generating very similar results. The accuracy of the
aggregate statistics was particularly high in this example.
The example of Naperville was chosen as a good example of a Modernist subdivision
with a speciﬁc depth, Figs. 4.16 and 4.17. Many of the residential parcels in the
observed subdivision neighbour a golf course to the rear leading to ﬁxed-depth oﬀsets.
The notable statistical misﬁt here is that a lower number of procedural parcels were
generated than observed, most probably due the changing street-frontage present in
the real world data.
To perform a direct comparison of the skeleton and OBB techniques we chose a middleclass neighbourhood in Philadelphia with a range of parcel styles. Figs. 4.18 and 4.19

4.5. Results

120
Observed

Procedural
0.00

area(m2 )

4259.59
8519.18
12778.77
17038.36

ratio

0.00
1.88
3.75
5.63
7.50

neighbour count

0.00
3.00
6.00
9.00
12.00

Figure 4.15: Results for the Pasadena procedural parcels generated using the skeleton
algorithm.

7

48

6
33

4
33

Procedural
0

0
1.

48
1.

aspect ratio

20
2.

27
3.

0

2

4

6

8

10

neighbour count

2
Figure 4.16: Location and aggregate statistics for the Naperville data set. Images from Google Maps. Note the truncated neighbour
count horizontal axis.

1

Observed

area(m2 )

4.5. Results
121

4.5. Results

122

Observed

Procedural

area(m2 )
0.00
4056.16
8112.31
12168.47
16224.63

ratio

0.00
1.80
3.59
5.39
7.19

neighbour count
0.00
5.75
11.50
17.25
23.00

Figure 4.17: Results for the Naperville procedural parcels generated using the skeleton
algorithm.

4.5. Results

123

document the comparison of both subdivision techniques against ground truth. We
observe that the aggregate aspect ratio of the straight skeleton subdivision is closer
to the observed distribution than that of the OBB. However the parcel level statistics
show that both techniques produce reasonable distributions for all three statistical
measures. We observe that the OBB technique produces more of the highly irregular
patterns present in the larger lots in the top right of the example area, while the
skeleton is able to generate the curving centrelines observed in the small lots to the
bottom left.
The ﬁnal example uses Germantown, again in Philadelphia, as an example of a traditional lot subdivision. The results are illustrated in Figs. 4.20 and 4.21. Again we
observe that the OBB technique generates a ﬂatter aggregate aspect ratio histogram,
but in this case this distribution matches the ground data well; this is supported by
the per-parcel statistics.

6

31

4

17

8
96

Procedural (SS)

1.

00

58

1.

51
2.

aspect ratio

97
3.

28
6.

0

2

neighbour count

4

6

8

10

Figure 4.18: Location and aggregate statistics for the Wynneﬁeld data set. Images from Google Maps.

1

Procedural (OBB)

Observed

area(m2 )

4.5. Results
124

4.5. Results

125

Observed
area(m2 )

ratio

neighbour count

Procedural (Skeleton)

Procedural (OBB)

0.00
1349.50
2699.00
4048.50
5398.00

0.00
2.49
4.97
7.46
9.95

0.00
4.00
8.00
12.00
16.00

Figure 4.19: Results for the Wynneﬁeld procedural parcels generated using the skeleton and OBB algorithms.

Procedural

1

8

63

7
39
49
39
Figure 4.20: Location and aggregate statistics for the
procedural aspect ratio.

Observed

area(m2 )

00 58 .50 .95
3
2
1. 1.
Germantown data

aspect ratio

0 2 4 6 8 10 12
25
6.
set. Images from Google Maps. Note the vertically truncated

neighbour count

4.5. Results
126

4.5. Results

127

Observed
2

area(m )

Procedural
0.00
7800.75
15601.50
23402.25
31203.00

ratio

0.00
2.47
4.94
7.42
9.89

neighbour count

0.00
6.75
13.50
20.25
27.00

Figure 4.21: Results for the Germantown procedural parcels generated using the OBB
algorithm.

4.5. Results

128

The subdivision methods introduced all successfully imitate real world subdivisions.
However certain cases in the above examples demonstrate deﬁciencies. Fig. 4.22 shows
three examples common to all algorithms:
• Left, shows that we do not model parcels with private access roads. The central
observed parcel has a lane to the bottom right. Often parcels recorded in GIS
data include a narrow stretch of land for access, these deeply concave polygons
are not modelled by our system at all. Indeed, both the algorithms do to not
include considerations such polygons.
• Centre, illustrates an artifact related to statistical extraction. The large lot (blue)
skews the statistical mean and deviation to cause the subdivision to create larger
lots with high variation.
• Right, demonstrates the importance of selecting a suitable algorithm for the shape
of block. The OBB subdivision here creates unrealistic interior parcels, and is
unable to identify a realistic centreline.
Germantown
bottom right
observed

Pasadena
mid-left

Wynneﬁeld (OBB)
mid-left

procedural

area

area

ratio

Figure 4.22: General issues arising from our subdivision algorithms illustrated by
cropped portions of earlier images.

4.5. Results

129

A further feature that we do not take into account is the modeling of non-local features.
For example Fig. 4.23 identiﬁes a straight centreline that continues between blocks.
Inspection of various maps suggests that this appears to be caused by a power-line
running throughout the neighbourhood, dictating the boundary of the parcels. These
features are not modeled by our algorithms, and do not form a signiﬁcant part of the
urban planning literature, but seem to be very visible in certain circumstances.

Figure 4.23: Non-local features are not modeled by our system in the Pasadena data
set. Left: observed. Right: modeled (as Fig. 4.15)
.

4.5. Results

130

The skeleton algorithm in particular provided some very accurate block subdivision,
due in part to the additional information available about street priorities. Fig. 4.24
examines various aspects of the skeleton subdivision.
• Column 1 demonstrates that other split-direction heuristics are possible. The
observed data in this cases slices strips in a uniform direction, regardless of the
local street normal. The parcels of the procedural model adjacent to the right
road are also of a peculiar shape. This artifact occurs when diagonal edges do
not snap together when there is a small street frontage.
• Column 2 shows a further split-heuristic. The Naperville area statistics make it
clear the the designers desired parcels of constant area, unlike our algorithm which
attempt to assign equal street frontage. This suggests that another parameter
for selecting the split heuristic may be desirable.
• Column 3 shows a complex concave block in which the skeleton subdivision centreline was very faithful to the observed data.
• Column 4 illustrates a complex example from Naperville that was very also similar to observed data, especially when we compare the number of neighbouring
parcels.
Wynneﬁeld (SS)
bottom right

Naperville
mid-left

Pasadena
bottom right

Naperville
bottom right

Observed

Procedural

neighbours

area

area

neighbours

Figure 4.24: Cropped portions of earlier results images, examining various aspects
of the skeleton subdivision.

4.6. Conclusion

131

Figure 4.25: The results of our parcel subdivision algorithm within CityEngine. Left:
The parcel subdivision generated with both skeleton (bottom left of grey line) and OBB
(top right) techniques; the colouring denotes relative area. Right: the result of the urban
procedural modeling pipeline within CityEngine.

4.5.1

Use within CityEngine†

The integration with CityEngine allows a large range of PGM techniques to be brought
to bear on the resulting parcels. In Fig 4.25 we use two subdivision styles within a
single area to better represent the change in land use variation in the Wynneﬁeld
data set. The resulting parcel subdivisions may then be passed to later stages in the
procedural urban modeling pipeline[160] to generate a visualisation of a Philadelphia
neighbourhood.

4.6

Conclusion

We have demonstrated the application of the straight skeleton to the generation of
city parcel layouts. Alongside a modiﬁcation of earlier OBB-based work our system
is able to model a wide variety of the subdivision styles observed in urban areas. We
have quantitatively evaluated our system over a range of North American real-world
subdivisions, and found the areas, parcel aspect ratios and the number of neighbours to
resemble observed subdivisions. The most frequently observed deﬁcit in our system was
the inability to simulate concave parcel subdivisions in a manner similar to observed

4.6. Conclusion

132

data; we hypothesise that additional simulation elements in the subdivision process
may resolve this issue. The presented algorithms allow interactive editing and have
proven robust enough for integration into a commercial procedural modeling system.
Future work may include —
• mixing the two subdivision styles within a single block,
• modeling inter-block phenomena, such as a preferred split direction or features
such as power cables or administrative boundaries,
• selecting the most appropriate subdivision algorithm automatically from examples; this could be extended to the extraction of all of the parameters, such as
street priorities, given examples, or
• adjusting the skeleton subdivision to deliver constant-area, rather than constantstreet-access solutions.
Having demonstrated one domain, block subdivision, in which the straight skeleton
provides a compelling interactive procedural modeling tool, we continue in the following chapter to examine another domain — that of constructing mass models from
ﬂoorplans.

133

Chapter 5
Procedural Extrusions

This section is based on the paper Interactive Architectural Modeling with Procedural Extrusions[116], co-authored with Peter Wonka.

5.1

Introduction

Here we introduce an application of the mixed weighted straight skeleton to the interactive procedural modeling of architectural models. The procedural extrusion (PE)
system procedurally generates solid 3D meshes by extruding building footprints. Such
an application of the straight skeleton to the creation of architectural surfaces allows
for the generation of diﬃcult architectural surfaces such as curved roofs, overhanging roofs, dormer windows, interior dormer windows, roof constructions with vertical
walls, buttresses, chimneys, bay windows, columns, pilasters, and alcoves. The system
comprises of a user interface to specify procedural extrusions manually as well as a
tool for the automated generation of large procedural cityscapes from their footprints.
Extensions to the the sweep plane algorithm of Chapter 3 are utilised to compute a
wide range of two-manifold architectural surfaces.
The procedural extrusion system is both an interactive and procedural modeling tool for
such architectural surfaces. Procedural geometric modeling oﬀers several advantages
over traditional static modeling of architectural forms. PGM descriptions of objects
allow us to edit meshes at a higher sematic level; for example, editing roof angles rather
than vertex coordinates, whilst ensuring constraints are enforced, such as polygon
planarity. Additionally we can preseve subsequent edits while allowing earlier edits
to be modiﬁed; such as changing the slope of the roof after the chimney has been
created upon it, without adjusting the chimney. Nevertheless, the biggest advantage
of procedural modeling over static modeling is the creation of large scale cityscapes,

5.1. Introduction

134

Figure 5.1: Procedural extrusions allow a footprint (2d plan) to be extruded to form
the walls and roof of a house (inset). Meshes and procedural details can then be attached
(main).
without a proportional increase in designer eﬀort. Many of the current PGM systems,
such as CGA Shape[159], require end user programming. In contrast, the PE system
provides an interactive graphical tool, instead of a programming language, to specify
geometry. This lowers the barriers of entry to PGM, allowing more people to create
procedural content.
Architectural surfaces are often deeply concave and contain complex architectural features such as overhanging roofs, dormer windows, interior dormer windows, roof constructions with vertical walls, buttresses, chimneys, bay windows, columns, pilasters,
and alcoves. These intricate surfaces have not previously been available as watertight
meshes in procedural environments. Systems such as shape grammars[219, 157, 140]
have tended to concentrate on the combinatorial, rather than the geometric aspects of
architecture generation, and are not able to generate such geometry themselves. Typically these systems rely on pre-existing meshes that are instanced, positioned, and
scaled to appropriate locations.

5.1. Introduction

135

Figure 5.2: These two examples show architectural surfaces overlayed with the user
input. Plans (green), proﬁles (blue), natural steps (orange) and oﬀset events (red) are
speciﬁed in the user interface. The output of our system is an architectural shell (gray).
Given buildings, such as in Fig. 5.2, it is not obvious how to construct 3D models
of these structures. Procedural extrusions provide a novel parameterisation of such
buildings by taking inspiration from architects’ drawings consisting of ﬂoorplans and
elevations.
The ﬁrst major component of the system is presented in Sec. 5.3 and allows the user
to interactively draw a ﬂoorplan, and assign an arbitrary proﬁles to each plan edge.
Nested sets of plans and proﬁles allow features such as dormer windows and alcoves
(Fig. 5.2, orange) to be modeled. Interactive modeling via the user interface allows
the expressivness of the system to be explored in depth. We evaluate the interactive
portion of the PE system in Sec. 5.6 by modeling 50 various structures from a catalogue,
as well as seeking opinions from users as to the properties of the system.
In order to combine arbitrary plans and proﬁles, the second component of the system is
a collection of algorithms to construct 3D meshes from the speciﬁed plans an proﬁles.
These algorithms utilise a variety of repeated applications of the MWSS (Chapter 3,

5.2. Related work

136

Sec. 3.5) to create a geometry modeling system. We take the sweep-plane that is
used to calculate the MWSS and introduce additional types of user speciﬁed events.
These algorithms are presented in Sec. 5.5.1. To evaluate the real-world stability of
these algorithms we evalute PEs over a large scale data of 6000 building footprints
in Sec. 5.6. Here we note that the computational geometry community emphasizes
provably correct algorithms and therefore often favors rational arithmetic. In contrast,
our work consists of heuristic algorithms that emphasize computational speed and are
geared towards a ﬂoating point implementation. While our heuristics include various
mechanisms to make the results more robust, it is possible that the computations can
fail. For example, in the Atlanta data set of 6000 footprints we noted that two roof
planes were not computed correctly. The approximate nature of our ﬂoating point
computation also results in roof planes being moved by millimeters.
We conclude with a description of external applications to which others have sucessfully
applied components of the PE system.
The contributions of our work are:
• the design of the system and tools to enable procedural modeling of complex
architectural surfaces.
• the set of tool choices to enable procedural modeling of complex architectural
surfaces.
• heuristic algorithms to generate a polygonal mesh from the user speciﬁcation that
is approximately consistent with the input data.
• the evaluation of the system on a collection of examples to verify its practical
utility, and to identify conﬁgurations that are diﬃcult to model with our tools.

5.2

Related work

In this section we describe and examine some common techniques applied to architectural modeling and analyze some of the properties of the resulting architectural
meshes.
We may make the observation that many architectural and man-made objects have
a common property: There are many horizontal edges to the geometry, and the faces
adjacent to these edges lie in the same plane. For example Fig. 5.3 shows one building
with many horizontal edges and associated faces.
In addition there are several properties that we ﬁnd desirable in computer models of
architectural structures. We assume to use polygonal mesh models, since these are

5.2. Related work

137

Figure 5.3: In many buildings’ geometries, there are many horizontal edges (green).
Many faces of such geometry are coplanar to one or two such edges. In this case, only
the red faces do not do not have such a horizontal edge.
common, somewhat standard in industry, and are those which hardware (GPU) acceleration is designed to accommodate. “Nice” 3D meshes commonly have the following
properties:
• Planar faces: Each face lies entirely within a single plane.
• Water-tight: There are no holes in the mesh, all adjacent faces are connected via
a shared edge, and all adjacent edges are connected via a shared vertex.
• No self-intersections: No part of the mesh protrudes through another; the only
parts of the mesh that touch are adjacent in the mesh data structure.
To describe such meshes, basic 3D modelling tools such as as those introduced in
Sec. 2.12 may be used. Tools such as manual vertex modeling, extrusion, lofting
and constructive solid geometry tools have all been used to model architecture in
3D modeling tools such as Maya[20], 3D Studio Max[2] and Blender[73]. Given the
common features of many architectural models, these general tools are not optimal
when working with such a speciﬁc domain:
• Manual vertex and face speciﬁcation gives users the tools to create and position
verticies in R3 . These tools allow unrestricted mesh creation, but it is possible,
and even common, for such tools create non-planar polygons, non-watertight, or
self-intersecting meshes. Often additional post-processing stages must be applied
to check for these conditions, and resolving them is left to the user. Fig. 5.4
illustrates how moving a single vertex may result in several non-planar faces.

5.2. Related work

138

Figure 5.4: Given a mesh (left), translating a single point(orange) may result in one
or more non-planar faces(right).
• Extruding a plan-polygon either in a single direction or along a 3D path, Fig. 5.5,
left, is another method to construct meshes with rectangular faces. Careful positioning of the plan and proﬁle can produce meshes with the desired horizontal
edge property. An extrusion tool creates an instance of the plan at each vertex of the path. It continues to create a rectangular face between the pairs of
corresponding plan edges from adjacent plan-instances.
However there are some problems with the extrusion tool. If the path rotates, the
faces of the resuling geometry may not be planar, Fig. 5.5, centre. Additionally,
when modelling walls and roofs, the plans and proﬁles are not changed in response
to the geometry; self-interesctions may occur, such as when modeling roofs —
the crest of the roof may either fall short, or overshoot as in Fig. 5.5, right. Such
deﬁciencies with geometry created by the extrude tool must be identiﬁed and
removed manually, possible with manual vertex and face edits.
Levelshop is a rapid video game level prototyping tool that uses extrusions, together with user deﬁned 2D plans[72]. Because of the above problems with extrusion, it is limited to relively output simple geometry.
• A modiﬁcaiton to the extrusion algorithm allows for diﬀerent proﬁles to be used
at each vertex on the proﬁle. This loft tool allows more artist interaction, so
that when the geometry does self-intersect, the proﬁles may be manually edited.
Lofts are a modeling primitive extensively used in 3D modeling packages. As
when extruding there are no guarantees that the result of a loft will not selfintersect. The manual editing of proﬁles can be quite involved as it requires the
user to specify additional segments for some of the polyline instances as well as
specifying corresponding topologies for face creation.
• Another popular method for geometry creation is constructive solid geometry[16]
to form objects from the addition and subtraction of geometry elements. CSG

5.2. Related work

139

p1
2
p1
2
p1
1
p2
1

Figure 5.5: Left: A plan polygon (green) is extruded along a single segment path
(blue). Rectangular faces are created between adjacent instances of the polygon, here
verticies p1 , p2 from the ﬁrst instance and p1 and p2 from the second instance. Centre:
2
2
1
1
If the path rotates an instance, faces may not be planar. Note that the non-planar quads
are depicted here as triangles. Right: Using a more complex path, geometry with strong
horizontal lines can be created. However self-intersections and holes in the geometry
are evident in this example, such as near the roof line of this mesh, and above the
concavity in the plan.
has been used by several systems since to create urban modeling tools. Sugihara
and Hayashi[223] create roofs on orthagonal geometry by unioning roofs after
rectangular decomposition. This approach is adapted to building reconsutrction
in [128], by computing the CSG union of elements from a library of 3D roof-form
blocks.
The advantages of CSG are that manifold results are guarenteed, and that all
the output faces are subsets of the input faces. Thus if the input faces planar,
then so will the result. The disadvantage is, however, that the range of results
are limited by the availble CSG primitves, as illustrated in Fig. 5.6.

5.2. Related work

140

b

a

e

g

c
f
d

Figure 5.6: The expressivness of a constructive solid approach, given limited input
primitives (a) is limited. For example, we may wish to elongate the primative, a CSG
union operation could construct a mesh with several peaks (b). A scale operation would
also adjust the slope of the roof in an unrealistic manner (c), however we probably
prefer a result closer to the straight skeleton (d). In a second example, the union (e) is
not the same as the SS (f ), and introduces unwanted, water collecting, horizontal edges
into the roof-line. More complex examples (g) cannot be created at all, since they are
not locally similar to the available primitive.
As introduced in Chapter 2 there are a wide range of languages and grammars for specifying geometry. Many of these systems, such as CGA Shape[159], are concerned with
the combinatorial and positional aspects of the modeling, rather than the geometetric
elements. For example, CGA may specify the location of the roof, but would rely on
extrude operations to specify the mass model and other geometric routines to calculate
the roof geometry.
Several systems exist to deform existing architectural meshes into new conﬁgurations[90][36][76],
additional detail is given in Chapter 2. For example, in [90] Habbecke and Kobbelt
introduce a mesh deformation tool that constrains speciﬁed edges to remain, for example, coplanar, horizontal or vertical. The system constructs a linear system that may
be deformed in real time. These deformation tools, however, do not solve the problem
of creating geometry to be deformed in the ﬁrst place.
Previous systems have applied the straight skeleton to the modeling of architectural
roofs. Laycock and Day[169] use the SS to deﬁne roofs over arbitrary ﬂoorplans, and
adjust the positions of the verticies to create Gable roofs. Havemann[101] uses an
application of the SS with uniform negative weights, followed by an application with
uniform positive weights to create overhanging roofs. Our goals are similar to these
approaches and we contribute new extensions to the straight skeleton to avoid the need
for Laycock’s vertex adjustment and to extend the skeleton beyond roof modeling to
an interactive procedural modeling system for entire architectural meshes.

5.3. User Interface Description

141

g

c
a

b

e

j

f

i

m

k

ep
st e
g
an
or

h

ue

bl

le
rp

d
re

pu

en

e
gr

d

l

n

Figure 5.7: Three example buildings constructed in our user interface. We demonstrate multiple proﬁles on a simple plan (abcd), modeling overhangs (efghi) and anchors
(jklmn). Simple proﬁles (ab) are applied to the green and purple edges of the plan (c)
to create the geometry (d). Overhangs are deﬁned using an additional pair of proﬁle
polylines associated with every edge (ef ) to create typical roof geometry (hi). Anchors
(magenta circles) are deﬁned on the proﬁle (j) and the plan (l) to position features. In
this example the anchors position a rectangular natural step (m) with a proﬁle (k) that
creates a roof-window (n).

5.3

User Interface Description

To control the underlying application of MWSS instances, the PE system utilies a
graphical user interface. This section introduces the interface, and how it can be used
to model single instances of complex watertight architectural meshes, we call shells.
The MWSS algorithms are largely motivated by the desirable user interface commands,
and so the user interface provides a motivation for the technicalities in the following
sections. These new event types speciﬁed by the UI are explained in Sec. 5.5.

5.3.1

Overview

Our system originates from the observation that simple roofs can be deﬁned by a aerial
plan, and an angle for the roof. We combined this line of enquiry with the study of
architect’s drawings that combine plan drawings from above, and elevation images from
the four sides. The plan speciﬁes the footprint of the structure, while the observed roof
angle is often present in the elevations. Exploring this observation, one may extract
angles and heights from other locations on the proﬁle in an architectural elevation, such
as the height of the walls. However, architects typically produce a small number of
elevations, typically one for each cardinal direction, and this provides insuﬃcient detail
for reconstruction. For example when the footprint of the house contains concavities,
cardinal elevations underconstrain the resulting solid shape. The premise of the PE
system is to create solid geometry from a plan and per plan-edge proﬁles, as in Fig. 5.2.
The plans and proﬁles are evaluated by a rising sweep plane algorithm, in a manner

5.3. User Interface Description

142

Figure 5.8: The interactive interface during the design of a temple. The right
window contains the output preview whilst the left window contains the plan and the
proﬁle editors.
similar MWSS, of section 3.5. As the sweep plane rises, it carries with it an active plan
which combines the diﬀerent proﬁles to create a solid polygonal mesh.
The complete UI is available online [115].

5.3.2

Plans and Proﬁles

The complete user interface, as illustrated in Fig 5.8 and provides:
• the current plan,
• the current proﬁle,
• a 3D preview of the current architectural shell,
• tools to add, remove and move verticies in the plan and proﬁle,
• tools to associate proﬁles with plan edges,
• options to add and remove proﬁles
• options to add events to the proﬁle and plan using anchors. There are several
diﬀerent types of discrete UI events, introduced below, which are enacted as the
sweep plane rises past them.
• Finally the UI also provides standard save, load, and export functionality.
We shall continue to use the deﬁnition of a plan introduced in Sec. 3.2.1 — a linked
list of verticies that deﬁne the counter-clockwise boundaries of enclosed regions. In

5.3. User Interface Description

143

the PE system, every edge in the plane is also associated with a proﬁle. A proﬁle is
a collection of polyline segments that deﬁne a cross-section of the building through
the associated plan edge. As the user edits the plan or proﬁle, the system shows
the resulting architectural shell in a 3D preview window. The following Sec. 5.5.3
will introduce edge direction events into the sweep plane algorithm, each of which is
speciﬁed by a proﬁles vertex.
Fig. 5.7, c, shows an example a plan and two proﬁles, a & b. In the 2D plan, diﬀerent colours show the association between the plan-edges and proﬁles. Each proﬁle is
automatically assigned a colour upon creation, and the plan-edge is drawn with this
colour.
Because of the underlying sweep-plane algorithm we must constrain the proﬁles to be
monotonic in the vertical (z) direction; horizontal polylines are allowed as a special
case. The underlying procedural extrusions grow architecture upwards from an inputplan. Therefore, a downwards moving line-segment is meaningless. In order to creating
buildings with overhanging roofs, such as the temple of Fig. 5.8, there were two design
directions that could have been taken:
1. Allow the user to draw arbitrary polylines as proﬁles that can go up or down in
the vertical direction. These would be automatically decomosed into monotonic
proﬁles;
2. Force the user to explicitly model proﬁles as multiple polylines where each polyline must be monotonic in the vertical direction.
Given several examples, it became clear that when design 1 was used it was diﬃcult to
coordinate diﬀerent proﬁles, each with an overhang, to occur at the same height. This
case is relitively common, so design 2 was chosen. All the poylines in a proﬁle are,
therefore, monotonic; polylines that represent overhangs on diﬀerent proﬁles all start
from the same height. The height is marked in the user interface by a white circle, as
in Figs. 5.8 & 5.7 e & f. The height of all overhangs starting from the same elevation
can be changed by moving the position of this circle.
We will explain the process of modeling overhangs using the second example in Fig. 5.7
efhg & i. The user creates the input ﬂoor plan shown in (g). The edges in this ﬂoor
plan are color coded as either red or blue. A red edge will be extruded according to
the red proﬁle (e) and the blue edges will be extruded according to the blue proﬁle
(f). The ﬁnal architectural shell is shown in (h) and (i). The red proﬁle and the
blue proﬁle each consist of three polylines. Each of these polylines is monotone in
the vertical direction. In the red proﬁle we can see that one of the polylines has two

5.3. User Interface Description

144

Figure 5.9: A proﬁle oﬀset event simulates a non-monotone proﬁle by manipulating the active plan at the height of the event and adding an additional overhanging
region (top left). In this example the front and back edges of the roof have been disabled from taking part in the oﬀset. One proﬁle oﬀset event (a,b) may deﬁne a shared
starting height for one roof with two diﬀerent angles. Coordinating this oﬀset event between proﬁles allows for a single parameter to control the roof height (c; several heights
shown).
segments that are completely horizontal. Modeling horizontal segments is transparent
to the user, but will be handled as special case later in the implementation. Modeling
overhangs is an explicit operation. The overhang is modeled by inserting two new
polylines into both proﬁles at a certain height. In the user interface this is one atomic
insertion operation. When the user adds an overhang to one proﬁle, via a right-click
menu, then all proﬁles will obtain two new polylines at the same height. These two
polylines bound the inside and outside of the overhanging area in the active plan. The
user can independently edit the new polylines for each proﬁle, whilst only the starting
height remains synchronized. The interface allows users to disable edges so that they
do not contribute to the oﬀset boundary, an example of which is shown in Fig. 5.9.
The proﬁle associated with edges adjoining such disabled edges is speciﬁed once for the
entire oﬀset. Both the edge disable option and adjoining edge proﬁle are manipulated
via the right-click menu.
Computing these non-monotone sections of the proﬁles is somewhat involved as the
user interface does not specify the oﬀset region in absolute coordinates, but rather
relative to current edges in the active plan. Sec. 5.5.6 will introduce these proﬁle oﬀset
events, and a solution to computing the corresponding 3D meshes via sub-spplications
of the WSS to the current active plan outline.

5.3. User Interface Description

5.3.3

145

Anchors

There are several categories of UI operation that perform actions at speciﬁc locations
on the 3D architectural model being constructed. For example we may wish to position
a decorative mesh at a speciﬁc location, make local change to the active plan in order
to induce dormer windows into a roof, or we may wish divide the active plan into
separate parts at a certain height. The diﬃculty here is that these locations must
be persistant to changes in the input plan, proﬁle changes and re-calculations of the
architectural shell. This is called the persistence problem in procedural systems[140],
and we introduce anchors as a partial solution in our system.
An anchor is created, after specifying the event type, by selecting a point on the plan,
or on the corresponding proﬁle polylines. In Fig. 5.7 jklm & n, the anchors are shown
as magenta circles on a ﬂoor plan edge and a proﬁle edge. A plan anchor and proﬁle
anchor together specify the location of a feature, in this case a roof window. Fig. 5.10
shows how an anchor on the plan (a), and the proﬁle (b), may be combined to specify
a location (c). A proﬁle anchor alone speciﬁes an event at a the speciﬁed height, for
example splitting the active plan into two halfs. In either case, if the corresponding
proﬁle anchor is no longer associated with an edge in the active plan at the speciﬁed
height, then it will not be instanced. Furthermore, if the edge on which an anchor was
placed has been split, then the event may occur two or more times.

5.3.4

Plan Edits

Editing the active plan at a speciﬁc location allows a wide range of local features to be
created on the architectural shell. These edit-events are plan edits; they are speciﬁed
by a plan-edit plan and proﬁle, a plan/proﬁle anchor pair to position the edits, and a
step type. The step type speciﬁes one of two options for inserted edges into the active
plan, with diﬀerent advantages:
• Forced steps insert an arbitrary set of edges into the plan.
• Natural steps oﬀer a range of simple shapes that can be inserted, and come with
a guarantee not to cause self-intersecting geometry.
The details of the diﬀerences between these two step types are discussed later. Fig. 5.7
jklm & n show a plan edit with a forced step being used to create a roof window.
Fig. 5.11 illustrates that, as well as adding additional regions into the plan, plan edits
may also remove regions. Here we use a plan edit to specify a square portion of the
roof to be removed. This square is replaced by a square plan region, and associated

5.3. User Interface Description

146

c
b

a

Figure 5.10: Positioning a feature, c, using plan anchor a and proﬁle anchor b on
the complex surface of a bay window.

Figure 5.11: Left: The plan (solid green line) and proﬁles (blue lines) deﬁne the
shape of the structure. The anchors (orange) locate the chimney (red). A natural step
is inserted into the building at the anchored location (dashed green lines). Middle: The
ﬁnished 3d geometry, showing the proﬁles for the new edges. Right: Alternative natural
step which adds an additional rectangle into the plan (dashed green lines) to specify a
chimney.

5.3. User Interface Description

147

proﬁles, such that a chimney is formed as the sweep plane rises. If the input plan
has several repeated elements, such as bay windows or buttresses, plan edits give a
convenient tool for deﬁning the repeated plan and proﬁle once, whilst repeating it at
a number of diﬀerent anchored locations; for example the creation of the butresses of
Fig. 5.32.

5.3.5

Positioning Decorative Details

Another application of anchors is to specify the location of architectural details. Sets
of anchors can be used to mark the location of anchor points of decorative meshes. For
example the top and bottom elements in a grid of windows of Fig. 5.12. This ﬁgure
provides an example of re-using plan and proﬁle anchors to ensure that the decorative
meshes are positioned in a regular pattern. By using a pair of anchors to specify
the top and bottom of each window mesh on the facade, the user speciﬁes that the
windows have a particular height. In general, we may use tuples of anchors to specify
the position of control bones to provide a variety of deformations to decorative meshes.
The mesh deformation takes place using per-bone vertex weights[131], imported into
the PE system in the MD5 ﬁle format. Typically these are created using an external
modeling tool; the examples in this chapter were created with Blender[73].
A user interface parameter allows the users to specify the scale of the decorative meshes
on the architectural shell. This is useful when working with decorative meshes from a
library with varying scales.
While pairs of anchors can be used to specify points on the architectural shell, individual
faces of the shell can be identiﬁed by adding tags to the appropriate proﬁle segement.
These are shown as small triangles in the user interface, a cyan coloured example is
shown in Fig. 5.13. After the complete manifold is computed, the faces that were
generated from the speciﬁed proﬁle segment are post-processed in a particular way, for
example to add tiles to the roof.

5.3. User Interface Description

148

Figure 5.12: Above: Plan (blue) and proﬁle (green) anchors deﬁne the attachment
points (purple) for decorative meshes. By sharing plan and proﬁle anchors, the attachment points may be constained to the same horizontal or vertical line. Below: The
window and pillar meshes are deformed by the attachment points to increase the variety
in the model.

5.4. Splitting the active plan

5.4

149

Splitting the active plan

A subdivision event splits the area enclosed by the active plan into several sections at a
particular height. It is used to model buildings that rely on an internal structures, such
as “saw tooth” roofs. The user deﬁnes a set of oﬀsets, which bound the newly created
regions on the active plan. As with proﬁle oﬀset events, the challenge in implementing
subdivision events is in creating a robust result for all possible active plan topologies;
again a second application of PE are used to deﬁne these oﬀset region boundaries.
When creating a subdivision event the user speciﬁes the following using the interface
of Fig. 5.13:
• A height for the subdivision event, speciﬁed by a proﬁle anchor.
• A map that deﬁnes the new proﬁles in the subdivision application of procedural
extrusions, from the existing proﬁles.
• A set of tags applied to these new proﬁles which specify the new regions of the
subdivided plan.
• A map that speciﬁes new proﬁles for the new regions.

5.5. Computing Procedural Extrusions

150

Figure 5.13: The subdivision event UI. Left: The plan and subdivision proﬁle. Right:
The UI for speciﬁying the new proﬁle map, and tags for specifying the new regions and
associated proﬁles for their side, bottom and top edges. Inset: The resulting 3D model.

5.5

Computing Procedural Extrusions

Given the UI input, this section details the procedural extrusion system which generates
the output geometry. It begins by deﬁning the terminology used, the inputs and the
outputs of the main algorithm. The section continues with a description of the diﬀerent
events generated automatically and by the user, and how each event type is computed.

5.5.1

Deﬁnitions

We shall use the terminology of Chapter 3, breiﬂy introducing it again, and extending it
where appropriate. Broadly, the inputs are the plans and proﬁles deﬁned, for example,
by the UI, while the output of the system is an architectural shell in 3d Euclidean
space with a xyz world coordinate system. The up direction is along the z axis.
A (ﬂoor) plan is a planar subdivision (a straight line planar embedding of a planar
graph) that divides a plane into inside and outside regions. A plan has corners and
oriented edges. A plan is embedded in a plane parallel to the xy-plane (the ground
plane), so that all corners of a plan have the same z (height) value. We require that the
boundaries of a plan are a non-intersecting collection of oriented polygons. The inside is
on the left-hand side of each oriented polygon edge. The polygons are oriented counterclockwise, but polygons describing holes are oriented clockwise. Additional bounded
regions may be recursively located inside a hole. The jth polygon is described by nj
polygon corners cj ∈ R3 with 1 ≤ i ≤ nj . Each corner cj is connected to the next
i
i
corner (according to the polygon orientation) by an implicitly deﬁned edge, ej . In the
i
following, indices should be treated cyclically, such that a polygon with corners cj , cj ,
1
2

5.5. Computing Procedural Extrusions

151

and cj , the corner cj means cj .
3
4
1
Each edge in a plan is associated with a direction plane, dpj , which contains the edge.
i
Since we will be using it to evaluate a MWSS, it is deﬁned by an angle θ such that
−π/2 ≤ θ ≤ π/2. A vertical direction plane has θ = 0, whilst a direction plane oriented
towards the inside (outside) satisﬁes θ > 0 (θ < 0 respectively). The angle is measured
between the direction plane and a vertical plane that also contains the edge, as in
previous Fig. 3.28.
A proﬁle is a set of polylines that is used to control the direction plane of an edge.
A polyline is modeled in a local 2d wz-coordinate system and consists of a list of m
points ti . The location of point i is (ti .w, ti .z) and we require, for monotonicity, that
ti .z ≤ ti+1 .z. The polyline deﬁnes m − 1 angles, θ1 ..θm−1 . The angle θi is calculated as
the clockwise angle between a vertical line and the line ti to ti+1 . The angle lies in the
range −π/2 ≤ θi ≤ π/2, and the ﬁnal angle is constrained such that θm−1 > 0. This
ﬁnal condition ensures that the MWSS terminates.

5.5.2

Overview

This section describes the input, output, and an outline of the PE algorithm.
Input
The input of the algorithm is a (ﬂoor) plan, called the input plan, proﬁles associated
with the edges of the input plan, proﬁle oﬀset events, and anchor events. Anchor events
specify the location of plan edits, a mesh instance or subdivision event.
Output
The main output of the algorithm is an architectural shell (3d mesh) in the xyz world
coordinate system. In the non-degenerate case the shell is watertight and two-manifold.
The architectural shell is a polygonal mesh stored in a half-edge data structure. The
half-edge data structure stores a set of vertices in R3 , a set of input edges and skeleton
arcs between the vertices, and a set of planar faces which may contain holes. Faces are
deﬁned by a counter-clockwise ordering of arcs.
Outline
The algorithm is an extension of the MWSS algorithm introduced in Chapter 3. As
well as the automatic events that occur in the MWSS, the event queue also contains

5.5. Computing Procedural Extrusions

152

user interface events. As before the core algorithm repeatedly takes the next event
from the queue, allowing it to update the active plan as well as insert additional events
into the queue if necessary. Fig. 5.14 gives the algorithm in pseudocode form.
Main begin
Q = new priority queue;
sweepZ = 0;
foreach corner c in active plan do
CreateGIEEvents ( c, Q );
CreateUserEvents( queue Q)
while !Q.empty() do
event = FindNextEvent(Q);
event.updateActivePlan();
event.updateEventQueue(Q);
foreach edge e in input plan do
ReconstructFace (e);
end
CreateUserEvents( queue Q ) begin
foreach Proﬁle p in user proﬁles do
foreach ProﬁleOﬀsetEvent poe in p do
Q.insert (new ProﬁleOﬀsetEvent(poe) );
foreach vertex v in p do
Q.insert (new EdgeDirectionEvent(p, v) );
foreach AnchorEvent ae in user anchor events do
Q.insert (new AnchorEvent(ae) );
end

Figure 5.14:
Fig. 3.14

Pseudo-code for main loop of the PE algorithm, an extension of

The priority queue orders events by their z height, thus simulating the rising sweep
plane. By allowing additional edges to be added by the user to the rising active plan,
the MWSS is extended to describe a wide range of architectural forms. Therefore the
PE algorithm is equivilant to a sucessesion of MWSS skeletons stacked on top of each
other, along the z axis.
Once all the events in the priority queue have been processed the algorithm terminates. The skeleton faces deﬁned by the events are post processed and output. This
post processing involves identifying holes, positing decorative meshes and applying the
textures speciﬁed by user tags.
Data structures
The ﬁrst signiﬁcant data structure is th plan data structure, which encodes the active
plan on the sweep plane, as in [68] and Chapter 3. This structure is a doubly linked
list of corners. Each corner has a pointer to the next corner, the previous corner, and
a pointer to its previous and next direction planes, Fig. 5.15. At the beginning of the

5.5. Computing Procedural Extrusions

153

corners

direction planes

direction plane pointers

output arcs

linked list of corners
Figure 5.15: The plan data structure, shown part way through the sweep. A linked
list of corners describes each enclosed region. In addition every corner has a reference to
the previous and next direction planes, each associated with an edge on the active plan.
Skeleton arcs are the output by events, and are used to reconstruct the 3D architectural
shell.
algorithm the input plan is speciﬁed by the building ﬂoorplan. During the algorithm,
the sweep rises from the input plan and this data structure is updated to encode any
changes to the active plan.
The second important data structure is a priority queue, Fig. 5.14 Q, that sorts events
by ascending height. GIE events are automatically created, while user events (edge
direction events, proﬁle oﬀset events and anchor events) are deﬁned by the user.

5.5.3

Description of Events

As the sweep plane ascends it encounters several diﬀerent types of events, introduced
in this section. The two major classes of events are those automatically inserted to
ensure the area on the active plan remains well formed, and those speciﬁcally inserted
by the user.
The automatic events are the general intersection events — our generalisation of split,
edge[68] and vertex events[65], as introduced in Sec. 3.2.4. These events are created
whenever a new event is added to the active plan.
The user events are speciﬁed in various portions of the user interface. There are ﬁve
types of UI event:

5.5. Computing Procedural Extrusions

154

• Edge direction events occur at proﬁle polyline verticies. Such an event updates
the direction plane associated with a set of edges in the active plane
• Proﬁle oﬀset events occur at heights speciﬁed by user edits. Intuitively, a proﬁle
oﬀset event results in additional inside regions being added to the active plan at
the speciﬁed height.
• Anchor events come in a further three varieties:
– Plan edit anchors modify the active plan to insert architectural features
such as chimneys, or dormer windows into the shell.
– Mesh anchors specify attachment points for decorative meshes.
– Subdivision event anchors divide the active plan into a number of pieces.
They occur over the entire active plan at a height given by the anchor.
We continue to detail each of these event types.

5.5.4

Generalized Intersection Event

The GIE is an automatic type of event, introduced previously in Sec. 3.2.4. Here we
introduce the implementation details required for a robust implementation in a ﬂoating
point environment. We chose a double-precision ﬂoating point environment, instead
of an exact computation paradigm, such as CGAL[1], as it was both simpler to work
with, and faster — a beneﬁt for the rapid computation of large environments. The
main robustness tool we use are epsilon tolerances.
Generalized intersection events perform topological changes on the active plan to ensure
that it never self-intersects as the sweep plane ascends. These events are automatic,
and inserted whenever new edges are added to the active plan. For example, all user
speciﬁed events that add edges to the output, will also check for potential GIE events
involving those new edges.
Chapter 3 introduces the limitations of the GIE. Indeed there are many MWSS situations in which the GIE does succeed in active plan to remain well formed. Dispite
this we found the GIE remarkably robust solution to the complex events created by
architectural plans and proﬁles.
Input: The input of a generalized intersection event is a point l ∈ R3 , and a set of
three or more direction planes, f , whose associated direction planes intersect at l. The
point l is calculated as the center of the clustered volume.
Output: The output of a generalized intersection event is an updated active plan.
This represents the bounded region on the sweep plane after the event.

5.5. Computing Procedural Extrusions

155

a
b

b
e

(abcde)
c
d

p

a
(aop)

c

e

d
(abcdlmno)

o

l
n

m

k

f
g
(ghi)
(defgijkl)
i
j

h

Figure 5.16: Left: Five faces forming an intersection event. Right: Events can
interfere with each other if they have the same height, in this case the four points share
a roof ridge.
Epsilon Tolerances
As part of the GIE we remove any out of bounds edges from the edge set, f . Because
the intersections are detected using unbounded direction planes, there may be edges in
f that do not approach l on the active plan. Such edges are removed from f .
It is possible for the line deﬁned by the intersection of the direction plane and the sweep
plane to pass close to l, however the line-segment deﬁned by the associated active plan
edge may not. A small epsilon range, δ1 , expands the active plan edge and ensures
that collisions occur reliably. On our inputs of footprints measured in meters we found
δ1 = 10−5 a suﬃcient margin. If δ1 becomes too large, the chances of the extended
edges intersecting with unintented geometry increases.
In addition, we use expanded bounds for intersection location clustering. This addresses
two stability problems:
• In symmetrical inputs made up of regular polygons, such as often found in architectural plans, it is very common for more than three direction planes to meet
at a point. To avoid degenerate output in a ﬂoating point situation it is necessary to identify intersections whose locations are close together, and treat these
as a single event. Fig. 5.16, left, illustrates such an example of such a building
footprint.
• Second, direction plane intersections that are far apart from each other can interfere if they are close to one other in height, Fig. 5.16, right. It is also necessary
to detect and handle these events at the same height to resolve the parallel consecutive edge degeneracies.
To address the two previously mentioned event detection problems, we cluster the
events in both vertical and horizontal directions. We poll the priority queue to collect
all intersection events whose height, z, is within some threshold, δ2 , of the initial event.

5.5. Computing Procedural Extrusions

156

δ2
δ3

Figure 5.17: When an event is processed we simultaneously extract all intersection
events within a height of δ2 . Then we cluster all events that are within a cylinder of
radius δ3 and height δ2 .
Second, we cluster all the events according to their location after projection onto the
xy sweep plane. The clustered volume is therefore a cylinder of radius δ3 and height
δ2 . Fig. 5.17 illustrates this clustering step. We found that values of δ2 = 10−4 and
δ3 = 10−6 gave the best reliability. There are certain pathological inputs which cause
this clustering stage to fail. An example would be a row of events, each within δ2 of
another, which could contain an arbitrary number of events.
PCE resolution
As introduced in Sec. 3.3.2, the MWSS is poorly deﬁned in several situations. Diﬀerent
modeling choices lead to diﬀerent ambiguous-case resolution strategies, Fig. 5.18. In
particular when modeling architecutre the parallel consecutive edge degeneracies need
to resolved in an architecture viable way. We found that the volume maximizing approach tended to be the most desirable default for architecure situations; we take the
lowest valued θ when resolving the PCE. We hypothesise that this case is observed
most commonly since it maximizes the space inside the building.

5.5. Computing Procedural Extrusions

157

Figure 5.18: Two identical bay windows that lead to the same two events (red circles)
involved in an degenerate PCE situation (red line). To resolve the PCE situation,
a single edge must be chosen to replace the others. The building on the left (right)
resolves the ambiguity using the volume maximizing (respectively minimizing) priority
technique. The resulting unused section of the original proﬁle is shown in orange. Note
that in each case, two ambiguous events occur at the same height, and must create
globally consistent output.

5.5. Computing Procedural Extrusions

5.5.5

158

Edge Direction Events

A set of edge direction events are created for each proﬁle. An edge direction event
updates the angle and direction planes of a set of edges. There are two types of
edge direction event, standard and near horizontal. Standard edge direction events are
constructed from a single angle in the plan, while a near horizontal edge direction event
is constructed from two consecutive angles and a distance. These values are calculated
from the proﬁle polyline.
Standard edge direction events
Input: A set of edges, f , in the active plan, each associated with the same proﬁle and
a single new angle for all the edges, γ.
Output: A new active plan which replaces the original.
For each of these edges ej ∈ f , we update the associated direction plane by setting its
i
j
angle, θi to γ. The implicit edge, ej , continues to propagate over the sweep plane with
i
a new speed, as deﬁned by the new angle.
Near horizontal edge direction events
When the angle associated with an edge, θ, approaches ±π/2, standard edge direction
events face a problem as two parallel (horizontal) direction planes do not intersect to
form a line. Additionally, as the angle approaches these limits the algorithm computes
the intersections of near coplanar planes, causing numerical instability. To resolve this
issue, as illustrated in Fig. 5.19, we use a secondary application of a MWSS to calculate
the horizontal section of the proﬁle. To do this we ﬁrst increase the angles according
to the length of the horizontal proﬁle segement, then calculate the secondary MWSS,
and ﬁnally project the result onto the original sweep plane.
Input: A set of edges in the active plan, f , associated with the proﬁle, a distance, d,
a direction angle, γ, and a following angle, ζ. The angle γ ≈ π/2 (γ ≈ −π/2) speciﬁes
the direction of the horizontal as towards the inside (respectively outside) of the active
plan. ζ speciﬁes the angle of the following non-horizontal edge event.
Output: A new active plan which replaces the original.
First we create a temporary plan as a copy of the active plan. For each edge in the
j
original plan, ej , and associated angle θi , the temporary plan has an edge Eij , and
i
associated angle Θj . Secondly we update the angles in the temporary plan according
i
to the following mapping:

5.5. Computing Procedural Extrusions

a

b

c

159

d

Figure 5.19: The horizontal section desired (b) can be created by a secondary application of a MWSS to calculate the oﬀset in the given direction. After ﬂattening (c)
unchanged edges (red, d) are ignored.





tan−1 (d)
Θj =
− tan−1 (d)
i


0

if ej ∈ f and γ > 0
i
if ej ∈ f and γ < 0
i
otherwise

The secondary MWSS extrudes the temporary plan for a height of one unit. The
temporary active plan is projected onto, and replaces, the active plan in the original
procedural extrusion instance. That is, ej is replaced by Eij if it exists in the updated
i
j
plan, otherwise ei is removed from the active plan. The location of Eij is projected onto
the original active plan. Finally the values of θ in the original skeleton are updated
using the mapping:
ζ if ej ∈ f
j
i
θi =
j
θi otherwise
Occasionally multiple edge direction events occur at the same height. In this situation
the direction events are sequenced by the order of user creation.

5.5.6

Proﬁle Oﬀset Events

Proﬁle oﬀset events specify the start of overhangs. The diﬃculty of specifying and
handling proﬁle oﬀset events comes from the procedural deﬁnition. While it is easy
to specify overhangs for a given region, the geometry must produce good results for a
wide range of building footprints, and adjust itself according to the user editing the
plan. Our technique must procedurally perform changes to the active plan without
creating badly formed self-intersections.
At a proﬁle oﬀset event, an additional inside region, called an oﬀset region, is inserted
into the active plan (see Fig. 5.20). Two oﬀset boundaries are grown from the active
plan to enclose the new oﬀset region. We introduce new edges and corners into the
active plan to represent this newly enclosed region on the sweep plane. The new edges
are classiﬁed as inside, outside, or side, depending if the edge stems from the ﬁrst

5.5. Computing Procedural Extrusions

160

a
d
c
b

g
f

e

j

i

h

Figure 5.20: Some meshes that can be computed from an input plan (a) using proﬁle
oﬀset events. Buildings b and c are shown in two orientations. By creating two oﬀset
boundaries (e) that deﬁne an oﬀset region (h), an overhanging roof (b) can be generated
from an arbitrary plan (a). If two edges are disabled in the proﬁle oﬀset event, openended roofs can be created (c,f,i). Finally, by oﬀsetting inside the active plan, walled
roofs can be created (d,g,j).

5.5. Computing Procedural Extrusions

161

d

c

b

a

Figure 5.21: The recursive application of procedural extrusions (b) to a plan (a)
from Fig. 5.20 (c). The faces between z = 1 and z = 2 are projected onto the primary
active plan (c), before being merged (d). Zero area faces (blue and purple) are removed,
and proﬁles assigned based on the origin of the edge. In (d) green edges are assigned
prof ile inside, red prof ile outside and blue prof ile side.
boundary, the second boundary, or are at the side-edge of an oﬀset region.
Input: A map for each edge in the active plan, ej to a tuple, tj = {disabledj ,
i
i
i
j
j
j
j
dist insidei , dist outsidei , prof ile insidei , prof ile outsidei } and a single
prof ile side. The variable disabledj is a boolean value that speciﬁes if the oﬀset region
i
associated with this edge is present in the output; dist insidej and dist outsidej are
i
i
real values that deﬁne distance and direction from the active plan of the inside and
outside oﬀset boundaries; prof ile insidej , prof ile outsidej and prof ile side are proi
i
j
ﬁles. We require that all values of dist insidei and dist outsidej have the same sign;
i
a positive (negative) sign indicates an oﬀset (respectively inset) of the active plan. To
ensure proper topology on the active plan, the distance, dist inside, is constrained to
be non-zero.
Output: The output of an oﬀset event is an updated active plan, typically with the
additional region deﬁned either inside or outside of the input active plan.
We create a temporary plan as a copy of the primary (input) active plan. For each edge
in the primary plan, ej , the temporary plan has an edge Eij , and an associated proﬁle,
i
j
prof ile recursivei . Edge Eij is constructed by projecting ej onto the plane z = 0. The
i
j
j
−1
proﬁle prof ile recursivei deﬁnes the angles Θi = tan (dist insidej ) at z = 0, and
i
Θj = tan−1 (dist outsidej ) at z = 1. We execute a recursive application of procedural
i
i
extrusions using the temporary plan as input. It is executed from height 0 to 2, to

5.5. Computing Procedural Extrusions

162

create a temporary output shell. Before continuing we correct the orientation to ensure
that counter-clockwise loops enclose an inside region; the orientation of each face in
the shell is reversed (the counter-clockwise ordering of vertices in the half edge data
structure is reversed to a clockwise ordering). Faces of the shell between the planes
z = 1 and z = 2 are projected onto the primary active plan, forming the oﬀset region.
This process is illustrated in Fig. 5.21.
The projection associates each tuple, tj , with an oﬀset region in the primary active
i
plan. The entire oﬀset region is bounded by the projected edges, r. Additionally the
projection deﬁnes a 1:1 mapping between the new edges, ek ∈ r, and a subset of the
l
k
temporary shell’s arcs Al . We remove from the primary active plan any edges in r that
enclose an oﬀset region of area 0 or that are associated with a tuple containing a value
of disabledj = true. We update the proﬁle, prof ilej , associated with each edge, ej , in
i
i
i
the primary active plan according to the function:


prof ilej

i


 prof ile insidej
i
prof ilej =
i
 prof ile outsidej

i



prof ile side

if ej ∈ r
i /
if Aj lies in the plane z = 1
i
if Aj lies in the plane z = 2
i
otherwise

Finally we merge adjacent parts of the oﬀset region to avoid self-intersections. We
remove the corresponding edges and corners from the active plan.

5.5.7

Anchor events

Anchors deﬁne the location of features, such as plan edits, decorative meshes, or subdivision events. The plan and proﬁle anchors speciﬁed in the user interface are used in
diﬀerent combinations to deﬁne either an event that happens at a certain height, or an
event that happens at a particular point on the mesh. Subdivision events are triggered
at a certain height by a proﬁle anchor on an active proﬁle. In contrast, plan edits and
decorative meshes are placed at points by both a proﬁle and plan anchor.
Finding parameterized locations on a surface that are robust to subsequent edits in
the ﬂoor plan is challenging. The manifold of the structure may not reach any given
point in space because, for example, the anticipated active plan edge may have been
removed by previous events. Therefore, to position features in a manner robust to plan
and proﬁle edits the user positions a pair of two dimensional anchors, Fig. 5.10.
The proﬁle anchor deﬁnes a plane parallel to the sweep plane, at the anchor’s z height.
When the sweep plane reaches this height we trigger height-events. If there is an

5.5. Computing Procedural Extrusions

163

associated plan anchor, that is evaluated upon the current active-plan to give the xy
coordinates.
We allow the user to select from two types of plan anchor — relative and absolute. A
relative anchor’s location is a fraction of its length on the active plan edge, Fig. 5.22
middle row, left. If the edge is represented in the active plan at the speciﬁed height,
the feature is instanced. Absolute anchors are deﬁned on an input plan edge, and
deﬁne a plane perpendicular to this edge, Fig. 5.22 bottom row, left. The intersection
of this plane and the corresponding edge in the active plan at the height speciﬁed by
the proﬁle anchor deﬁnes the instance location. Because an active plan edge may grow,
it is possible to position absolute anchors beyond the ends of the input plan edge.
Relative and absolute anchors each deﬁne a diﬀerent co-ordinate system on faces of
the architecural shell, Fig. 5.22 centre column. Each system is a more natural way to
express certain patterns with diﬀerent geometric properties:
• Relative plan edge anchors: if an edge is present at the height, the operation will
occur at least once. If a split event has taken place on the corresponding edge,
it may take place more than once, 5.22, middle row, right. This makes relative
anchors suitable for features that must always exist, however having multiple
instances of certain features may be inconvienient.
• Absolute plan edge anchors: these may occur once or zero times at a certain
height. At a certain height the corresponding plan anchor may no longer deﬁne
a perpendicual plane that intersects the corresponding edge in the active plan.
Hence the absolute anchors may not be suitable for referencing features that must
exist, 5.22, bottom row, right.
It is also desirable to be able to position features on the surfaces created by plan edits,
introduced in the following section. In this situation we may deﬁne plan anchors for
the new edges introduced by the plan edits, Fig. 5.23. We translate instances of the
proﬁles associated with the plan event by the height of the event. This also moves the
associated proﬁle anchors. These anchors may deﬁne additional plan edits, leading to
a possibly recursive sequence of plan edits.

164

relative plan anchors

anchors

5.5. Computing Procedural Extrusions

x2
y2

absolute plan anchors

x1
y1

Figure 5.22: Top row: plan anchors (green) and proﬁle anchors (blue) combine
to locate a feature (purple). If the edge is not in the active plan at a given height,
the feature may not be instanced (red). Middle row: Relative plan anchors deﬁne a
1
2
proportional coordinate system relative to the input plan edge’s length, x1 = x2 (left).
y
y
However some features may be repeated (right). Bottom row: Absolute plan anchors
deﬁne a rectilinear grid over the shell, however they may not be always instanced (red).

5.5. Computing Procedural Extrusions

165

α

Figure 5.23: A plan edit may be deﬁned by a plan segment and a proﬁle (left). The
geometry arising from the edit may be parameterized in several ways, here we show the
use of relative plan anchors (middle). The proﬁles associated with the plan event are
oﬀset by some value, α, such that feature locations are positioned relative to the start
of the plan event (right).

5.5.8

Plan Edit Events

Plan edits introduce discrete changes to the active plan at speciﬁed heights. We describe how plan edits operate eﬃciently and detail two methods to deﬁne them.
Input: Plan and proﬁle anchors deﬁnes the location, or locations of the step. In
addition the step type (natural or forced), and step geometry is speciﬁed. Natural
steps have an additional distance paramater.
Output: The output of a plan edit event is an updated active plan, with its boundary
altered by the step.
When performing a plan edit, some edges are deleted, some edges are moved, and some
edges are inserted, Fig. 5.24. The new edges are at the height of the current sweep
plane.
Our user interface oﬀers two types of plan edits. Inserting an arbitrary shape gives
the largest variety of geometric designs. However these forced steps oﬀer no guarantees
that the resulting active plan will not self intersect and create an invalid topology. The
challenge comes again from the procedural nature of our approach and the fact that
the edit has to work for all input plans. Natural steps oﬀer a solution to this problem
by using a recursive application of procedural extrusions to insert edges into the active
plan.
Natural steps are calculated on the active plan at a given height by amending a small
(typically 10−3 by 10−3 ) protrusion. This is oﬀset by a recursive application of procedural extrusions such that it does self intersect, Fig. 5.25, similar to the edge direction
events of Sec. 5.5.5. This recursive PE application is constructed by assigning θ = 0
to all edges not part of the feature, and a user deﬁned θ to those edges in the protru-

5.5. Computing Procedural Extrusions

166

a

b

c
Figure 5.24: Inserting a plan edit into the active plan during execution. a) The plan
data structure (blue dots, green arrows) implicitly deﬁnes the active plan (cyan). b) To
insert new edges into the active plan, corresponding edges are linked into the plan data
structure. c) The resulting architectural shell.

a

b

d

e

c

f

Figure 5.25: Given an intricate plan, calculating a robust perturbation is challenging. Forced steps are positioned at the location of the anchors (a, orange). These
are combined with the boundary. However many geometry artifacts are undesirable (c,
red) in an architectural situation. Given natural steps at certain positions (a, orange),
small changes to the boundary are made (d), which are then grown (e) using a recursive
application of procedural extrusions, to create more natural geometry (f ).

5.5. Computing Procedural Extrusions

167

Figure 5.26: Given a natural step feature location, a, we may insert a small protrusion, d, intro the active plan. It is possible to assign weights (black arrows) to the
edges in such a way that the geometry becomes disconected. This changes the genus of
the active plan, and creates a suitable footprint for a butress or similar (d).

a

b

c

d

Figure 5.27: If we combine an step towards the interior of the active plan with a
genus change, we can create a suitable plan edit to represent a chimney or similar.
Note that the length of the black arrows indicates the relative speeds of the natural step
oﬀset.
sion. The resulting temporary active plan is calculated at a speciﬁc height, and this is
incorporated into the original active plan. The new edges in the active plan have the
relevant proﬁles assigned to them.
We have descovered that natural steps can create a wide range of geoemtry in this
robust manner. Butresses and other disjoint regions can be created by growing the
protusion in such a manner that it disconnects itself, Fig. 5.26. The chimney plans
of Fig. 5.11, can be be grow by combining this disjoint region with an inwards step,
Fig. 5.27.

5.5.9

Mesh Anchors

In order to add intricate details to the architectural shells, anchors may also be used to
position decorative meshes. A range of simple parameterizations is given by positioning

5.5. Computing Procedural Extrusions

168

Figure 5.28: The four example meshes used in the evaluation. The meshes are parameterized via control points (blue and green circles) and can be instanced to diﬀerent
sizes.
a number of bones which deform the mesh. For example we can increase the height of
a pillar without deforming the capitals, as in Fig. 5.28, left.
Input: A mesh with n bones, a scale factor, g, and n anchor locations, where n ≥ 1.
Output: As the sweep plane passes, the location and orientation of each anchor is
recorded. During the post processing stage, if all n anchors are recorded, the mesh is
instanced with the scale factor g applied to each bone.

5.5.10

Subdivison Events

We may also wish to subdivide a given primary active plan into a number of discrete
areas. Like proﬁle oﬀset events these occur over the entire active plan a speciﬁc height,
but are speciﬁed in the UI using proﬁle anchors rather than the proﬁle polylines. A
recursive PE application is again used to ensure a robust maniulation of the active
plan, Fig. 5.29. The boundaries of these new subdivision regions are then assigned
proﬁles corresponding to a combination of their originating primary active plan edge
proﬁles and their classiﬁcation as top, bottom or side edges in the subdivision output
shell.
Input: A map from each proﬁle present on the active plan to a subdivision proﬁle, m, and a set of tags, tx ∈ t0 ..tt max, attached to subdivision proﬁle segments

5.5. Computing Procedural Extrusions

169

Figure 5.29: The subdivision of the primary active plan is triggered at height by a
proﬁle anchor (left: grey circle) into two new regions to create a sawtooth roof. Given
the primary proﬁles (left: purple green orange), the map m speciﬁes the subdivision
proﬁles, (right, arrows), from which we can calculate the subdivision PE (right). The
result is projected back to the original active plan, replacing the original geometry, and
assigned new proﬁles. Finally the original sweep plane continues to rise, creating the
ﬁnal mesh (left).
with properties, (prof ile bottom, prof ile top, prof ile side, merge bottom, merge top,
merge side)x . The map is speciﬁed such that m(prof ile1 ) = prof ile2 , where prof ile1
is a proﬁle in the primary active plan before the subdivision event, and prof ile2 is a
subdivision proﬁle. The boolean values, merge bottom, merge top, merge side, specify whether the subdivision region should be merged with the corresponding abutting
region. The tags, tx , are optionally assigned to a set of polyline segments in the
subdivision proﬁles to mark faces in the subdivision shell, Fig. 5.29. The proﬁles,
prof ile bottom, prof ile top and prof ile side are assigned to the newly created subdivision regions in the primary plan.
Output: The output of a subdivision event is a new primary active plan.
Each edge in an output shell can be classiﬁed as top, bottom or side according to to
how it was created. Horizontal edges created by the input plan or edge direction events
are classiﬁed as top or bottom, depending on their orientation, while all other edges in
the output shell are classiﬁed as side.
We create a new, recursive application of procedural extrusions, the subdivision application. Initially this is a copy of the primary active plan, translated to height 0. We
update the proﬁle associated with each edge in the subdivision active plan according
to the map, m. We then execute this instance of procedural extrusions to create a 3d
shell. Each face in the subdivision shell may have a subdivision tag, tx associated with

5.5. Computing Procedural Extrusions

170
α

β

γ
Figure 5.30: We may use diﬀerent proﬁles to divide an irregular plan into regions
deﬁned by relative or absolute measures. Above: by assigning the angle on the proﬁle
of one edge to be twice the speed (red) of another (purple) we may create a region of
1
relative size 3 = α (top left, pink). Below: By only using the lower section of a proﬁle
β
curve, an absolute subdivision of γ units may be created.
it, which speciﬁes how it is merged into the primary active plan, and which proﬁles the
new edges have.
Each secondary PE face is projected it onto the primary active plan, possibly combining
with adjacent regions according to the merge tags associated with tx . The proﬁles of
these new regions on the active plan are given by the , prof ile bottom, prof ile top and
prof ile side members of the tuple.
We note that subdivision events are a generalisation of proﬁle oﬀset events. That is, it
is possible to create a proﬁle oﬀset event using a subdivison event. However subdivision
events cannot be easily incorpriated into the user interface proﬁle curves, and are much
more involved for the user to user because the speciﬁcation of m and tx .
Subdivision events are a ﬂexible method of creating relative or absolute portions of a
plan. By assigning proﬁles with angles of a certain ratio, we can split the active plan
into relatively sized areas, Fig. 5.30 top. Alternately we can only use a certain polyline
segement of the proﬁle to create an area of absulte dimension, Fig. 5.30 bottom. By
combing both these techniques, a wide range of shapes can be created. Fig. 5.31 gives
an example of a relative subdivision event in a modeling context.

5.6. Evaluation

171

Figure 5.31: A procedural model that creates a row of houses from a spline. In
this case the street was generated by four points deﬁning the street’s curve. Seed points
were grown using another application of the skeleton to create the building footprints.
Relative subdivision events were used to split the roof plan into three areas.

5.6

Evaluation

Given the PE system consisting of the user interface, and the algorithms to process the
user speciﬁed events into an architectural shell, we continue to evaluate the usefullness
of the system. Initial results such as Fig. 5.32 shows many typical architectural shells
that are not possible using just the straight skeleton, or extrude operations alone.
The earlier Fig. 5.31 also illustrates how we may generate architecure alone a curved
street, a challenge for systems such as CGA Shape. We can also create buildings with
horizontal roof overhangs, such as Fig. 5.33. The alcoves and columns illustrate how
disconnected regions can merge together and interact. This is possible because the
MWSS can grow as well as shrink, unlike the SS, which can only shrink.
More eccentric uses of the PE system can also be imagined. Many other designed forms
contain the strong horizontal edges that we exploit here. We can rotate the plan so
that we may model other architectural features such as windows or moldings, Fig. 5.34.
As an illustration of the ability to compute extrusions on complex plans we may decide
it is desirable to use a thresholded image as a plan, as in Fig. 5.35.
However, in order to perform a more objective evaluation of the PE system, three
diﬀerent approaches were taken. Firsly, Sec. 5.6.1 we examine the use of PEs as an
automated GIS procedural modeling system, secondly Sec. 5.6.2 describes our experi-

5.6. Evaluation

172

Figure 5.32: From top, left: buttress, dormer windows, ﬂying buttress, bay windows,
curved plan, eight faces meeting on a symmetrical footprint with a chimney, hipped roof,
curved roof, a horizontal overhang, an overhanging gable, standard gable and interior
dormer windows

5.6. Evaluation

173

Figure 5.33: Inset: the output of our procedural extrusions using a complex footprint, horizontal sections and plan edits. We are able to create pillars, covered parking
and alcoves respectively. Main: A procedural condo with roof texture surrounded by
procedural trees

5.6. Evaluation

174

Figure 5.34: Using a creative set of proﬁles, a wide range of architectural features
can be created. By setting the input in a diﬀerent plane, various windows may be
extruded.

Figure 5.35: A thresholded image (inset) was used as the plan, with one of two
proﬁles randomly assigned, to create this artistic image.

5.6. Evaluation

175

ences of PEs as an interactive tool. Finally Sec. 5.6.3 describes the use of the PEs by
artists, and documents their opinions of the system.

5.6.1

GIS Evaluation

In order to evaluate the usefullness of the PE system for procedural modeling, we developed and evaluated a tool that generates 3D meshes given a Geographic Information
System dataset of building footprints.
GIS User Interface
To generate and apply appropriate proﬁles to the footprints, we developed a secondary
GIS UI. The graphical interface allows users to to apply sets of proﬁles and anchors
to existing plans semi-automatically. Given a set of ﬂoorplans from a GIS or similar
database, Fig. 5.36, the user can specify several machines to assign proﬁles and anchors to each building plan. Each machine deﬁnes a certain style of building, such as
victorian, industrial or dutch. The tools to assign machines are:
• Directly: this sets the assigned machine to all the selected plans.
• Painting: after selecting a set of plans to paint, the user selects a machine type
from a pallete, a brush size, and is then able to assign the machines to proﬁles
by painting over the centrum of each plan with the brush.
• By size: After selecting a set of plans, the user can execute a program that assigns
machines based on the area enclosed by the ﬂoorplans. For example, the smallest
buildings may become garden sheds and the largest become factories.
• Randomly: The user is given an option to select a fraction of the currently selected
plans randomly. This allows, for example, 10% of the plans in a particular area
of the city are assigned machines to create victorian properties.
Each machine that has several items of meta-data derrived from the GIS system to
enable the assignment of proﬁles to each edge, and other features described by the
anchors. The most important datum is an orientation label applied to each edge. This
is assigned by an angle computed by orienting the building to the nearest street and
mapping the normal vectors of the footprint edges to the unit disk. We assign labels
for the front, left, right and back of the building, Fig. 5.38. Furthmore short edges at
the front of side of the building are assigned the appropriate proﬁle for their direction.
These labels are then mapped by each machine onto proﬁles.

5.6. Evaluation

176

Figure 5.36: Typical GIS data. In this case this is a subset of the ﬂoorplans of buildings in Atlanta (black), which have subsequently been marked up with road data(green).

Figure 5.37: The GIS UI allows diﬀerent sets of proﬁles (right) to be assigned to
diﬀerent ﬂoor plans (left). Users are able to edit the sets of proﬁles that are used to
generate the architectural shells.

5.6. Evaluation

177

Figure 5.38: Given a plan (blue) and a road (thick grey line), we assign a set of
diﬀerent proﬁles (red: front, blue: back, green: right, yellow left, with light and dark
shades specifying long and short edges). In b. the naive ordering assigns a label based
on the oritenation. In c the long and short labels are assigned by considering triples
of consecutive edges. If the ﬁrst and last edge of the triple have the same orientation,
and the second has a shorter length than the ﬁrst or third, then the assignment of the
second edge is changed to a short edge of the same orientation as the ﬁrst.
The positioning of anchors representing machines is also delegated by these labels.
Proﬁle anchors are speciﬁed by the associated proﬁles, while the plan-anchors are
positioned by short Java programs which specify an interval to repeat anchors at —
for example to create a row of windows, or a door and several windows.
GIS results
Using our GIS UI tool we were able to apply PEs to a large scale cityscape. We created
a procedural model using about 6000 footprints from Atlanta (see Fig. 5.39). We used
our interactive system to apply three diﬀerent machines to generate diﬀerent styles of
architecture to the footprints.
The resulting geometry has three million polygons, 3 diﬀerent building styles, took 20
minutes user modeling time, 10 minutes to compute the procedural extrusions, and
15 minutes to render. The automated system used GIEs, horizontal and normal edge
direction events, as well as anchor events. One limitation was that we were not able
to ﬁnd a rendering infrastructure to render such a detailed model. We therefore had
to omit the decorative meshes from all but the nearest structures. The PE system
was implemented in Java and we measured the running times of our system on 64bit
2.6GHz CPU.
The system eﬃciently created a large quantity of architectural geometry. However we
were able to could several geometry failures by manual inspection 5.40. It is likely that

5.6. Evaluation

178

Figure 5.39: We present an interactive procedural modeling system that is able to
model diﬃcult architectural surfaces, such as roof constructions. This ﬁgure shows procedural extrusions applied to 6000 ﬂoorplans from a GIS database of Atlanta. Procedural
tree meshes were added for decoration.

Figure 5.40: The two observed examples of missing geometry. Note the missing roof
sections in both buildings.
these cases were caused by ﬂoating point errors, or our use of GIE for event resolution.
Typically these errors expressed themselves as missing sections of roof, or very tall,
self-inverted roof lines.

5.6.2

Interactive Evaluation

While procedural evaluation of the PE shows the algorithmic stability and potential for
large scale cityscapes, it does not explore the range of forms that can be created. To
this end we performed an evaluation of the range of forms that our user interface was
able to sucessfully model. In order to do this we modeled 50 buildings, and recorded
the issues that were encountered.
Each building was modeled from a plan and a perspective image. A set of four simple
meshes were used to add detail to the structures, these meshes are illustrated in earlier
Fig. 5.28. The events used for modeling were edge direction events, proﬁle oﬀset events,
natural steps and decorative mesh anchors.

5.6. Evaluation

179

Figure 5.41: The example cases and modeling statistics. v Vertices in modeled plan
(additional vertices); l Polygons in modeled plan (polygons in library plan); p Number
of proﬁle sections in model; s Number of natural steps designed (number of natural step
applications); o Number of oﬀset events.

5.6. Evaluation

180

Figure 5.42: Sample aerial photographs of buildings used for modeling examples 46
to 50 in Fig. 5.28. a,b) Stockholm, c) Copenhagen, d) Edinburgh, e) Vienna. c 2013
Google.
We undertook the evaluation with the goal that all major geometric features from
the elevation drawings should be present, although smaller details (such as cornices,
plumbing and decorative windows) were excluded. We traced the plans from those
speciﬁed or aerial views of the property. The construction of proﬁles and positioning
of features was performed “by eye” by the author of this thesis.
The ﬁrst 45 buildings were taken from a library of ready designed architectural styles
for family homes[99], Appendix A. We modeled the ﬁrst example in each of the categories in the library. These categories styles as diverse as ranch or Dutch (Fig. 5.41,
examples 13 and 32 respectively), however much of the stylistic content was dependent
on architectural details that were replaced with our simple meshes.
Because the library plans were generic American templates, they had predominantly
90◦ and 45◦ degree angles between ﬂoorplan edges. That is, the design was not constrained by environmental features. To provide more challenging examples, we chose
an additional ﬁve buildings from European cities that had irregular plans (Fig. 5.41, examples 46-50). These buildings were modeled from satellite and aerial views, Fig. 5.42.
The modeling times ranged from 20 to 120 minutes with a mean time of 63 minutes.
Features on the input plan smaller than approximately 30cm were not modeled. We
also recorded a number of additional metrics for each building: the number of vertices
in the input plan and in the model; the number of corner-loops in the input and in the
model; the number of proﬁles in the model, the number of oﬀset events, the number
of natural step templates and the number of instances of those steps. These statistics
are given in Fig. 5.41.
It was possible to model all the buildings using the PE system, although the long
modeling times reﬂect the fact that obtaining some roof lines was comples. We continue
to describe some of the problems encountered.
The most common issue when modeling was the construction of structures that contained edges not speciﬁed in the input plan (Fig. 5.43 (a). In these circumstances it
was necessary to add extra edges to model these features. These would either be added

5.6. Evaluation

181

Figure 5.43: a) The red roof face is not described in the input polygon(left). By
creating a small change to the input polygon we can create the desired face (green). b)
left: edges can be expected to collide at a certain height (green polygons), right: however
when these edges are involved in other events (such as those from the red polygon), there
may be undesired consequences, here a non-terminating polygon. c) Some structures
(such as dormer windows and chimneys) do not obey the volume-maximizing resolution
to the ambiguous case, in this situation we have to lower the ambiguous case priority
of some edges (blue) to get the desired result. d) A face (yellow) may be shared between
two proﬁles (blue lines), deﬁning co-planar proﬁle sections requires patience on behalf
of the user.
in the plan, leading to the diﬀerence between the vertices in the input plans and the
model in several of the examples, or by natural steps at certain heights.
We share a limitation with the straight skeleton that certain smaller edits to the footprint can result in bigger changes to the roof surface[65]. For example when two
adjacent edges, which are nearly parallel have diﬀerent θ values, the behavior of the
resulting roof can be erratic as the angle between the edges is set to greater than, or
less than zero. In practice these edges do not appear often in architecture. When they
do, it is often possible to add a perpendicular edge (Fig. 5.43, a) to lessen the chaotic
behaviour.
In several circumstances one face relies upon another, spatially separated, face to halt
its propagation at the correct time; that is, an edge is fated to meet another (Fig. 5.43,
b). When another feature blocks, or changes the course of one of these faces, the other
may not terminate, or collide in an unexpected location. These fated edges lead to
potentially undesirable intermediate outputs while editing.
Modeling circular arches was diﬃcult because any adjustment in the width of the arch,
would have to be accompanied by a re-scaling of the proﬁles. Modeling techniques such
as shape grammars are able to retain such semantic information to automate such a
process, and it is possible to imagine a similar system for the procedural extrusions.
It is not convenient to model a roof that is held only by a large number of pillars,
because it is not easy to model the transition from pillars to the roof. For example,
pergolas (Fig. 5.41, example 31) contain no walls to allow the plan to generate a roof.
These were not a large part of our data set, and were approximated by walled structures

5.6. Evaluation

182

of similar volume.
It was occasionally necessary to override our default of a volume maximizing priority in
the ambiguous case. For example, in the case of a chimney stack or a dormer window
(Fig. 5.43, c). To do this we used tags to specify high priority and low priority proﬁle
segments. This approach proved simple compared to the alternative of specifying a
priority for every pair of segments.
It was relitively easy to split one edge into two, by inserting a step event in the edge.
In contrast, we found the reverse case quite tricky; allowing two proﬁles to merge to
one (Fig. 5.43, d). We see this architectural feature as two diﬀerent proﬁles to merge
at the top of a shorter roof (Fig. 5.41, examples 3, 20). To design a proﬁle with a
face co-planar to another is diﬃcult, especially if the second edge starts from an edge
parallel, but not colinear to the ﬁrst.
Natural steps proved very versatile for inserting edges into the polygons. For example,
Fig. 5.41 (example 34) required a new edge internal to the plan for the back-facing wall
of the tower. By positioning a wide square natural step on the end of the building, it
was possible to split the polygon into two. One partition became the tower, and the
other the remainder of the roof structure.

5.6.3

Artistic Evaluation

The ﬁnaly evaluation technique was intended to investigate the usability of the system
by those unfamilar with procedural modeling. We employed two artists to use the
system for four weeks. These users reported that it took between 5 hours and 3 weeks
to become competent with the tool given a short three page user guide. Brief telephone
calls were made with the artists, and no direct tutoring occured.
During this training the artists were able to create a number of interesting forms,
Fig. 5.44. Finally they were asked to create some complex example meshes, Fig. 5.45.
To create these complex examples the artists created their own custom meshes to
attach. This took the total modeling time to 30 hours for both artists, although the
time spend using the procedural extrusion system ranged from 5-10 hours. The time
saved compared to standard mesh modeling techniques was estimated by the artists to
be between 5 and 15 hours.
Whilst this approach only gives a coarse qualititive metric, it shows the applicability
of the procedural extrusions in the real world. The ﬁnal interviews with the arists are
recorded in Sec. B. Both artists commented that the PE system was faster to use than
commercial generic mesh modeling packages.

5.6. Evaluation

183

Figure 5.44: The artists’ example work while learning to use procedural extrusions.
Note the wide range of roof shapes easily expressed in the system.

5.6. Evaluation

184

Figure 5.45: The ﬁnal projects from user 1 (above) and user 2 (below). These took
“10 hours” and “5-10” of work with the procedural extrusion system.

5.6. Evaluation

5.6.4

185

Notable external applications

Procedural extrusions have been used in external academic and commercial projects.
Fig. 5.46 illustrates the intended use of procedural extrusions in the video game Clockwork Empires[196]. This project, which is still in development, extends on the work presented here by including texturing, and forced termination at speciﬁed height, “caps”,
to stop the user creating run-away geometry that may become very tall.
In an acadmic project, our PE library has been integrated into the skylineEngine[197],
implemented in Houdini3D[215]. This project allows basic plans an proﬁles to be
deﬁned inside the Houdini environment, as in Fig. 5.47.

5.6. Evaluation

186

Figure 5.46: c 2012, 2013, Gaslamp Games. Clockwork Empires[196] uses procedural extrusions to generate buildings from user speciﬁed footprints. Top: The user
designs a footprint. Bottom Left: the resulting mesh. Bottom Right: Another in-game
building in context.

5.7. Comments

187

Figure 5.47: c Gustavo Patow 2012. The integration of our PE implementation with
Houdini. Top: Two views of a Raccolet style house, and the graph that generates it.
Bottom: Two views of a “sea view” style house.

5.7

Comments

A signiﬁcant decision made early on in the development of the PE system was to choose
between an exact arithmetic or a ﬂoating point implementation. Our ﬂoating point
implementation is well suited to interactive modeling applications because it prioritizes
interactive update speeds over high precision. An exact arithmetic approach may be
important to give theoretical guarantees and such an alternative implementation would
be very valuable. Posing a particular problem to such a rigerous approach is the lack
of a solution for a generic MWSS – the pincushion problem of Sec. 3.5.3.
An informative perspective on the PE system is to consider the MWSS as a system for
automated and domain-appropriate information loss. The user inserts data into the
system, in the form of UI speciﬁed events, and the MWSS removes it in an architecturally appropriate manner. As the sweep plane rises, MWSS events such as split and
edge events remove edges (and information) from the active plan. Concurrently the
edge direction events, proﬁle oﬀset events, subdivision events, and the input plan insert
additional information into the active plan. This contrast invites the description of PE
as an automated information loss system. The user speciﬁes the places to insert additional data, while the MWSS is utilised to remove it in an architecturally-meaningful

5.7. Comments

188

Figure 5.48: Left: Straight skeleton; Middle: Straight Skeleton with angle changes;
Right: Procedural extrusions
manner. An example is given in Fig. 5.49.
An interesting challenge is that it is possible, and indeed probable, that the fa¸ades
c
generated the PE system are not rectangular. The large variety of shapes that a
fa¸ade can take leads to issues integrating the PE system with other approaches which
c
expect shapes to be rectangular, such as CGA Shape. While the system of deformable
meshes and anchors have been sucessful in positioning elements, describing a repeating
facade over an irregular polygon is still a matter for research. This problem has been
particularly evident when integrating PEs with Houdini.

5.8. Conclusion

189

Figure 5.49: A procedural extrusion model of a haunted house. The green lines show
where data is inserted into the rising sweep plane, and the red lines show where an user
event removes data.

5.8

Conclusion

In contrast to the previous chapter, which used the straight skeleton for modeling parcel
subdivisions, this chapter has introduced an application of the MWSS to the modeling of complex architectural shells. We have demonstrated this procedural extrusion
system is suitable for both interactive architectural modeling and procedural cityscape
visualisation. The large scale tests proved that the PE system was robust enough for
procedural use, and could stand alone as an entire procedural system, rather than just
a geomteric component. Additionally we showed that the PE system is usable, and
useful to, people without signiﬁcant promgramming experiance.
Existing modeling techniques, such as extrude operation and Havemann’s[101] roof
modeling constrain the direction of the extrudes is limited to angles above the sweep
plane. By using proﬁle oﬀset events and horizontal edge direction events, the PE system
can also simulate arbitrary non-monotone extrusions. This dramatically increases the
range of shapes possible. Indeed, in theory, it is possible to encode an arbitrary mesh
into a system of PEs, with an arbitrary sweep plane direction. This is, however, future
work.
In addition we have introduced a novel improvement to mesh instancing in procedual
modeling. The PE system of anchors and deformable meshes allows a larger variety of decorative elements to be added to meshes, that the traditional technqiues of

5.8. Conclusion

190

translation and scaling allow.
The theoretical problems underlying the speciﬁcation of MWSS events have had minimum impact on the usefullness of the PE system. While a few failures cases were
encountered in the large scale GIS test case, this issue has not caused problems during
software development or evaluation.
It is informative to attempt to place the PE on our spectrum of proceduralisation. The
interactive system, is, at it’s simplest a very speciﬁc mesh modeling system. However,
the ease of reparameterisation of the plan places it somewhere in the middle of the
spectrum. It is a system dedicated to the genartion of architecture from one domain,
but it still able to create a range of such architecture. In particual, the PE system
stands out against other systems at this level of specialisation in that it requires no
end user programming, and can be entirely graphically driven.
We believe that the PE system is the ﬁrst to provide a solution for the procedural
modeling of walls, roofs, and complex architectural elements from arbitrary building
footprints. The main contribution of this paper is the design of a set of tools that
extend the basic extrude operation to one that is geometrically self-sensitive. These
tools are able to model a wide range of architectural surfaces that may have not been
expressable with previous procedural models.

191

Chapter 6
Conclusion

192

Appendix A
Appendix - input for interactive UI
evaluation

193

Figure A.1: The input plans and proﬁles to Fig. 5.41. c 2012 ePlans.

194

Appendix B
Appendix - artists’ comments on
the procedural extrusions system
Please note that the artists refer to the procedural extrusion system as “the skeleton
program” or similar.

B.0.1

User 1

In less than 3 sentences, describe your artistic training (eg: university
course and any relevant work experience you’ve done) My artistic training
consists of a bachelors of ﬁne arts degree in 3-D Imaging and Animation from Arizona
State University, as well as a certiﬁcate in computer gaming. Relevant work experience includes creating all artistic assets for a stroke patient rehabilitation interactive
videogame for the Arizona State University Biomedical Research Facility.
How much programming experience have you had (eg: none? max-scripting?
c++?) My personal programming experience consists of one meager class in ﬂash programming for videogames that I was not extremely successful at.
How long did it take you to become competent at using the tool? After
being given a list of hot keys and experimenting with the program, it took roughly
three weeks to become comfortable with multiple proﬁles and ﬂoor plan pieces while
using the program.
Was the skeleton program easy to use (compare to using Max/Maya/Sketchup)? Compared to Max or Maya the program has a much softer learning curve,
from interface aspects to object creation. For the sole purpose of creating buildings and
architecture, the skeleton program appears more expedient than the normal modeling
programs due to automated steps it takes in completing and triangulated the meshes.

195
How long did it take you to create you current projects (the mansion or the
oriental house). How much of this time was creating the meshes. How much
of this time was using the skeleton program? To create my brick mansion and
ﬁnal renders took roughly twenty to twenty ﬁve hours. Creating my meshes (windows,
door, cornice, chimney) only took about four to ﬁve hours in Maya. It took about
10 hours using the skeleton program to create the mansion mesh itself, but that was
due to changing it repeatedly and experimenting with 10+ proﬁles and how they align.
The latter 10 hours or so was spent in Maya ﬁrst creating textures, then a 10 piece
lighting unit, and then creating quality renders for the paper.
Would it have taken longer to create these models without the skeleton
program? Yes, it would have taken quite a while longer to create the mesh in Maya,
and I can assume that the triangulation and face count wouldn’t be as low either. It
probably would take at least twice the amount of time due to the roof most of all, to
create all the angles seamlessly and uniformly.
Would the tool be a useful addition to current 3D modeling packages? The
tool would be very useful for a 3-D Environment modeling package. Being able to
export an OBJ ﬁle, it would be very easy to populate the background of an environment
with buildings that diﬀered just enough that they didn’t look like duplicates, but not
so high poly that it would slow down a game engine.
Any other comments about the skeleton program? Overall the program has
quite a lot of potential, if only for a speciﬁc set of uses. The only suggestions I had is
to ﬁnd a way to make the measurements more exact than just the align to grid system,
whether it’s just a soft grid in the background, or an actual numerical system that
can be manipulated. This goes for the proﬁle view as well. One thing that makes it
very easy in Maya is you can always move things in exact, straight lines, which is very
useful for low poly creation. Occasionally I would ﬁnd that my building swelled at the
top compared the bottom, or one side was actually just a shade shorter than the other
even though they look identical on the ﬂoor plan.

B.0.2

User 2

In less than 3 sentences, describe your artistic training (eg: university
course and any relevant work experience you’ve done): I have taken a number
of traditional art classes including Drawing, Painting, Sculpture, Color Theory as well
as 2D and 3D Design. I have also completed 4 classes in 3D Modeling and Animation,
and have been using 3D programs for over 5 years.

196
How much programming experience have you had (eg: none? max-scripting?
c++?) I have taken introductory courses in Visual Basic, C++, Java and Action
Script. I am also familiar with HTML and CSS.
How long did it take you to become competent at using the tool? With only
the Note document it took me about 5 hours to get a decent understanding of the
program. I think that a video guide would cut down on this time quite a bit, as well
as give a user a much better grasp of the program.
Was the skeleton program easy to use (compare to using Max/Maya/Sketchup)? Yes, the skeleton program was easy to use compared to Max and Maya.
How long did it take you to create you current projects (the mansion or
oriental house). How much of this time was creating the meshes. How
much of this time was using the skeleton program? I would say that it took
be about 20 to 30 hours to get the oriental house to where it is now. I would say the
majority of this time was spent creating the meshes, 15 to 20 hours and 5 to 10 hours
using the skeleton program.
Would it have taken longer to create these models without the skeleton
program? I think that it would have taken me longer to get my model to the same
level of completion without the skeleton program. I would say traditional modeling
techniques would add at least 5 hours of work.
Would the tool be a useful addition to current 3D modeling packages? This
would be a great addition to Max or Maya, the speed with which it allows you to create
buildings
Any other comments about the skeleton program? Overall I think that the core
idea behind the skeleton program is really great, and for the most part the execution of
the program is equally great. The ease with which you can create a building and then
tweak it until it is exactly what you are looking for is extremely useful. In its current
state, I think the meshes are the weakest part of the Skeleton program. The main reason
I say this is because as it currently stands, the application of meshes doesnt really save
you that much time compared to creating and attaching them within a separate 3D
program. If I were using this program in the industry my preferred pipeline would be
something along the lines of the below.
• Use the Skeleton program to create the basic shape of a building
• Create any dormer-window like protrusions (if implemented again)
• Apply roof tiles where appropriate within the skeleton program

197
• Export the building as an .obj ﬁle
• Import building into Max or Maya
• Build the detail meshes for the building on top of the imported building
• Duplicate, rotate, and transform the meshes to ﬂesh out all the desired details.
This only diﬀerence between the above pipeline and the current pipeline is that currently I build a mesh, skin it, export it, and then attach it within the skeleton program.
I think that the removal of the need to skin and weight the meshes makes up for the
need to manually duplicate, rotate, and transform them.
Ultimately, in a perfect software, I would love to be able to create meshes and then
apply them to my models in a 3D environment instead of the two 2D environment the
Skeleton program uses. In other words, I would want the ability to create the anchor
points directly on the mesh in the 3D view of the Skeleton program.

BIBLIOGRAPHY

198

Bibliography
[1] CGAL, Computational geometry algorithms library. www.cgal.org, February
2008.
[2] 3ds
Max.
3ds
max:
Product
information.,
2007.
http://images.autodesk.com/adsk/ﬁles/ 3ds max 2008 overview brochure.pdf.
[3] G. Abram and L. Treinish. An extended data-ﬂow architecture for data analysis
and visualization. In Proceedings of the 6th conference on Visualization’95, page
263. IEEE Computer Society, 1995.
[4] M Agarwal and J Cagan. A blend of diﬀerent tastes: the language of coﬀeemakers.
Environment and Planning B: Planning and Design, 25(2):205–226, March 1998.
[5] S. Agarwal, N. Snavely, I. Simon, S.M. Seitz, and R. Szeliski. Building rome in
a day. In Computer Vision, 2009 IEEE 12th International Conference on, pages
72–79. Ieee, 2009.
[6] O. Aichholzer, D. Alberts, F. Aurenhammer, and B. G¨rtner. Straight skeletons
a
of simple polygons. In Proc. 4th Internat. Symp. of LIESMARS, pages 114–124,
1995.
[7] O. Aichholzer, F. Aurenhammer, D. Alberts, and B. Grtner. A novel type of
skeleton for polygons. Journal of Universal Computer Science, 1(12):752–761,
1995.
[8] Oswin Aichholzer and Franz Aurenhammer. Straight skeletons for general polygonal ﬁgures in the plane. In Computing and Combinatorics, pages 117–126.
Springer-Verlag, 1996.
[9] S. Al-Kheder, J. Wang, and J. Shan. Fuzzy inference guided cellular automata
urban-growth modelling using multi-temporal satellite images. International
Journal of Geographical Information Science, 22(11-12):1271–1293, 2008.

Bibliography

199

[10] Christopher Alexander, Sara Ishikawa, and Murray Silverstein. A Pattern Language: Towns, Buildings. Oxford University Press, later printing edition, August
1977.
[11] K. Alexandridis, B.C. Pijanowski, and Z. Lei. Assessing multiagent parcelization
performance in the mabel simulation model using monte carlo replication experiments. Environment and Planning B: Planning and Design, 34(2):223, 2007.
[12] Daniel G. Aliaga, Paul A. Rosen, and Daniel R. Bekins. Style grammars for
interactive visualization of architecture. IEEE Transactions on Visualization
and Computer Graphics, 13(4):786–797, 2007.
[13] Daniel G. Aliaga, Carlos A. Vanegas, and Bedˇich Beneˇ. Interactive exampler
s
based urban layout synthesis. ACM Transactions on Graphics, 27(5):1–10, 2008.
[14] Fabricio Anastacio, Przemyslaw Prusinkiewicz, and Mario Costa Sousa. Sketchbased interfaces and modeling (sbim): Sketch-based parameterization of lsystems using illustration-inspired construction lines and depth modulation.
Computer Graphics, 33(4):440–451, 2009.
[15] R. Anderl and R. Mendgen. Modelling with constraints: theoretical foundation
and application. Computer-Aided Design, 28(3):155–168, 1996.
[16] Peter R Atherton. A scan-line hidden surface removal procedure for constructive
solid geometry. SIGGRAPH Computer Graphics, 17(3):73–82, 1983.
[17] Franz Aurenhammer. Weighted skeletons and ﬁxed-share decomposition. Computer Geom. Theory Appl., 40(2):93–101, 2008.
[18] Autodesk. ArcGIS. www.esri.com/software/arcgis, accessed (14/8/12).
[19] Autodesk. AutoCAD. www.autodesk.co.uk/autocad, accessed (14/8/12).
[20] Autodesk. Autodesk Maya. usa.autodesk.com/maya, accessed (14/8/12).
[21] Autodesk. Mudbox. http://www.autodesk.com/mudbox, accessed (14/8/12).
[22] Shai Avidan and Ariel Shamir. Seam carving for content-aware image resizing.
ACM Transactions on Graphics, 26(3):10, 2007.
[23] S. Becker. Generation and application of rules for quality dependent fa¸ade
c
reconstruction. ISPRS journal of photogrammetry and remote sensing, 64(6):640–
653, 2009.

Bibliography

200

[24] T. Beier and S. Neely. Feature-based image metamorphosis. Computer Graphics,
26(2):35–42, 1992.
ˇ
[25] B. Beneˇ, O. St’ava, R. Mˇch, and G. Miller. Guided procedural modeling. In
s
e
Computer Graphics Forum, volume 30, pages 325–334. Wiley Online Library,
2011.
[26] Bentley.
Generative
Components.
www.bentley.com/enGB/Products/GenerativeComponents/, accessed (14/8/12).
[27] J. Bloomenthal. Medial-based vertex deformation. In Proceedings of the 2002
ACM SIGGRAPH/Eurographics symposium on Computer animation, pages 147–
151. ACM, 2002.
[28] Jules Bloomenthal. Modeling the mighty maple. SIGGRAPH Computer Graphics, 19(3):305–311, 1985.
[29] Harry Blum. A transformation for extracting new descriptors of shape. Models
for the Perception of Speech and Visual Form, pages 362–380, 1967.
[30] M. Bokeloh, A. Berner, M. Wand, H.P. Seidel, and A. Schilling. Symmetry
detection using feature lines. In Computer Graphics Forum, volume 28, pages
697–706, 2009.
[31] M. Bokeloh, M. Wand, and H.P. Seidel. A connection between partial symmetry
and inverse procedural modeling. ACM Transactions on Graphics, 29(4):104,
2010.
[32] Martin Bokeloh, Michael Wand, Vladlen Koltun, and Hans-Peter Seidel. Patternaware shape deformation using sliding dockers. ACM Transactions on Graphics,
30:123:1–123:10, December 2011.
[33] Martin Bokeloh, Michael Wand, Hans-Peter Seidel, and Vladlen Koltun. An
algebraic model for parameterized shape editing. ACM Transactions on Graphics,
31(4):XXX, August 2012.
[34] P. Borrel and D. Bechmann. Deformation of n-dimensional objects. In Proceedings of the ﬁrst ACM symposium on Solid modeling foundations and CAD/CAM
applications, pages 351–369. ACM, 1991.
[35] G.H. Buck-Sorlin, O. Kniemeyer, and W. Kurth. Barley morphology, genetics
and hormonal regulation of internode elongation modelled by a relational growth
grammar. New Phytologist, 166(3):859–867, 2005.

Bibliography

201

[36] M. Cabral, S. Lefebvre, C. Dachsbacher, and G. Drettakis. Structure-preserving
reshape for textured architectural scenes. In Computer Graphics Forum, volume 28, pages 469–480. Wiley Online Library, 2009.
[37] M. Carmona. Public places, urban spaces: the dimensions of urban design. Architectural Press, 2003.
[38] HH Chau, X. Chen, A. McKay, and A. de Pennington. Evaluation of a 3d shape
grammar implementation. Design computing and cognition, 4:357–376, 2004.
[39] Guoning Chen, Gregory Esch, Peter Wonka, Pascal Muller, and Eugene Zhang.
Interactive procedural street modeling. ACM Transactions on Graphics, 27(3),
2008.
[40] S.W. Cheng and A. Vigneron. Motorcycle graphs and straight skeletons. In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms,
pages 156–165. Society for Industrial and Applied Mathematics, 2002.
[41] N. Chomsky. Three models for the description of language. Information Theory,
IRE Transactions on, 2(3):113–124, January 1956.
[42] N. Chomsky. On certain formal properties of grammars*. Information and control, 2(2):137–167, 1959.
[43] M.F. Cohen, J. Shade, S. Hiller, and O. Deussen. Wang tiles for image and
texture generation. ACM Transactions on Graphics, 22(3):287–294, 2003.
[44] Complexity zoo, January 2011. [online] http://qwiki.stanford.edu, retrieved
1/1/12.
[45] G. Curdes. Stadtstruktur und Stadtgestaltung. Kohlhammer, 1997.
[46] Scott Davidson.
(14/8/12).

Grasshopper.

http://www.grasshopper3d.com/, accessed

[47] AL Davis and RM Keller. Data ﬂow program graphs. Computer, pages 26–41,
1982.
[48] AL Davis and SA Lowder. A sample management application program in a
graphical data driven programming language. Digest of Papers Compcon Spring,
81:162–167, 1981.
[49] M. Davis, R. Sigal, and E.J. Weyuker. Computability, complexity, and languages:
fundamentals of theoretical computer science. Morgan Kaufmann, 1994.

Bibliography

202

[50] MD de Jong and CL Hankin. Structured data ﬂow programming. ACM SIGPLAN Notices, 17(8):18–27, 1982.
[51] Phillippe de Reﬀye, Claude Edelin, Jean Fran¸on, Marc Jaeger, and Claude
c
Puech. Plant models faithful to botanical structure and development. In SIGGRAPH ’88: Proceedings of the 15th annual conference on Computer graphics
and interactive techniques, pages 151–158, New York, NY, USA, 1988. ACM.
[52] Paul E. Debevec, Camillo J. Taylor, and Jitendra Malik. Modeling and rendering
architecture from photographs: a hybrid geometry- and image-based approach. In
Proceedings of the 23rd annual conference on Computer graphics and interactive
techniques, SIGGRAPH ’96, pages 11–20, New York, NY, USA, 1996. ACM.
[53] F. Dellaert, S.M. Seitz, C.E. Thorpe, and S. Thrun. Structure from motion
without correspondence. In Computer Vision and Pattern Recognition, 2000.
Proceedings. IEEE Conference on, volume 2, pages 557–564. IEEE, 2000.
[54] J. Dennis. First version of a data ﬂow procedure language. In Programming
Symposium, pages 362–376. Springer, 1974.
[55] A.R. Dick, PHS Torr, and R. Cipolla. Modelling and interpretation of architecture from several images. International Journal of Computer Vision, 60(2):111–
134, 2004.
[56] J.J. Dolado and F.J. Torrealdea. Formal manipulation of forrester diagrams
by graph grammars. Systems, Man and Cybernetics, IEEE Transactions on,
18(6):981 –996, nov/dec 1988.
[57] P. Dosch, K. Tombre, C. Ah-Soon, and G. Masini. A complete system for the
analysis of architectural drawings. International Journal on Document Analysis
and Recognition, 3(2):102–116, 2000.
[58] K. Dylla, B. Frischer, P. Mueller, A. Ulmer, and S. Haegler. Rome reborn 2.0: A
case study of virtual city reconstruction using procedural modeling techniques.
Computer Graphics World, 16:25, 2008.
[59] A.A. Efros and T.K. Leung. Texture synthesis by non-parametric sampling.
In Computer Vision, 1999. The Proceedings of the Seventh IEEE International
Conference on, volume 2, pages 1033–1038. Ieee, 1999.
[60] Alexei A. Efros and William T. Freeman. Image quilting for texture synthesis
and transfer. In Proceedings of ACM SIGGRAPH 2001, pages 341–346, 2001.

Bibliography

203

[61] H. Ehrig and H.J. Kreowski. Parallel graph grammars. In Automata, Languages,
Development, pages 425–442. Amsterdam: North Holland, 1976.
[62] H. Ehrig, M. Pfender, and H.J. Schneider. Graph-grammars: An algebraic approach. In Switching and Automata Theory, 1973. SWAT’08. IEEE Conference
Record of 14th Annual Symposium on, pages 167–180. IEEE, 1973.
[63] Michael Eigensatz, Martin Kilian, Alexander Schiftner, Niloy J. Mitra, Helmut
Pottmann, and Mark Pauly. Paneling architectural freeform surfaces. ACM
Transactions on Graphics, 29:45:1–45:10, July 2010.
[64] D. Eppstein. Subgraph isomorphism in planar graphs and related problems. In
Proceedings of the sixth annual ACM-SIAM symposium on Discrete algorithms,
pages 632–640. Society for Industrial and Applied Mathematics, 1995.
[65] David Eppstein and Jeﬀ Erickson. Raising roofs, crashing cycles, and playing
pool: applications of a data structure for ﬁnding pairwise interactions. In SCG
’98: Proceedings of the fourteenth annual symposium on Computational geometry,
pages 58–67, New York, NY, USA, 1998. ACM.
[66] Esri. Esri CityEngine. www.esri.com/software/cityengine/index.html, accessed
(14/8/12).
[67] P. Felkel and S. Obdrˇalek. Straight skeleton implementation. In Proceedings of
z´
Spring Conference on Computer Graphics, pages 210–218, 1998.
[68] Petr Felkel and Stepan Obdrzalek. Straight skeleton implementation. In Proceedings of Spring Conference on Computer Graphics, pages 210–218, 1998.
[69] Dieter Finkenzeller. Detailed building facades. IEEE Computer Graphics and
Applications, 28:58–66, 2008.
[70] M.A. Fischler and R.C. Bolles. Random sample consensus: a paradigm for model
ﬁtting with applications to image analysis and automated cartography. Communications of the ACM, 24(6):381–395, 1981.
[71] U. Flemming. More than the sum of its parts: the grammar of queen anne houses.
Environment and Planning B, 14:323–350, 1987.
[72] Harvey Fong. Levelshop: From grid paper to playable. Game Developers Conference, 2011.
[73] Blender Foundation. Blender. www.blender.org, accessed (14/8/12).

Bibliography

204

[74] T. Funkhouser, M. Kazhdan, P. Shilane, P. Min, W. Kiefer, A. Tal,
S. Rusinkiewicz, and D. Dobkin. Modeling by example. In ACM Transactions
on Graphics, volume 23, pages 652–663. ACM, 2004.
[75] T. Funkhouser, P. Min, M. Kazhdan, J. Chen, A. Halderman, D. Dobkin, and
D. Jacobs. A search engine for 3d models. ACM Transactions on Graphics,
22(1):83–105, 2003.
[76] Ran Gal, Olga Sorkine, Niloy Mitra, and Daniel Cohen-Or. iWires: An analyzeand-edit approach to shape manipulation. ACM Transactions on Graphics (proceedings of ACM SIGGRAPH), 28(3):1–10, 2009.
[77] M. Gardner. The fantastic combinations of john conway’s new solitaire game
“life”. Scientiﬁc American, 223:120–123, October 1970.
[78] Bj¨rn Gerth, Ren´ Berndt, Sven Havemann, and Dieter W. Fellner. 3d modeling
o
e
for non-expert users with the castle construction kit v0.5. In VAST 2005: 6th
International Symposium on Virtual Reality, Archaeology and Intelligent Cultural
Heritage, pages 49–58, November 2005.
[79] Y. Gingold, T. Igarashi, and D. Zorin. Structured annotations for 2d-to-3d modeling. ACM Transactions on Graphics, 28(5):148, 2009.
[80] Y. Gingold and D. Zorin. Shading-based surface editing. In ACM Transactions
on Graphics, volume 27, page 95. ACM, 2008.
[81] J. Gips. Computer implementation of shape grammars. In NSF/MIT Workshop
on Shape Computation, 1999.
[82] Google. Google Blockly. code.google.com/p/blockly, accessed (14/8/12).
[83] J. Gosling and H. McGilton. The java language environment: A white paper.
1995. Sun Microsystems, 1996.
[84] H. G¨ttler. Attributed graph grammars for graphics. In Graph-Grammars and
o
their Application to Computer Science, pages 130–142. Springer, 1983.
[85] H. G¨ttler. Graphgrammatiken in der Softwaretechnik: Theorie und Anwenduno
gen, volume 178. Not Avail, 1988.
[86] T. Grasl and A. Economou. Palladian graphs. In Future cities: proceedings of
the 28th Conference on Education in Computer Aided Architectural Design in
Europe, September 15-18, 2010, Zurich, Switzerland, ETH Zurich, page 275. vdf
Hochschulverlag AG, 2010.

Bibliography

205

[87] N. Greene. Voxel space automata: modeling with stochastic growth processes
in voxel space. In SIGGRAPH ’89: Proceedings of the 16th annual conference
on Computer graphics and interactive techniques, pages 175–184, New York, NY,
USA, 1989. ACM.
[88] Herbert Gttler. Graph grammars, a new paradigm for implementing visual languages. In Nachum Dershowitz, editor, Rewriting Techniques and Applications,
volume 355 of Lecture Notes in Computer Science, pages 152–166. Springer Berlin
/ Heidelberg, 1989.
[89] Herbert Gttler, Joachim Gnther, and Georg Nieskens. Use graph grammars
to design cad-systems! In Hartmut Ehrig, Hans-Jrg Kreowski, and Grzegorz
Rozenberg, editors, Graph Grammars and Their Application to Computer Science, volume 532 of Lecture Notes in Computer Science, pages 396–410. Springer
Berlin / Heidelberg, 1991.
[90] M. Habbecke and L. Kobbelt. Linear analysis of nonlinear constraints for interactive geometric modeling. Proceedings Eurographics., XXX 2012.
[91] A. Habel, R. Heckel, and G. Taentzer. Graph grammars with negative application
conditions. Fundamenta Informaticae, 26(3):287–313, 1996.
[92] P.E. Haeberli. Conman: a visual programming language for interactive graphics.
In ACM SIGGRAPH Computer Graphics, volume 22, pages 103–111. ACM, 1988.
[93] S. Haegler, P. M¨ller, and L. Van Gool. Procedural modeling for digital cultural
u
heritage. Journal on Image and Video Processing, 2009:4–4, 2009.
[94] Evan Hahn, Prosenjit Bose, and Anthony Whitehead. Persistent realtime building interior generation. In sandbox ’06: Proceedings of the ACM SIGGRAPH
symposium on Videogames, pages 179–186, NY, USA, 2006. ACM.
[95] Jan Halatsch, Antje Kunze, and Gerhard Schmitt. Using shape grammars for
master planning. In John S. Gero and Ashok K. Goel, editors, Design Computing
and Cognition ’08, pages 655–673. Springer Netherlands, 2008.
[96] Feng Han and Song-Chun Zhu. Bottom-up/top-down image parsing by attribute
graph grammar. In ICCV, pages 1778–1785, Washington, DC, USA, 2005. IEEE
Computer Society.
[97] J.S. Hanan and P. Adviser-Prusinkiewicz. Parametric L-systems and their application to the modelling and visualization of plants. The University of Regina
(Canada), 1992.

Bibliography

206

[98] C.L. Hankin and HW Glaser. The data ﬂow programming language cajole-an
informal introduction. ACM Sigplan Notices, 16(7):35–44, 1981.
[99] Hanley Wood, LLC. eplans.com, sept 2010. http://www.eplans.com.
[100] John C. Hart and Brent Baker. Structural simulation of tree growth and response.
In In: Proceedings International Conference on Shape Modeling and Applications,
pages 7–11. Springer-Verlag, 1996.
[101] S. Havemann. Generative Mesh Modeling. PhD thesis, TU Braunschweig, 2005.
[102] Sven Havemann and Dieter Fellner. Generative parametric design of gothic window tracery. Shape Modeling and Applications, International Conference on,
0:350–353, 2004.
[103] B. Hohmann, U. Krispel, S. Havemann, and D. Fellner. Cityﬁt: High-quality
urban reconstructions by ﬁtting shape grammars to images and derived textured
point clouds. In Proceedings of the 3rd ISPRS Workshop. Citeseer, 2009.
[104] M. Honda, K. Mizuno, Y. Fukui, and S. Nishihara. Generating autonomous timevarying virtual cities. In Cyberworlds, 2004 International Conference on, pages
45–52. IEEE, 2004.
[105] Y. Horry, K.I. Anjyo, and K. Arai. Tour into the picture: using a spidery mesh
interface to make animation from a single image. In Proceedings of the 24th
annual conference on Computer graphics and interactive techniques, pages 225–
232. ACM Press/Addison-Wesley Publishing Co., 1997.
[106] P. Hudak, S. Peyton Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, M.M.
Guzm´n, K. Hammond, J. Hughes, T. Johnsson, et al. Report on the programa
ming language haskell: a non-strict, purely functional language version 1.2. ACM
SigPlan notices, 27(5):1–164, 1992.
[107] T. Igarashi, T. Moscovich, and J.F. Hughes. As-rigid-as-possible shape manipulation. In ACM Transactions on Graphics, volume 24, pages 1134–1141. ACM,
2005.
[108] M. Ilˇ´ S. Fiedler, W. Purgathofer, and M. Wimmer. Procedural skeletons:
cık,
kinematic extensions to cga-shape grammars. In Proceedings of the 26th Spring
Conference on Computer Graphics, pages 157–164. ACM, 2010.
[109] National Instruments. Labview. www.ni.com/labview, accessed (14/8/12).

Bibliography

207

[110] International Business Machines Corporation. General information manual; programmer’s primer for FORTRAN automatic coding system for the IBM 704 data
processing system. IBM Corporation, pub-IBM:adr, 1957.
[111] A. Irschara, C. Zach, M. Klopschitz, and H. Bischof. Large-scale, dense city
reconstruction from user-contributed photos. Computer Vision and Image Understanding, 2011.
[112] Nianjuan Jiang, Ping Tan, and Loong-Fah Cheong. Symmetric architecture modeling with a single image. ACM Transactions on Graphics, 28(5):113:1–113:8,
December 2009.
[113] Evangelos Kalogerakis, Siddhartha Chaudhuri, Daphne Koller, and Vladlen
Koltun. A probabilistic model for component-based shape synthesis. ACM Transactions on Graphics, 31(4):XXX, August 2012.
[114] Yoichiro Kawaguchi. A morphological study of the form of nature. In SIGGRAPH ’82: Proceedings of the 9th annual conference on Computer graphics
and interactive techniques, pages 223–232, New York, NY, USA, 1982. ACM.
[115] Tom Kelly. Siteplan. https://code.google.com/p/siteplan/.
[116] Tom Kelly and Peter Wonka. Interactive architectural modeling with procedural
extrusions. ACM Transactions on Graphics, 30(2):14:1–14:15, April 2011.
[117] Tom W A Kelly. City architecture generation. Master’s thesis, University of
Bristol, 2006.
[118] B. Kerautret, X. Granier, and A. Braquelaire. Intuitive shape modeling by shading design. In Smart Graphics, pages 923–923. Springer, 2005.
[119] J.W. Klop and R. de Vrijer. Term rewriting systems. Cambridge Univ Pr, 2003.
[120] T. W. Knight. The generation of hepplewhite-style chair-back designs. Environment and Planning B, 7(2):227–238, 1980.
[121] D.E. Knuth. Semantics of context-free languages. Theory of Computing Systems,
2(2):127–145, 1968.
[122] D.W. Ko, H.S. He, and D.R. Larsen. Simulating private land ownership fragmentation in the missouri ozarks, usa. Landscape ecology, 21(5):671–686, 2006.
[123] H Koning and J Eizenberg. The language of the prairie: Frank lloyd wright’s
prairie houses. Environment and Planning B: Planning and Design, 8(3):295–323,
1981.

Bibliography

208

[124] L. Krecklau and L. Kobbelt. Procedural modeling of interconnected structures.
In Computer Graphics Forum, volume 30, pages 335–344. Wiley Online Library,
2011.
[125] R. Krishnamurti. The arithmetic of shapes. Environment and Planning B: Planning and Design, 7(4):463–484, 1980.
[126] R. Krishnamurti. The construction of shapes. Environment and Planning B,
8:5–40, 1981.
[127] R. Krishnamurti and CF Earl. Shape recognition in three dimensions. Environment and Planning B: Planning and Design, 19(5):585–603, 1992.
[128] F. Lafarge, X. Descombes, J. Zerubia, and M. Pierrot-Deseilligny. Structural
approach for building reconstruction from a single dsm. Pattern Analysis and
Machine Intelligence, IEEE Transactions on, 32(1):135–147, 2010.
[129] G. Lee, R. Sacks, and C.M. Eastman. Specifying parametric building object
behavior (bob) for a building information modeling system. Automation in construction, 15(6):758–776, 2006.
[130] J. Lee and T. Funkhouser. Sketch-based search and composition of 3d models. In
Eurographics Workshop on Sketch-Based Interfaces and Modeling, pages 97–104.
The Eurographics Association, 2008.
[131] J.P. Lewis, M. Cordner, and N. Fong. Pose space deformation: a uniﬁed approach
to shape interpolation and skeleton-driven deformation. In Proceedings of the
27th annual conference on Computer graphics and interactive techniques, pages
165–172. ACM Press/Addison-Wesley Publishing Co., 2000.
[132] R. Lewis and C. S´quin. Generation of 3d building models from 2d architectural
e
plans. Computer-Aided Design, 30(10):765–779, 1998.
[133] Y. Li, X. Wu, Y. Chrysathou, A. Sharf, D. Cohen-Or, and N.J. Mitra. Globﬁt:
consistently ﬁtting primitives by discovering global relations. In ACM Transactions on Graphics, volume 30, page 52. ACM, 2011.
[134] Yuanyuan Li, Eugene Zhang, Yoshihiro Kobayashi, and Peter Wonka. Editing operations for irregular vertices in triangle meshes. ACM Transactions on Graphics,
29:153:1–153:12, December 2010.
[135] Jinjie Lin, Daniel Cohen-Or, Hao Zhang, Cheng Liang, Andrei Sharf, Oliver
Deussen, and Baoquan Chen. Structure-preserving retargeting of irregular 3d architecture. ACM Transactions on Graphics, 30(6):183:1–183:10, December 2011.

Bibliography

209

[136] A. Lindenmayer and G. Rozenberg. Parallel generation of maps: Developmental
systems for cell layers. In Graph-grammars and their application to computer
science and biology, pages 301–316. Springer, 1979.
[137] Aristid Lindenmayer. Mathematical models for cellular interactions in development ii. simple and branching ﬁlaments with two-sided inputs. Journal of
Theoretical Biology, 18(3):300–315, March 1968.
[138] M. Lipp, D. Scherzer, P. Wonka, and M. Wimmer. Interactive modeling of city
layouts using layers of procedural content. In Computer Graphics Forum, volume 30, pages 345–354. Wiley Online Library, 2011.
[139] Markus Lipp, Peter Wonka, and Michael Wimmer. Interactive visual editing of
grammars for procedural architecture. ACM Transactions on Graphics, 27(3):1–
10, 2008.
[140] Markus Lipp, Peter Wonka, and Michael Wimmer. Interactive visual editing of grammars for procedural architecture. ACM Transactions on Graphics,
27(3):102:1–10, 2008. Article No. 102.
[141] Hua Liu, Qing Wang, Wei Hua, Dong Zhou, and Hujun Bao. Building Chinese
Ancient Architectures in Seconds. In International Conference on Computational
Science, pages 248–255, 2005.
[142] Yang Liu, Helmut Pottmann, Johannes Wallner, Yong-Liang Yang, and Wenping
Wang. Geometric modeling with conical meshes and developable surfaces. ACM
Transactions on Graphics, 25(3):681–689, 2006.
[143] R. Lovejoy. Turtle graphics implementation using a graphical dataﬂow programming approach(M. S. thesis). Master’s thesis, Navel Postgraduate School, 1992.
[144] F. Ludolph, Y.Y. Chow, D. Ingalls, S. Wallace, and K. Doyle. The fabrik programming environment. In Visual Languages, 1988., IEEE Workshop on, pages
222–230. IEEE, 1988.
[145] S. Marshall. Cities design and evolution. Urban design and planning. Routledge,
2009.
[146] M. Mathias, A. Martinovic, J. Weissenberg, and L.V. Gool. Procedural 3d building reconstruction using shape grammars and detectors. In 3D Imaging, Modeling, Processing, Visualization and Transmission (3DIMPVT), 2011 International
Conference on, pages 304–311. IEEE, 2011.

Bibliography

210

[147] S. Matwin and T. Pietrzykowski. Prograph: a preliminary report. Computer
Languages, 10(2):91–126, 1985.
[148] J.P. McCormack and J. Cagan. Supporting designers’ hierarchies through parametric shape recognition. Environment and Planning B, 29(6):913–932, 2002.
[149] H. Meinhardt and M. Klingler. A model for pattern formation on the shells of
molluscs. Journal of Theoretical Biology, 126(1):63–89, 1987.
[150] E. Mendez, G. Schall, S. Havemann, D. Fellner, D. Schmalstieg, and S. Junghanns. Generating semantic 3d models of underground infrastructure. Computer
Graphics and Applications, IEEE, 28(3):48–57, 2008.
[151] Paul Merrell. Example-based model synthesis. In I3D ’07: Proceedings of the
2007 symposium on Interactive 3D graphics and games, pages 105–112, New
York, NY, USA, 2007. ACM.
[152] Paul Merrell and Dinesh Manocha. Continuous model synthesis. ACM Transactions on Graphics, 27(5):1–7, 2008.
[153] Paul Merrell, Eric Schkufza, Zeyang Li, Maneesh Agrawala, and Vladlen Koltun.
Interactive furniture layout using interior design guidelines. ACM Transactions
on Graphics, 30:87:1–87:10, July 2011.
[154] N. J. Mitra, L. Guibas, and M. Pauly. Partial and approximate symmetry detection for 3d geometry. In ACM Transactions on Graphics, volume 25, pages
560–568, 2006.
[155] F. Morgram and D. O’Sullivan. Using binary space partitioning to generate
urban spatial patterns. In 4th International Conference on Computers in Urban
Planning and Urban Management, 2009.
[156] F. Morsdorf, E. Meier, B. K¨tz, K.I. Itten, M. Dobbertin, and B. Allg¨wer.
o
o
Lidar-based geometric reconstruction of boreal type forest stands at single tree
level for forest and wildland ﬁre management. Remote Sensing of Environment,
92(3):353–362, 2004.
[157] M¨ller, Wonka, Haegler, Ulmer, and Van Gool. Procedural modeling of buildings.
u
ACM Transactions on Graphics. to appear, 2006.
[158] Pascal M¨ller, T Verneenooghe, Andy Ulmer, and Luc Van Gool. Spatial reu
lations and grammars. In International Workshop on Recording, Modeling and
Visualization of Cultural Heritage, pages 287–297, 2005.

Bibliography

211

[159] Pascal M¨ller, Peter Wonka, Simon Haegler, Andreas Ulmer, and Luc Van Gool.
u
Procedural modeling of buildings. ACM Transactions on Graphics, 25(3):614–
623, 2006.
[160] Pascal M¨ller, Peter Wonka, Simon Haegler, Andreas Ulmer, and Luc Van Gool.
u
Procedural Modeling of Buildings. In Proceedings of ACM SIGGRAPH 2006 /
ACM Transactions on Graphics, 2006.
[161] Pascal M¨ller, Gang Zeng, Peter Wonka, and Luc Van Gool. Image-based prou
cedural modeling of facades. ACM Transactions on Graphics, 24(3):85, 2007.
[162] P. Musialski, P. Wonka, D.G. Aliaga, M. Wimmer, L. van Gool, W. Purgathofer, N.J. Mitra, M. Pauly, M. Wand, D. Ceylan, et al. A survey of urban
reconstruction. In Eurographics 2012-State of the Art Reports, pages 1–28. The
Eurographics Association, 2012.
[163] Radom´ Mˇch and Przemyslaw Prusinkiewicz. Visual models of plants interactır e
ing with their environment. In SIGGRAPH ’96: Proceedings of the 23rd annual
conference on Computer graphics and interactive techniques, pages 397–410, New
York, NY, USA, 1996. ACM.
[164] P. Mller, T. Vereenooghe, P. Wonka, I. Paap, and L. Van Gool. Procedural
3d reconstruction of puuc buildings in xkipch. In Eurographics Symposium on
Virtual Reality, Archaeology and Cultural Heritage (VAST), pages 139–146. EG,
2006.
[165] M. Nagl. Formal languages of labelled graphs. Computing, 16(1):113–137, 1976.
[166] M. Nagl, G. Engels, R. Gall, and W. Sch¨fer. Software speciﬁcation by graph
a
grammars. In Graph-Grammars and Their Application to Computer Science,
pages 267–287. Springer, 1983.
[167] J. Nakielski. Tensorial model for growth and cell division in the shoot apex.
Pattern Formation in Biology, Vision and Dynamics, pages 252–267, 2000.
[168] A. Nealen, T. Igarashi, O. Sorkine, and M. Alexa. Fibermesh: designing freeform
surfaces with 3d curves. In ACM Transactions on Graphics, volume 26, page 41.
ACM, 2007.
[169] Laycock University Of, R. G. Laycock, and A. M. Day. Automatically generating
roof models from building footprints, 2003.

Bibliography

212

[170] R. Ohbuchi, M. Nakazawa, and T. Takei. Retrieving 3d shapes based on their
appearance. In Proceedings of the 5th ACM SIGMM international workshop on
Multimedia information retrieval, pages 39–45. ACM, 2003.
[171] M. Ovsjanikov, W. Li, L. Guibas, and N.J. Mitra. Exploration of continuous variability in collections of 3d shapes. In ACM Transactions on Graphics, volume 30,
page 33. ACM, 2011.
[172] S. Owada, F. Nielsen, and T. Igarashi. Copy-paste synthesis of 3d geometry with
repetitive patterns. In Smart Graphics, pages 184–193. Springer, 2006.
[173] P. Paczkowski, M.H. Kim, Y. Morvan, J. Dorsey, H. Rushmeier, and C. OSullivan. Insitu: sketching architectural designs in context. ACM Transactions on
Graphics, 30(6):182, 2011.
[174] P. Palfrader, M. Held, and S. Huber. On computing straight skeletons by means
of kinetic triangulations. Algorithms–ESA 2012, pages 766–777, 2012.
[175] Wojciech Palubicki, Kipp Horel, Steven Longay, Adam Runions, Brendan Lane,
Radom´ Mˇch, and Przemyslaw Prusinkiewicz. Self-organizing tree models for
ır e
image synthesis. ACM Transactions on Graphics, 28(3):1–10, 2009.
[176] Yoav I. H. Parish and Pascal M¨ller. Procedural modeling of cities. In SIGu
GRAPH ’01: Proceedings of the 28th annual conference on Computer graphics
and interactive techniques, pages 301–308, New York, NY, USA, 2001. ACM.
[177] Yoav I. H. Parish and Pascal M¨ller. Procedural modeling of cities. In Eugene Fiu
ume, editor, Proceedings of ACM SIGGRAPH 2001, pages 301–308. ACM Press,
2001.
[178] D.G. Parolek, K. Parolek, and P.C. Crawford. Form-based codes: a guide for
planners, urban designers, municipalities, and developers. J. Wiley & Sons, 2008.
[179] G. Patow. User-friendly graph editing for procedural modeling of buildings.
Computer Graphics and Applications, IEEE, 32(2):66 –75, march-april 2012.
[180] Mark Pauly, Niloy J. Mitra, Johannes Wallner, Helmut Pottmann, and
Leonidas J. Guibas. Discovering structural regularity in 3d geometry. In SIGGRAPH ’08: ACM SIGGRAPH 2008 papers, pages 1–11, New York, NY, USA,
2008. ACM.
[181] A. Peytavie, E. Galin, J. Grosjean, and S. Merillou. Arches: a framework for
modeling complex terrains. In Computer Graphics Forum, volume 28, pages
457–467. Wiley Online Library, 2009.

Bibliography

213

[182] J.L. Pfaltz and A. Rosenfeld. Web grammars. In Proceedings of the 1st international joint conference on Artiﬁcial intelligence, pages 609–619. Morgan
Kaufmann Publishers Inc., 1969.
[183] Pixologic. ZBrush. http://www.pixologic.com/zbrush, accessed (14/8/12).
[184] A. Plas, D. Comte, O. Gelly, and JC Syre. Lau system architecture: A parallel data driven processor based on single assignment. In Proceedings of the
International Conference on Parallel Processing, pages 293–302, 1976.
[185] M. Pollefeys, L. Van Gool, M. Vergauwen, F. Verbiest, K. Cornelis, J. Tops, and
R. Koch. Visual modeling with a hand-held camera. International Journal of
Computer Vision, 59(3):207–232, 2004.
[186] H. Pottmann, Y. Liu, J. Wallner, A. Bobenko, and W. Wang. Geometry of multilayer freeform structures for architecture. In ACM Transactions on Graphics,
volume 26, page 65. ACM, 2007.
[187] Helmut Pottmann, Qixing Huang, Bailin Deng, Alexander Schiftner, Martin Kilian, Leonidas Guibas, and Johannes Wallner. Geodesic patterns. ACM Transactions on Graphics, 29:43:1–43:10, July 2010.
[188] Helmut Pottmann, Alexander Schiftner, Pengbo Bo, Heinz Schmiedhofer, Wenping Wang, Niccolo Baldassini, and Johannes Wallner. Freeform surfaces from
single curved panels. ACM Transactions on Graphics, 27(3):76:1–76:10, August
2008.
[189] P. PRUSINKIEWICZ. Graphical applications of l-systems. In Canadian Information Processing Society Graphics Interface 1986, pages 247–253, 1986.
[190] P. Prusinkiewicz and A. Lindenmayer.
Springer Verlag, 1991.

The Algorithmic Beauty of Plants.

[191] P. Prusinkiewicz, A. Lindenmayer, and J. Hanan. Development models of herbaceous plants for computer imagery purposes. In ACM SIGGRAPH Computer
Graphics, volume 22, pages 141–150. ACM, 1988.
[192] Przemyslaw Prusinkiewicz, Mark James, and Radom´ Mˇch. Synthetic topiır e
ary. In SIGGRAPH ’94: Proceedings of the 21st annual conference on Computer
graphics and interactive techniques, pages 351–358, New York, NY, USA, 1994.
ACM.

Bibliography

214

[193] S. Pu and G. Vosselman. Knowledge based reconstruction of building models
from terrestrial laser scanning data. ISPRS Journal of Photogrammetry and
Remote Sensing, 64(6):575–584, 2009.
[194] M.J. Pugliese and J. Cagan. Capturing a rebel: modeling the harley-davidson
brand through a motorcycle shape grammar. Research in Engineering Design,
13(3):139–156, 2002.
[195] M. Resnick, J. Maloney, A. Monroy-Hern´ndez, N. Rusk, E. Eastmond, K. Brena
nan, A. Millner, E. Rosenbaum, J. Silver, B. Silverman, et al. Scratch: programming for all. Communications of the ACM, 52(11):60–67, 2009.
[196] R
Ridorsa
and
G
Patow.
ClockworkEmpires.
http://www.gaslampgames.com/2012/08/27/clockwork-empires-the-pressrelease/ accessed (10/10/12).
[197] R Ridorsa and G Patow. skylineEngine. http://ggg.udg.edu/skylineEngine/,
accessed (10/1/13).
[198] N. Ripperda. Determination of facade attributes for facade reconstruction. International Archives of Photogrammetry, Remote Sensing and Spatial Information
Sciences, 37(B3a):285–290, 2008.
[199] N. Ripperda and C. Brenner. Application of a formal grammar to facade reconstruction in semiautomatic and automatic environments. In Proceedings of the
12th AGILE Conference on GIScience, 2009.
[200] G. Rozenberg and A. Salomaa. Handbook of formal languages: Beyond words,
volume 1. Springer Verlag, 1997.
[201] Adam Runions, Brendan Lane, and Przemyslaw Prusinkiewicz. Modeling trees
with a space colonization algorithm. In Eurographics Workshop on Natural Phenomena, 2007.
[202] S. Said and M.R. Embi. A parametric shape grammar of the traditional
malay long-roof type houses. International Journal of Architectural Computing,
6(2):121–144, 2008.
[203] T.W. Sederberg and S.R. Parry. Free-form deformation of solid geometric models.
ACM Siggraph Computer Graphics, 20(4):151–160, 1986.
[204] A. Sharf, M. Alexa, and D. Cohen-Or. Context-based surface completion. In
ACM Transactions on Graphics, volume 23, pages 878–887. ACM, 2004.

Bibliography

215

[205] B. Shizuki, M. Toyoda, E. Shibayama, and S. Takahashi. Smart browsing among
multiple aspects of data-ﬂow visual program execution, using visual patterns
and multi-focus ﬁsheye views. Journal of Visual Languages and Computing,
11(5):529–548, 2000.
[206] I. Shlyakhter, M. Rozenoer, J. Dorsey, and S. Teller. Reconstructing 3d tree
models from instrumented photographs. Computer Graphics and Applications,
IEEE, 21(3):53–61, 2001.
[207] P.G. Sibley, P. Montgomery, and G.E. Marai. Wang cubes for video synthesis
and geometry placement. In ACM SIGGRAPH 2004 Posters, page 20. ACM,
2004.
[208] DC Simmonds. The design of the delta land-use modelling package. Environment
and Planning B, 26:665–684, 1999.
[209] Loic Simon, Olivier Teboul, Panagiotis Koutsourakis, Luc Van Gool, and Nikos
Paragios. Parameter-free/pareto-driven procedural 3d reconstruction of buildings
from ground-level sequences. In Computer Vision and Pattern Recognition. IEEE,
2012.
[210] S.N. Sinha, D. Steedly, R. Szeliski, M. Agrawala, and M. Pollefeys. Interactive 3d
architectural modeling from unordered photo collections. In ACM Transactions
on Graphics, volume 27, page 159. ACM, 2008.
[211] Jeﬀrey Smith, Jessica Hodgins, Irving Oppenheim, and Andrew Witkin. Creating
models of truss structures with optimization. ACM Transactions on Graphics,
21(3):295–301, July 2002.
[212] R.S. Smith, S. Guyomarc’h, T. Mandel, D. Reinhardt, C. Kuhlemeier, and
P. Prusinkiewicz. A plausible model of phyllotaxis. Proceedings of the National
Academy of Sciences of the United States of America, 103(5):1301–1306, 2006.
[213] D.B. Smythe. A two-pass mesh warping algorithm for object transformation and
image interpolation. Technical report, ILM Computer GRaphcis Department,
Lucasﬁlm, 1990.
[214] CNC Software. AutoCAD. www.mastercam.com, accessed (14/8/12).
[215] Side Eﬀects Software. Houdini. http://www.sidefx.com/index.php, accessed
(10/1/13).

Bibliography

216

ˇ
[216] O. St’ava, B. Beneˇ, R. Mˇch, D.G. Aliaga, and P. Kriˇtof. Inverse procedural
s
e
s
modeling by automatic generation of l-systems. In Computer Graphics Forum,
volume 29, pages 665–674. Wiley Online Library, 2010.
[217] J.S. Steyer, M. Boulay, and S. Lorrain. 3d external restorations of stegocephalian
skulls using zbrush: The renaissance of fossil amphibians. Comptes Rendus
Palevol, 9(6-7):463–470, 2010.
[218] G. Stiny. Ice-ray: A note on the generation of chinese lattice designs. Environment
and Planning B, 4:89–98, 1977.
[219] G Stiny. Introduction to shape and shape grammars. Environment and Planning
B Planning and Design, 7(3):343–351, 1980.
[220] G. Stiny. Spatial relations and grammars. Environment and Planning B: Planning and Design, 9(1):113–114, 1982.
[221] G Stiny and W J Mitchell. The palladian grammar. Environment and Planning
B: Planning and Design, 5(1):5–18, January 1978.
[222] George Stiny and James Gips. Shape grammars and the generative speciﬁcation
of painting and sculpture. In Segmentation of Buildings for 3DGeneralisation.
In: Proceedings of the Workshop on generalisation and multiple representation ,
Leicester, 1971.
[223] Kenichi Sugihara and Yoshitugu Hayashi. Automatic generation of 3d building
models with multiple roofs. Tsinghua Science and Technology, 13(Supplement
1):368 – 374, 2008.
[224] J. Sun, X. Yu, G. Baciu, and M. Green. Template-based generation of road
networks for virtual city modeling. In Proceedings of the ACM symposium on
Virtual reality software and technology, pages 33–40. ACM, 2002.
[225] W.R. Sutherland. On-line graphical speciﬁcation of computer procedures. PhD
thesis, MIT, 1966.
[226] K. Takayama, R. Schmidt, K. Singh, T. Igarashi, T. Boubekeur, and O. Sorkine.
Geobrush: Interactive mesh geometry cloning. In Computer Graphics Forum,
volume 30, pages 613–622. Wiley Online Library, 2011.
[227] J.O. Talton, Y. Lou, S. Lesser, J. Duke, R. Mˇch, and V. Koltun. Metropolis
e
procedural modeling. ACM Transactions on Graphics, 30(2):11, 2011.

Bibliography

217

[228] Mirela T˘nase and Remco C. Veltkamp. A straight skeleton approximating the
a
medial axis. 3221:809–821, 2004.
[229] S.L. Tanimoto and M.S. Runyan. Play: an iconic programming system for children. In Visual Languages, pages 191–205. Plenum Press: New York, 1986.
[230] D.A. Thadani, L. Krier, and A. Duany. The language of towns & cities: a visual
dictionary. Rizzoli, 2010.
[231] J. M. Thijssen, H. J. F. Knops, and A. J. Dammers. Dynamic scaling in polycrystalline growth. Phys. Rev. B, 45(15):8650–8656, Apr 1992.
[232] D. Thompson, J. Braun, and R. Ford. OpenDX: Paths to Visulization: Material Used for Learning OpenDX-the Open Derivate of IBM’s Visualization Data
Explorer. Visualization an imagery solutions, 2001.
[233] RB Tilove and A.A.G. Requicha. Closure of boolean operations on geometric
entities. Computer-Aided Design, 12(5):219–220, 1980.
[234] A. Toshev, P. Mordohai, and B. Taskar. Detecting and parsing architecture at
city scale from range data. In Computer Vision and Pattern Recognition (CVPR),
2010 IEEE Conference on, pages 398–405. IEEE, 2010.
[235] Trimble. SketchUp. www.sketchup.com, accessed (14/8/12).
[236] Trimble. Trimble (formally google) warehouse. www.sketchup.google.com, accessed (14/8/12).
[237] K. Tuite, N. Snavely, D.Y. Hsiao, N. Tabing, and Z. Popovic. Photocity: Training
experts at large-scale image acquisition through a competitive game. In Proceedings of the 2011 annual conference on Human factors in computing systems, pages
1383–1392. ACM, 2011.
[238] TurboSquid. Turbosquid.com. www.turbosquid.com, accessed (14/8/12).
[239] A. M. Turing. The chemical basis of morphogenesis. Philosophical Transactions
of the Royal Society of London. Series B, Biological Sciences, 237(641):37–72,
1952.
[240] Alan M. Turing. On computable numbers, with an application to the Entscheidungsproblem. Proceedings of the London Mathematical Society, 2(42):230–265,
1936.
[241] N. Umetani, T. Igarashi, and N.J. Mitra. Guided exploration of physically valid
shapes for furniture design. ACM Transactions on Graphics, 31(4):86, 2012.

Bibliography

218

[242] S. Upstill. The renderman companion. Addison-Wesley Reading, MA, 1990.
[243] C.A. Vanegas, D.G. Aliaga, and B. Benes. Building reconstruction using
manhattan-world grammars. In Computer Vision and Pattern Recognition
(CVPR), 2010 IEEE Conference on, pages 358–365. IEEE, 2010.
[244] C.A. Vanegas, D.G. Aliaga, B. Benes, and P. Waddell. Visualization of simulated urban spaces: Inferring parameterized generation of streets, parcels, and
aerial imagery. Visualization and Computer Graphics, IEEE Transactions on,
15(3):424–435, 2009.
[245] C.A. Vanegas, D.G. Aliaga, P. Wonka, P. M¨ller, P. Waddell, and B. Watson.
u
Modeling the appearance and behaviour of urban spaces. In Computer Graphics
Forum, volume 29, pages 25–42. Wiley Online Library, 2010.
[246] Carlos A. Vanegas, Daniel G. Aliaga, Bedˇich Beneˇ, and Paul A. Waddell. Interr
s
active design of urban spaces using geometrical and behavioral modeling. ACM
Transactions on Graphics, 28:111:1–111:10, December 2009.
[247] Carlos A. Vanegas, Tom Kelly, Basil Weber, Jan Halatsch, Daniel G. Aliaga, and
Pascal Mller. Procedural Generation of Parcels in Urban Modeling. Computer
Graphics Forum, 31(2):681–690, 2012.
[248] G Voronoi. Nouvelles applications des paramtres continus la thorie des formes
quadratiques. J. reine angew. Math., 133:97–178, 1907.
[249] E. Vouga, M. H¨binger, J. Wallner, TU Graz, TU Wien, and H. Pottmann.
o
Design of self-supporting surfaces. ACM Transactions on Graphics, 31(4):XXX,
August 2012.
[250] Paul Waddell. Urbansim: Modeling urban development for land use, transportation and environmental planning. In Journal of the American Planning
Association, volume 68, pages 297–314, 2002.
[251] D. Walker and T. Daniels. The Planners Guide to CommunityViz: The Essential Tool for a New Generation of Planning. Orton Family Foundation Books.
American Planning Association, 2011.
[252] He Wang and Taku Komura. Manipulation of ﬂexible objects by geodesic control.
Computer Graphics Forum, 31(2pt2):499–508, May 2012.
[253] Y. Wang, K. Xu, J. Li, H. Zhang, A. Shamir, L. Liu, Z. Cheng, and Y. Xiong.
Symmetry hierarchy of man-made objects. In Computer Graphics Forum, volume 30, pages 287–296. Wiley Online Library, 2011.

Bibliography

219

[254] Ian Watson and John Gurd. A prototype data ﬂow computer with token labelling.
Managing Requirements Knowledge, International Workshop on, 0:623, 1979.
[255] Basil Weber, Pascal Mueller, Peter Wonka, and Markus Gross. Interactive geometric simulation of 4d cities. Computer Graphics Forum, April 2009.
[256] Li-Yi Wei and Marc Levoy. Fast texture synthesis using tree-structured vector
quantization. In Kurt Akeley, editor, Proceedings of ACM SIGGRAPH 2000,
pages 479–488. ACM Press, 2000.
[257] J. Wernecke. Open inventor c++ reference manual. United States of America,
1994.
[258] T. Werner and A. Zisserman. New techniques for automated architectural reconstruction from photographs. Computer Vision ECCV 2002, pages 808–809,
2002.
[259] Emily Whiting, John Ochsendorf, and Fr´do Durand. Procedural modele
ing of structurally-sound masonry buildings. ACM Transactions on Graphics,
28(5):112:1–112:9, December 2009.
[260] Rohan Wickramasuriya, Laurie A. Chisholm, Marji Puotinen, Nicholas Gill, and
Peter Klepeis. An automated land subdivision tool for urban and regional planning: Concepts, implementation and testing. Environmental Modelling & Software, (0):–, 2011.
[261] S. Wolfram and M. Gad-el Hak. A new kind of science. Applied Mechanics
Reviews, 56:B18, 2003.
[262] Stephen Wolfram. Statistical mechanics of cellular automata. Rev. Mod. Phys.,
55:601–644, Jul 1983.
[263] Peter Wonka, Michael Wimmer, Fran¸ois Sillion, and William Ribarsky. Instant
c
architecture. In SIGGRAPH ’03: ACM SIGGRAPH 2003 Papers, pages 669–
677, New York, NY, USA, 2003. ACM.
[264] M. Woo, J. Neider, T. Davis, D. Shreiner, and OpenGL Architecture Review
Board. OpenGL Programming Guide. Addison Wesley, 1999.
[265] K. Xu, H. Zheng, H. Zhang, D. Cohen-Or, L. Liu, and Y. Xiong. Photo-inspired
model-driven 3d object modeling. In ACM Transactions on Graphics, volume 30,
page 80. ACM, 2011.

Bibliography

220

[266] Kai Xu, Hao Zhang, Daniel Cohen-Or, and Baoquan Chen. Fit and diverse:
Set evolution for inspiring 3d shape galleries. ACM Transactions on Graphics,
31(4):XXX, August 2012.
[267] Weiwei Xu, Jun Wang, KangKang Yin, Kun Zhou, Michiel van de Panne, Falai
Chen, and Baining Guo. Joint-aware manipulation of deformable models. ACM
Transactions on Graphics, 28(3):35:1–35:9, July 2009.
[268] Yong-Liang Yang, Yi-Jun Yang, Helmut Pottmann, and Niloy J. Mitra. Shape
space exploration of constrained meshes. ACM Transactions on Graphics,
30:124:1–124:12, December 2011.
[269] X. Yin, P. Wonka, and A. Razdan. Generating 3d building models from architectural drawings: A survey. Computer Graphics and Applications, IEEE,
29(1):20–30, 2009.
[270] T. Yokomori. Stochastic characterizations of e0l languages. Information and
Control, 45(1):26–33, 1980.
[271] S. Yoshizawa, A. Belyaev, and H.P. Seidel. Skeleton-based variational mesh
deformations. In Computer Graphics Forum, volume 26, pages 255–264. Wiley
Online Library, 2007.
[272] Lap-Fai Yu, Sai-Kit Yeung, Chi-Keung Tang, Demetri Terzopoulos, Tony F.
Chan, and Stanley J. Osher. Make it home: automatic optimization of furniture
arrangement. ACM Transactions on Graphics, 30:86:1–86:12, July 2011.
[273] K. Yue, R. Krishnamurti, and F. Gobler. Computation-friendly shape grammars.
Proceedings of CAAD futures, 2009.
[274] Q.Y. Zhou and U. Neumann. Fast and extensible building modeling from airborne lidar data. In Proceedings of the 16th ACM SIGSPATIAL international
conference on Advances in geographic information systems, page 7. ACM, 2008.

